{
  "language": "Solidity",
  "sources": {
    "contracts/fish/governance/ApprovalReceiver.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"./ErrorDecoder.sol\";\nimport \"../token/IApproveAndCall.sol\";\n\n/**\n * @title Base contract for receiving approval from SOV token.\n */\ncontract ApprovalReceiver is ErrorDecoder, IApproveAndCall {\n\tmodifier onlyThisContract() {\n\t\t// Accepts calls only from receiveApproval function.\n\t\trequire(msg.sender == address(this), \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Receives approval from SOV token.\n\t * @param _data The data will be used for low level call.\n\t */\n\tfunction receiveApproval(\n\t\taddress _sender,\n\t\tuint256 _amount,\n\t\taddress _token,\n\t\tbytes calldata _data\n\t) external {\n\t\t// Accepts calls only from SOV token.\n\t\trequire(msg.sender == _getToken(), \"unauthorized\");\n\t\trequire(msg.sender == _token, \"unauthorized\");\n\n\t\t// Only allowed methods.\n\t\tbool isAllowed = false;\n\t\tbytes4[] memory selectors = _getSelectors();\n\t\tbytes4 sig = _getSig(_data);\n\t\tfor (uint256 i = 0; i < selectors.length; i++) {\n\t\t\tif (sig == selectors[i]) {\n\t\t\t\tisAllowed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequire(isAllowed, \"method is not allowed\");\n\n\t\t// Check sender and amount.\n\t\taddress sender;\n\t\tuint256 amount;\n\t\t(, sender, amount) = abi.decode(abi.encodePacked(bytes28(0), _data), (bytes32, address, uint256));\n\t\trequire(sender == _sender, \"sender mismatch\");\n\t\trequire(amount == _amount, \"amount mismatch\");\n\n\t\t_call(_data);\n\t}\n\n\t/**\n\t * @notice Returns token address, only this address can be a sender for receiveApproval.\n\t * @dev Should be overridden in child contracts, otherwise error will be thrown.\n\t * @return By default, 0x. When overriden, the token address making the call.\n\t */\n\tfunction _getToken() internal view returns (address) {\n\t\treturn address(0);\n\t}\n\n\t/**\n\t * @notice Returns list of function selectors allowed to be invoked.\n\t * @dev Should be overridden in child contracts, otherwise error will be thrown.\n\t * @return By default, empty array. When overriden, allowed selectors.\n\t */\n\tfunction _getSelectors() internal view returns (bytes4[] memory) {\n\t\treturn new bytes4[](0);\n\t}\n\n\t/**\n\t * @notice Makes call and reverts w/ enhanced error message.\n\t * @param _data Error message as bytes.\n\t */\n\tfunction _call(bytes memory _data) internal {\n\t\t(bool success, bytes memory returnData) = address(this).call(_data);\n\t\tif (!success) {\n\t\t\tif (returnData.length <= ERROR_MESSAGE_SHIFT) {\n\t\t\t\trevert(\"receiveApproval: Transaction execution reverted.\");\n\t\t\t} else {\n\t\t\t\trevert(_addErrorMessage(\"receiveApproval: \", string(returnData)));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Extracts the called function selector, a hash of the signature.\n\t * @dev The first four bytes of the call data for a function call specifies\n\t * the function to be called. It is the first (left, high-order in big-endian)\n\t * four bytes of the Keccak-256 (SHA-3) hash of the signature of the function.\n\t * Solidity doesn't yet support a casting of byte[4] to bytes4.\n\t * Example:\n\t *  msg.data:\n\t *    0xcdcd77c000000000000000000000000000000000000000000000000000000000000\n\t *    000450000000000000000000000000000000000000000000000000000000000000001\n\t *  selector (or method ID): 0xcdcd77c0\n\t *  signature: baz(uint32,bool)\n\t * @param _data The msg.data from the low level call.\n\t * @return sig First 4 bytes of msg.data i.e. the selector, hash of the signature.\n\t */\n\tfunction _getSig(bytes memory _data) internal pure returns (bytes4 sig) {\n\t\tassembly {\n\t\t\tsig := mload(add(_data, 32))\n\t\t}\n\t}\n}\n"
    },
    "contracts/fish/governance/ErrorDecoder.sol": {
      "content": "pragma solidity ^0.5.17;\n\n/**\n * @title Base contract to properly handle returned data on failed calls\n * @dev On EVM if the return data length of a call is less than 68,\n * then the transaction fails silently without a revert message!\n *\n * As described in the Solidity documentation\n * https://solidity.readthedocs.io/en/v0.5.17/control-structures.html#revert\n * the revert reason is an ABI-encoded string consisting of:\n * 0x08c379a0 // Function selector (method id) for \"Error(string)\" signature\n * 0x0000000000000000000000000000000000000000000000000000000000000020 // Data offset\n * 0x000000000000000000000000000000000000000000000000000000000000001a // String length\n * 0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 // String data\n *\n * Another example, debug data from test:\n *   0x08c379a0\n *   0000000000000000000000000000000000000000000000000000000000000020\n *   0000000000000000000000000000000000000000000000000000000000000034\n *   54696d656c6f636b3a3a73657444656c61793a2044656c6179206d7573742065\n *   7863656564206d696e696d756d2064656c61792e000000000000000000000000\n *\n * Parsed into:\n *   Data offset: 20\n *   Length: 34\n *   Error message:\n *     54696d656c6f636b3a3a73657444656c61793a2044656c6179206d7573742065\n *     7863656564206d696e696d756d2064656c61792e000000000000000000000000\n */\ncontract ErrorDecoder {\n\tuint256 constant ERROR_MESSAGE_SHIFT = 68; // EVM silent revert error string length\n\n\t/**\n\t * @notice Concats two error strings taking into account ERROR_MESSAGE_SHIFT.\n\t * @param str1 First string, usually a hardcoded context written by dev.\n\t * @param str2 Second string, usually the error message from the reverted call.\n\t * @return The concatenated error string\n\t */\n\tfunction _addErrorMessage(string memory str1, string memory str2) internal pure returns (string memory) {\n\t\tbytes memory bytesStr1 = bytes(str1);\n\t\tbytes memory bytesStr2 = bytes(str2);\n\t\tstring memory str12 = new string(bytesStr1.length + bytesStr2.length - ERROR_MESSAGE_SHIFT);\n\t\tbytes memory bytesStr12 = bytes(str12);\n\t\tuint256 j = 0;\n\t\tfor (uint256 i = 0; i < bytesStr1.length; i++) {\n\t\t\tbytesStr12[j++] = bytesStr1[i];\n\t\t}\n\t\tfor (uint256 i = ERROR_MESSAGE_SHIFT; i < bytesStr2.length; i++) {\n\t\t\tbytesStr12[j++] = bytesStr2[i];\n\t\t}\n\t\treturn string(bytesStr12);\n\t}\n}\n"
    },
    "contracts/fish/token/IApproveAndCall.sol": {
      "content": "pragma solidity ^0.5.17;\n\n/**\n * @title Interface for contract governance/ApprovalReceiver.sol\n * @dev Interfaces are used to cast a contract address into a callable instance.\n */\ninterface IApproveAndCall {\n\t/**\n\t * @notice Receives approval from Fish token.\n\t * @param _sender The sender of Fish.approveAndCall function.\n\t * @param _amount The amount was approved.\n\t * @param _token The address of token.\n\t * @param _data The data will be used for low level call.\n\t * */\n\tfunction receiveApproval(\n\t\taddress _sender,\n\t\tuint256 _amount,\n\t\taddress _token,\n\t\tbytes calldata _data\n\t) external;\n}\n"
    },
    "contracts/fish/governance/Vesting/VestingLogic.sol": {
      "content": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../Staking/Staking.sol\";\nimport \"../IFeeSharingProxy.sol\";\nimport \"./IVesting.sol\";\nimport \"../ApprovalReceiver.sol\";\nimport \"./VestingStorage.sol\";\n\n/**\n * @title Vesting Logic contract.\n * @notice Staking, delegating and withdrawal functionality.\n * @dev Deployed by a VestingFactory contract.\n * */\ncontract VestingLogic is IVesting, VestingStorage, ApprovalReceiver {\n\t/* Events */\n\n\tevent TokensStaked(address indexed caller, uint256 amount);\n\tevent VotesDelegated(address indexed caller, address delegatee);\n\tevent TokensWithdrawn(address indexed caller, address receiver);\n\tevent DividendsCollected(address indexed caller, address loanPoolToken, address receiver, uint32 maxCheckpoints);\n\tevent MigratedToNewStakingContract(address indexed caller, address newStakingContract);\n\n\t/* Modifiers */\n\n\t/**\n\t * @dev Throws if called by any account other than the token owner or the contract owner.\n\t */\n\tmodifier onlyOwners() {\n\t\trequire(msg.sender == tokenOwner || isOwner(), \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the token owner.\n\t */\n\tmodifier onlyTokenOwner() {\n\t\trequire(msg.sender == tokenOwner, \"unauthorized\");\n\t\t_;\n\t}\n\n\t/* Functions */\n\n\t/**\n\t * @notice Stakes tokens according to the vesting schedule.\n\t * @param _amount The amount of tokens to stake.\n\t * */\n\tfunction stakeTokens(uint256 _amount) public {\n\t\t_stakeTokens(msg.sender, _amount);\n\t}\n\n\t/**\n\t * @notice Stakes tokens according to the vesting schedule.\n\t * @dev This function will be invoked from receiveApproval.\n\t * @dev SOV.approveAndCall -> this.receiveApproval -> this.stakeTokensWithApproval\n\t * @param _sender The sender of SOV.approveAndCall\n\t * @param _amount The amount of tokens to stake.\n\t * */\n\tfunction stakeTokensWithApproval(address _sender, uint256 _amount) public onlyThisContract {\n\t\t_stakeTokens(_sender, _amount);\n\t}\n\n\t/**\n\t * @notice Stakes tokens according to the vesting schedule. Low level function.\n\t * @dev Once here the allowance of tokens is taken for granted.\n\t * @param _sender The sender of tokens to stake.\n\t * @param _amount The amount of tokens to stake.\n\t * */\n\tfunction _stakeTokens(address _sender, uint256 _amount) internal {\n\t\t/// @dev Maybe better to allow staking unil the cliff was reached.\n\t\tif (startDate == 0) {\n\t\t\tstartDate = staking.timestampToLockDate(block.timestamp);\n\t\t}\n\t\tendDate = staking.timestampToLockDate(block.timestamp + duration);\n\n\t\t/// @dev Transfer the tokens to this contract.\n\t\tbool success = SOV.transferFrom(_sender, address(this), _amount);\n\t\trequire(success);\n\n\t\t/// @dev Allow the staking contract to access them.\n\t\tSOV.approve(address(staking), _amount);\n\n\t\tstaking.stakesBySchedule(_amount, cliff, duration, FOUR_WEEKS, address(this), tokenOwner);\n\n\t\temit TokensStaked(_sender, _amount);\n\t}\n\n\t/**\n\t * @notice Delegate votes from `msg.sender` which are locked until lockDate\n\t * to `delegatee`.\n\t * @param _delegatee The address to delegate votes to.\n\t * */\n\tfunction delegate(address _delegatee) public onlyTokenOwner {\n\t\trequire(_delegatee != address(0), \"delegatee address invalid\");\n\n\t\t/// @dev Withdraw for each unlocked position.\n\t\tfor (uint256 i = startDate + cliff; i <= endDate; i += FOUR_WEEKS) {\n\t\t\tstaking.delegate(_delegatee, i);\n\t\t}\n\t\temit VotesDelegated(msg.sender, _delegatee);\n\t}\n\n\t/**\n\t * @notice Withdraws all tokens from the staking contract and\n\t * forwards them to an address specified by the token owner.\n\t * @param receiver The receiving address.\n\t * @dev Can be called only by owner.\n\t * */\n\tfunction governanceWithdrawTokens(address receiver) public {\n\t\trequire(msg.sender == address(staking), \"unauthorized\");\n\n\t\t_withdrawTokens(receiver, true);\n\t}\n\n\t/**\n\t * @notice Withdraws unlocked tokens from the staking contract and\n\t * forwards them to an address specified by the token owner.\n\t * @param receiver The receiving address.\n\t * */\n\tfunction withdrawTokens(address receiver) public onlyOwners {\n\t\t_withdrawTokens(receiver, false);\n\t}\n\n\t/**\n\t * @notice Withdraws tokens from the staking contract and forwards them\n\t * to an address specified by the token owner. Low level function.\n\t * @dev Once here the caller permission is taken for granted.\n\t * @param receiver The receiving address.\n\t * @param isGovernance Whether all tokens (true)\n\t * or just unlocked tokens (false).\n\t * */\n\tfunction _withdrawTokens(address receiver, bool isGovernance) internal {\n\t\trequire(receiver != address(0), \"receiver address invalid\");\n\n\t\tuint96 stake;\n\n\t\t/// @dev Usually we just need to iterate over the possible dates until now.\n\t\tuint256 end;\n\n\t\t/// @dev In the unlikely case that all tokens have been unlocked early,\n\t\t///   allow to withdraw all of them.\n\t\tif (staking.allUnlocked() || isGovernance) {\n\t\t\tend = endDate;\n\t\t} else {\n\t\t\tend = block.timestamp;\n\t\t}\n\n\t\t/// @dev Withdraw for each unlocked position.\n\t\tfor (uint256 i = startDate + cliff; i <= end; i += FOUR_WEEKS) {\n\t\t\t/// @dev Read amount to withdraw.\n\t\t\tstake = staking.getPriorUserStakeByDate(address(this), i, block.number - 1);\n\n\t\t\t/// @dev Withdraw if > 0\n\t\t\tif (stake > 0) {\n\t\t\t\tif (isGovernance) {\n\t\t\t\t\tstaking.governanceWithdraw(stake, i, receiver);\n\t\t\t\t} else {\n\t\t\t\t\tstaking.withdraw(stake, i, receiver);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\temit TokensWithdrawn(msg.sender, receiver);\n\t}\n\n\t/**\n\t * @notice Collect dividends from fee sharing proxy.\n\t * @param _loanPoolToken The loan pool token address.\n\t * @param _maxCheckpoints Maximum number of checkpoints to be processed.\n\t * @param _receiver The receiver of tokens or msg.sender\n\t * */\n\tfunction collectDividends(\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints,\n\t\taddress _receiver\n\t) public onlyOwners {\n\t\trequire(_receiver != address(0), \"receiver address invalid\");\n\n\t\t/// @dev Invokes the fee sharing proxy.\n\t\tfeeSharingProxy.withdraw(_loanPoolToken, _maxCheckpoints, _receiver);\n\n\t\temit DividendsCollected(msg.sender, _loanPoolToken, _receiver, _maxCheckpoints);\n\t}\n\n\t/**\n\t * @notice Allows the owners to migrate the positions\n\t * to a new staking contract.\n\t * */\n\tfunction migrateToNewStakingContract() public onlyOwners {\n\t\tstaking.migrateToNewStakingContract();\n\t\tstaking = Staking(staking.newStakingContract());\n\t\temit MigratedToNewStakingContract(msg.sender, address(staking));\n\t}\n\n\t/**\n\t * @notice Overrides default ApprovalReceiver._getToken function to\n\t * register SOV token on this contract.\n\t * @return The address of SOV token.\n\t * */\n\tfunction _getToken() internal view returns (address) {\n\t\treturn address(SOV);\n\t}\n\n\t/**\n\t * @notice Overrides default ApprovalReceiver._getSelectors function to\n\t * register stakeTokensWithApproval selector on this contract.\n\t * @return The array of registered selectors on this contract.\n\t * */\n\tfunction _getSelectors() internal view returns (bytes4[] memory) {\n\t\tbytes4[] memory selectors = new bytes4[](1);\n\t\tselectors[0] = this.stakeTokensWithApproval.selector;\n\t\treturn selectors;\n\t}\n}\n"
    },
    "@openzeppelin/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/fish/interfaces/IERC20.sol": {
      "content": "/**\n * Copyright 2017-2021, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\npragma solidity ^0.5.17;\n\ncontract IERC20 {\n\tstring public name;\n\tuint8 public decimals;\n\tstring public symbol;\n\n\tfunction totalSupply() public view returns (uint256);\n\n\tfunction balanceOf(address _who) public view returns (uint256);\n\n\tfunction allowance(address _owner, address _spender) public view returns (uint256);\n\n\tfunction approve(address _spender, uint256 _value) public returns (bool);\n\n\tfunction transfer(address _to, uint256 _value) public returns (bool);\n\n\tfunction transferFrom(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value\n\t) public returns (bool);\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/fish/governance/Staking/Staking.sol": {
      "content": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"./WeightedStaking.sol\";\nimport \"./IStaking.sol\";\nimport \"../../rsk/RSKAddrValidator.sol\";\nimport \"../Vesting/ITeamVesting.sol\";\nimport \"../ApprovalReceiver.sol\";\n\n/**\n * @title Staking contract.\n * @notice Pay-in and pay-out function for staking and withdrawing tokens.\n * Staking is delegated and vested: To gain voting power, SOV holders must\n * stake their SOV for a given period of time. Aside from Bitocracy\n * participation, there's a financially-rewarding reason for staking SOV.\n * Tokenholders who stake their SOV receive staking rewards, a pro-rata share\n * of the revenue that the platform generates from various transaction fees\n * plus revenues from stakers who have a portion of their SOV slashed for\n * early unstaking.\n * */\ncontract Staking is IStaking, WeightedStaking, ApprovalReceiver {\n\t/**\n\t * @notice Stake the given amount for the given duration of time.\n\t * @param amount The number of tokens to stake.\n\t * @param until Timestamp indicating the date until which to stake.\n\t * @param stakeFor The address to stake the tokens for or 0x0 if staking for oneself.\n\t * @param delegatee The address of the delegatee or 0x0 if there is none.\n\t * */\n\tfunction stake(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) external {\n\t\t_stake(msg.sender, amount, until, stakeFor, delegatee, false);\n\t}\n\n\t/**\n\t * @notice Stake the given amount for the given duration of time.\n\t * @dev This function will be invoked from receiveApproval\n\t * @dev SOV.approveAndCall -> this.receiveApproval -> this.stakeWithApproval\n\t * @param sender The sender of SOV.approveAndCall\n\t * @param amount The number of tokens to stake.\n\t * @param until Timestamp indicating the date until which to stake.\n\t * @param stakeFor The address to stake the tokens for or 0x0 if staking for oneself.\n\t * @param delegatee The address of the delegatee or 0x0 if there is none.\n\t * */\n\tfunction stakeWithApproval(\n\t\taddress sender,\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) public onlyThisContract {\n\t\t_stake(sender, amount, until, stakeFor, delegatee, false);\n\t}\n\n\t/**\n\t * @notice Send sender's tokens to this contract and update its staked balance.\n\t * @param sender The sender of the tokens.\n\t * @param amount The number of tokens to send.\n\t * @param until The date until which the tokens will be staked.\n\t * @param stakeFor The beneficiary whose stake will be increased.\n\t * @param delegatee The address of the delegatee or stakeFor if default 0x0.\n\t * @param timeAdjusted Whether fixing date to stacking periods or not.\n\t * */\n\tfunction _stake(\n\t\taddress sender,\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress stakeFor,\n\t\taddress delegatee,\n\t\tbool timeAdjusted\n\t) internal {\n\t\trequire(amount > 0, \"Staking::stake: amount of tokens to stake needs to be bigger than 0\");\n\n\t\tif (!timeAdjusted) {\n\t\t\tuntil = timestampToLockDate(until);\n\t\t}\n\t\trequire(until > block.timestamp, \"Staking::timestampToLockDate: staking period too short\");\n\n\t\t/// @dev Stake for the sender if not specified otherwise.\n\t\tif (stakeFor == address(0)) {\n\t\t\tstakeFor = sender;\n\t\t}\n\n\t\t/// @dev Delegate for stakeFor if not specified otherwise.\n\t\tif (delegatee == address(0)) {\n\t\t\tdelegatee = stakeFor;\n\t\t}\n\n\t\t/// @dev Do not stake longer than the max duration.\n\t\tif (!timeAdjusted) {\n\t\t\tuint256 latest = timestampToLockDate(block.timestamp + MAX_DURATION);\n\t\t\tif (until > latest) until = latest;\n\t\t}\n\n\t\tuint96 previousBalance = currentBalance(stakeFor, until);\n\n\t\t/// @dev Increase stake.\n\t\t_increaseStake(sender, amount, stakeFor, until);\n\n\t\tif (previousBalance == 0) {\n\t\t\t/// @dev Regular delegation if it's a first stake.\n\t\t\t_delegate(stakeFor, delegatee, until);\n\t\t} else {\n\t\t\taddress previousDelegatee = delegates[stakeFor][until];\n\t\t\tif (previousDelegatee != delegatee) {\n\t\t\t\t/// @dev Update delegatee.\n\t\t\t\tdelegates[stakeFor][until] = delegatee;\n\n\t\t\t\t/// @dev Decrease stake on previous balance for previous delegatee.\n\t\t\t\t_decreaseDelegateStake(previousDelegatee, until, previousBalance);\n\n\t\t\t\t/// @dev Add previousBalance to amount.\n\t\t\t\tamount = add96(previousBalance, amount, \"Staking::stake: balance overflow\");\n\t\t\t}\n\n\t\t\t/// @dev Increase stake.\n\t\t\t_increaseDelegateStake(delegatee, until, amount);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Extend the staking duration until the specified date.\n\t * @param previousLock The old unlocking timestamp.\n\t * @param until The new unlocking timestamp in seconds.\n\t * */\n\tfunction extendStakingDuration(uint256 previousLock, uint256 until) public {\n\t\tuntil = timestampToLockDate(until);\n\t\trequire(previousLock <= until, \"Staking::extendStakingDuration: cannot reduce the staking duration\");\n\n\t\t/// @dev Do not exceed the max duration, no overflow possible.\n\t\tuint256 latest = timestampToLockDate(block.timestamp + MAX_DURATION);\n\t\tif (until > latest) until = latest;\n\n\t\t/// @dev Update checkpoints.\n\t\t/// @dev TODO James: Can reading stake at block.number -1 cause trouble with multiple tx in a block?\n\t\tuint96 amount = getPriorUserStakeByDate(msg.sender, previousLock, block.number - 1);\n\t\trequire(amount > 0, \"Staking::extendStakingDuration: nothing staked until the previous lock date\");\n\t\t_decreaseUserStake(msg.sender, previousLock, amount);\n\t\t_increaseUserStake(msg.sender, until, amount);\n\t\t_decreaseDailyStake(previousLock, amount);\n\t\t_increaseDailyStake(until, amount);\n\n\t\t/// @dev Delegate might change: if there is already a delegate set for the until date, it will remain the delegate for this position\n\t\taddress delegateFrom = delegates[msg.sender][previousLock];\n\t\taddress delegateTo = delegates[msg.sender][until];\n\t\tif (delegateTo == address(0)) {\n\t\t\tdelegateTo = delegateFrom;\n\t\t\tdelegates[msg.sender][until] = delegateFrom;\n\t\t}\n\t\tif (previousLock != until) {\n\t\t\tdelegates[msg.sender][previousLock] = address(0);\n\t\t}\n\t\t_decreaseDelegateStake(delegateFrom, previousLock, amount);\n\t\t_increaseDelegateStake(delegateTo, until, amount);\n\n\t\temit ExtendedStakingDuration(msg.sender, previousLock, until);\n\t}\n\n\t/**\n\t * @notice Send sender's tokens to this contract and update its staked balance.\n\t * @param sender The sender of the tokens.\n\t * @param amount The number of tokens to send.\n\t * @param stakeFor The beneficiary whose stake will be increased.\n\t * @param until The date until which the tokens will be staked.\n\t * */\n\tfunction _increaseStake(\n\t\taddress sender,\n\t\tuint96 amount,\n\t\taddress stakeFor,\n\t\tuint256 until\n\t) internal {\n\t\t/// @dev Retrieve the SOV tokens.\n\t\tbool success = SOVToken.transferFrom(sender, address(this), amount);\n\t\trequire(success);\n\n\t\t/// @dev Increase staked balance.\n\t\tuint96 balance = currentBalance(stakeFor, until);\n\t\tbalance = add96(balance, amount, \"Staking::increaseStake: balance overflow\");\n\n\t\t/// @dev Update checkpoints.\n\t\t_increaseDailyStake(until, amount);\n\t\t_increaseUserStake(stakeFor, until, amount);\n\n\t\temit TokensStaked(stakeFor, amount, until, balance);\n\t}\n\n\t/**\n\t * @notice Stake tokens according to the vesting schedule.\n\t * @param amount The amount of tokens to stake.\n\t * @param cliff The time interval to the first withdraw.\n\t * @param duration The staking duration.\n\t * @param intervalLength The length of each staking interval when cliff passed.\n\t * @param stakeFor The address to stake the tokens for or 0x0 if staking for oneself.\n\t * @param delegatee The address of the delegatee or 0x0 if there is none.\n\t * */\n\tfunction stakesBySchedule(\n\t\tuint256 amount,\n\t\tuint256 cliff,\n\t\tuint256 duration,\n\t\tuint256 intervalLength,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) public {\n\t\t/**\n\t\t * @dev Stake them until lock dates according to the vesting schedule.\n\t\t * Note: because staking is only possible in periods of 2 weeks,\n\t\t * the total duration might end up a bit shorter than specified\n\t\t * depending on the date of staking.\n\t\t * */\n\t\tuint256 start = timestampToLockDate(block.timestamp + cliff);\n\t\tif (duration > MAX_DURATION) {\n\t\t\tduration = MAX_DURATION;\n\t\t}\n\t\tuint256 end = timestampToLockDate(block.timestamp + duration);\n\t\tuint256 numIntervals = (end - start) / intervalLength + 1;\n\t\tuint256 stakedPerInterval = amount / numIntervals;\n\t\t/// @dev stakedPerInterval might lose some dust on rounding. Add it to the first staking date.\n\t\tif (numIntervals >= 1) {\n\t\t\t_stake(msg.sender, uint96(amount - stakedPerInterval * (numIntervals - 1)), start, stakeFor, delegatee, true);\n\t\t}\n\t\t/// @dev Stake the rest in 4 week intervals.\n\t\tfor (uint256 i = start + intervalLength; i <= end; i += intervalLength) {\n\t\t\t/// @dev Stakes for itself, delegates to the owner.\n\t\t\t_stake(msg.sender, uint96(stakedPerInterval), i, stakeFor, delegatee, true);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Withdraw the given amount of tokens if they are unlocked.\n\t * @param amount The number of tokens to withdraw.\n\t * @param until The date until which the tokens were staked.\n\t * @param receiver The receiver of the tokens. If not specified, send to the msg.sender\n\t * */\n\tfunction withdraw(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress receiver\n\t) public {\n\t\t_withdraw(amount, until, receiver, false);\n\t}\n\n\t/**\n\t * @notice Withdraw the given amount of tokens.\n\t * @param amount The number of tokens to withdraw.\n\t * @param until The date until which the tokens were staked.\n\t * @param receiver The receiver of the tokens. If not specified, send to the msg.sender\n\t * @dev Can be invoked only by whitelisted contract passed to governanceWithdrawVesting\n\t * */\n\tfunction governanceWithdraw(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress receiver\n\t) public {\n\t\trequire(vestingWhitelist[msg.sender], \"unauthorized\");\n\n\t\t_withdraw(amount, until, receiver, true);\n\t}\n\n\t/**\n\t * @notice Withdraw tokens for vesting contract.\n\t * @param vesting The address of Vesting contract.\n\t * @param receiver The receiver of the tokens. If not specified, send to the msg.sender\n\t * @dev Can be invoked only by whitelisted contract passed to governanceWithdrawVesting.\n\t * */\n\tfunction governanceWithdrawVesting(address vesting, address receiver) public onlyOwner {\n\t\tvestingWhitelist[vesting] = true;\n\t\tITeamVesting(vesting).governanceWithdrawTokens(receiver);\n\t\tvestingWhitelist[vesting] = false;\n\n\t\temit VestingTokensWithdrawn(vesting, receiver);\n\t}\n\n\t/**\n\t * @notice Send user' staked tokens to a receiver taking into account punishments.\n\t * Sovryn encourages long-term commitment and thinking. When/if you unstake before\n\t * the end of the staking period, a percentage of the original staking amount will\n\t * be slashed. This amount is also added to the reward pool and is distributed\n\t * between all other stakers.\n\t *\n\t * @param amount The number of tokens to withdraw.\n\t * @param until The date until which the tokens were staked.\n\t * @param receiver The receiver of the tokens. If not specified, send to the msg.sender\n\t * @param isGovernance Whether all tokens (true)\n\t * or just unlocked tokens (false).\n\t * */\n\tfunction _withdraw(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress receiver,\n\t\tbool isGovernance\n\t) internal {\n\t\tuntil = _adjustDateForOrigin(until);\n\t\t_validateWithdrawParams(amount, until);\n\n\t\t/// @dev Determine the receiver.\n\t\tif (receiver == address(0)) receiver = msg.sender;\n\n\t\t/// @dev Update the checkpoints.\n\t\t_decreaseDailyStake(until, amount);\n\t\t_decreaseUserStake(msg.sender, until, amount);\n\t\t_decreaseDelegateStake(delegates[msg.sender][until], until, amount);\n\n\t\t/// @dev Early unstaking should be punished.\n\t\tif (block.timestamp < until && !allUnlocked && !isGovernance) {\n\t\t\tuint96 punishedAmount = _getPunishedAmount(amount, until);\n\t\t\tamount -= punishedAmount;\n\n\t\t\t/// @dev punishedAmount can be 0 if block.timestamp are very close to 'until'\n\t\t\tif (punishedAmount > 0) {\n\t\t\t\trequire(address(feeSharing) != address(0), \"Staking::withdraw: FeeSharing address wasn't set\");\n\t\t\t\t/// @dev Move punished amount to fee sharing.\n\t\t\t\t/// @dev Approve transfer here and let feeSharing do transfer and write checkpoint.\n\t\t\t\tSOVToken.approve(address(feeSharing), punishedAmount);\n\t\t\t\tfeeSharing.transferTokens(address(SOVToken), punishedAmount);\n\t\t\t}\n\t\t}\n\n\t\t/// @dev transferFrom\n\t\tbool success = SOVToken.transfer(receiver, amount);\n\t\trequire(success, \"Staking::withdraw: Token transfer failed\");\n\n\t\temit TokensWithdrawn(msg.sender, receiver, amount);\n\t}\n\n\t/**\n\t * @notice Get available and punished amount for withdrawing.\n\t * @param amount The number of tokens to withdraw.\n\t * @param until The date until which the tokens were staked.\n\t * */\n\tfunction getWithdrawAmounts(uint96 amount, uint256 until) public view returns (uint96, uint96) {\n\t\t_validateWithdrawParams(amount, until);\n\t\tuint96 punishedAmount = _getPunishedAmount(amount, until);\n\t\treturn (amount - punishedAmount, punishedAmount);\n\t}\n\n\t/**\n\t * @notice Get punished amount for withdrawing.\n\t * @param amount The number of tokens to withdraw.\n\t * @param until The date until which the tokens were staked.\n\t * */\n\tfunction _getPunishedAmount(uint96 amount, uint256 until) internal view returns (uint96) {\n\t\tuint256 date = timestampToLockDate(block.timestamp);\n\t\tuint96 weight = computeWeightByDate(until, date); /// @dev (10 - 1) * WEIGHT_FACTOR\n\t\tweight = weight * weightScaling;\n\t\treturn (amount * weight) / WEIGHT_FACTOR / 100;\n\t}\n\n\t/**\n\t * @notice Validate withdraw parameters.\n\t * @param amount The number of tokens to withdraw.\n\t * @param until The date until which the tokens were staked.\n\t * */\n\tfunction _validateWithdrawParams(uint96 amount, uint256 until) internal view {\n\t\trequire(amount > 0, \"Staking::withdraw: amount of tokens to be withdrawn needs to be bigger than 0\");\n\t\tuint96 balance = getPriorUserStakeByDate(msg.sender, until, block.number - 1);\n\t\trequire(amount <= balance, \"Staking::withdraw: not enough balance\");\n\t}\n\n\t/**\n\t * @notice Get the current balance of an account locked until a certain date.\n\t * @param account The user address.\n\t * @param lockDate The lock date.\n\t * @return The stake amount.\n\t * */\n\tfunction currentBalance(address account, uint256 lockDate) internal view returns (uint96) {\n\t\treturn userStakingCheckpoints[account][lockDate][numUserStakingCheckpoints[account][lockDate] - 1].stake;\n\t}\n\n\t/**\n\t * @notice Get the number of staked tokens held by the user account.\n\t * @dev Iterate checkpoints adding up stakes.\n\t * @param account The address of the account to get the balance of.\n\t * @return The number of tokens held.\n\t * */\n\tfunction balanceOf(address account) public view returns (uint96 balance) {\n\t\tfor (uint256 i = kickoffTS; i <= block.timestamp + MAX_DURATION; i += TWO_WEEKS) {\n\t\t\tbalance = add96(balance, currentBalance(account, i), \"Staking::balanceOf: overflow\");\n\t\t}\n\t}\n\n\t/**\n\t * @notice Delegate votes from `msg.sender` which are locked until lockDate to `delegatee`.\n\t * @param delegatee The address to delegate votes to.\n\t * @param lockDate the date if the position to delegate.\n\t * */\n\tfunction delegate(address delegatee, uint256 lockDate) public {\n\t\treturn _delegate(msg.sender, delegatee, lockDate);\n\t}\n\n\t/**\n\t * @notice Delegates votes from signatory to a delegatee account.\n\t * Voting with EIP-712 Signatures.\n\t *\n\t * Voting power can be delegated to any address, and then can be used to\n\t * vote on proposals. A key benefit to users of by-signature functionality\n\t * is that they can create a signed vote transaction for free, and have a\n\t * trusted third-party spend rBTC(or ETH) on gas fees and write it to the\n\t * blockchain for them.\n\t *\n\t * The third party in this scenario, submitting the SOV-holderâ€™s signed\n\t * transaction holds a voting power that is for only a single proposal.\n\t * The signatory still holds the power to vote on their own behalf in\n\t * the proposal if the third party has not yet published the signed\n\t * transaction that was given to them.\n\t *\n\t * @dev The signature needs to be broken up into 3 parameters, known as\n\t * v, r and s:\n\t * const r = '0x' + sig.substring(2).substring(0, 64);\n\t * const s = '0x' + sig.substring(2).substring(64, 128);\n\t * const v = '0x' + sig.substring(2).substring(128, 130);\n\t *\n\t * @param delegatee The address to delegate votes to.\n\t * @param lockDate The date until which the position is locked.\n\t * @param nonce The contract state required to match the signature.\n\t * @param expiry The time at which to expire the signature.\n\t * @param v The recovery byte of the signature.\n\t * @param r Half of the ECDSA signature pair.\n\t * @param s Half of the ECDSA signature pair.\n\t * */\n\tfunction delegateBySig(\n\t\taddress delegatee,\n\t\tuint256 lockDate,\n\t\tuint256 nonce,\n\t\tuint256 expiry,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public {\n\t\t/**\n\t\t * @dev The DOMAIN_SEPARATOR is a hash that uniquely identifies a\n\t\t * smart contract. It is built from a string denoting it as an\n\t\t * EIP712 Domain, the name of the token contract, the version,\n\t\t * the chainId in case it changes, and the address that the\n\t\t * contract is deployed at.\n\t\t * */\n\t\tbytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n\n\t\t/// @dev GovernorAlpha uses BALLOT_TYPEHASH, while Staking uses DELEGATION_TYPEHASH\n\t\tbytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, lockDate, nonce, expiry));\n\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\t\taddress signatory = ecrecover(digest, v, r, s);\n\n\t\t/// @dev Verify address is not null and PK is not null either.\n\t\trequire(RSKAddrValidator.checkPKNotZero(signatory), \"Staking::delegateBySig: invalid signature\");\n\t\trequire(nonce == nonces[signatory]++, \"Staking::delegateBySig: invalid nonce\");\n\t\trequire(now <= expiry, \"Staking::delegateBySig: signature expired\");\n\t\treturn _delegate(signatory, delegatee, lockDate);\n\t}\n\n\t/**\n\t * @notice Get the current votes balance for a user account.\n\t * @param account The address to get votes balance.\n\t * @dev This is a wrapper to simplify arguments. The actual computation is\n\t * performed on WeightedStaking parent contract.\n\t * @return The number of current votes for a user account.\n\t * */\n\tfunction getCurrentVotes(address account) external view returns (uint96) {\n\t\treturn getPriorVotes(account, block.number - 1, block.timestamp);\n\t}\n\n\t/**\n\t * @notice Get the current number of tokens staked for a day.\n\t * @param lockedTS The timestamp to get the staked tokens for.\n\t * */\n\tfunction getCurrentStakedUntil(uint256 lockedTS) external view returns (uint96) {\n\t\tuint32 nCheckpoints = numTotalStakingCheckpoints[lockedTS];\n\t\treturn nCheckpoints > 0 ? totalStakingCheckpoints[lockedTS][nCheckpoints - 1].stake : 0;\n\t}\n\n\t/**\n\t * @notice Set new delegatee. Move from user's current delegate to a new\n\t * delegatee the stake balance.\n\t * @param delegator The user address to move stake balance from its current delegatee.\n\t * @param delegatee The new delegatee. The address to move stake balance to.\n\t * @param lockedTS The lock date.\n\t * */\n\tfunction _delegate(\n\t\taddress delegator,\n\t\taddress delegatee,\n\t\tuint256 lockedTS\n\t) internal {\n\t\taddress currentDelegate = delegates[delegator][lockedTS];\n\t\tuint96 delegatorBalance = currentBalance(delegator, lockedTS);\n\t\tdelegates[delegator][lockedTS] = delegatee;\n\n\t\temit DelegateChanged(delegator, lockedTS, currentDelegate, delegatee);\n\n\t\t_moveDelegates(currentDelegate, delegatee, delegatorBalance, lockedTS);\n\t}\n\n\t/**\n\t * @notice Move an amount of delegate stake from a source address to a\n\t * destination address.\n\t * @param srcRep The address to get the staked amount from.\n\t * @param dstRep The address to send the staked amount to.\n\t * @param amount The staked amount to move.\n\t * @param lockedTS The lock date.\n\t * */\n\tfunction _moveDelegates(\n\t\taddress srcRep,\n\t\taddress dstRep,\n\t\tuint96 amount,\n\t\tuint256 lockedTS\n\t) internal {\n\t\tif (srcRep != dstRep && amount > 0) {\n\t\t\tif (srcRep != address(0)) _decreaseDelegateStake(srcRep, lockedTS, amount);\n\n\t\t\tif (dstRep != address(0)) _increaseDelegateStake(dstRep, lockedTS, amount);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Retrieve CHAIN_ID of the executing chain.\n\t *\n\t * Chain identifier (chainID) introduced in EIP-155 protects transaction\n\t * included into one chain from being included into another chain.\n\t * Basically, chain identifier is an integer number being used in the\n\t * processes of signing transactions and verifying transaction signatures.\n\t *\n\t * @dev As of version 0.5.12, Solidity includes an assembly function\n\t * chainid() that provides access to the new CHAINID opcode.\n\t *\n\t * TODO: chainId is included in block. So you can get chain id like\n\t * block timestamp or block number: block.chainid;\n\t * */\n\tfunction getChainId() internal pure returns (uint256) {\n\t\tuint256 chainId;\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\t\treturn chainId;\n\t}\n\n\t/**\n\t * @notice Allow the owner to set a new staking contract.\n\t * As a consequence it allows the stakers to migrate their positions\n\t * to the new contract.\n\t * @dev Doesn't have any influence as long as migrateToNewStakingContract\n\t * is not implemented.\n\t * @param _newStakingContract The address of the new staking contract.\n\t * */\n\tfunction setNewStakingContract(address _newStakingContract) public onlyOwner {\n\t\trequire(_newStakingContract != address(0), \"can't reset the new staking contract to 0\");\n\t\tnewStakingContract = _newStakingContract;\n\t}\n\n\t/**\n\t * @notice Allow the owner to set a fee sharing proxy contract.\n\t * We need it for unstaking with slashing.\n\t * @param _feeSharing The address of FeeSharingProxy contract.\n\t * */\n\tfunction setFeeSharing(address _feeSharing) public onlyOwner {\n\t\trequire(_feeSharing != address(0), \"FeeSharing address shouldn't be 0\");\n\t\tfeeSharing = IFeeSharingProxy(_feeSharing);\n\t}\n\n\t/**\n\t * @notice Allow the owner to set weight scaling.\n\t * We need it for unstaking with slashing.\n\t * @param _weightScaling The weight scaling.\n\t * */\n\tfunction setWeightScaling(uint96 _weightScaling) public onlyOwner {\n\t\trequire(\n\t\t\tMIN_WEIGHT_SCALING <= _weightScaling && _weightScaling <= MAX_WEIGHT_SCALING,\n\t\t\t\"weight scaling doesn't belong to range [1, 9]\"\n\t\t);\n\t\tweightScaling = _weightScaling;\n\t}\n\n\t/**\n\t * @notice Allow a staker to migrate his positions to the new staking contract.\n\t * @dev Staking contract needs to be set before by the owner.\n\t * Currently not implemented, just needed for the interface.\n\t *      In case it's needed at some point in the future,\n\t *      the implementation needs to be changed first.\n\t * */\n\tfunction migrateToNewStakingContract() public {\n\t\trequire(newStakingContract != address(0), \"there is no new staking contract set\");\n\t\t/// @dev implementation:\n\t\t/// @dev Iterate over all possible lock dates from now until now + MAX_DURATION.\n\t\t/// @dev Read the stake & delegate of the msg.sender\n\t\t/// @dev If stake > 0, stake it at the new contract until the lock date with the current delegate.\n\t}\n\n\t/**\n\t * @notice Allow the owner to unlock all tokens in case the staking contract\n\t * is going to be replaced\n\t * Note: Not reversible on purpose. once unlocked, everything is unlocked.\n\t * The owner should not be able to just quickly unlock to withdraw his own\n\t * tokens and lock again.\n\t * @dev Last resort.\n\t * */\n\tfunction unlockAllTokens() public onlyOwner {\n\t\tallUnlocked = true;\n\t\temit TokensUnlocked(SOVToken.balanceOf(address(this)));\n\t}\n\n\t/**\n\t * @notice Get list of stakes for a user account.\n\t * @param account The address to get stakes.\n\t * @return The arrays of dates and stakes.\n\t * */\n\tfunction getStakes(address account) external view returns (uint256[] memory dates, uint96[] memory stakes) {\n\t\tuint256 latest = timestampToLockDate(block.timestamp + MAX_DURATION);\n\n\t\t/// @dev Calculate stakes.\n\t\tuint256 count = 0;\n\t\t/// @dev We need to iterate from first possible stake date after deployment to the latest from current time.\n\t\tfor (uint256 i = kickoffTS + TWO_WEEKS; i <= latest; i += TWO_WEEKS) {\n\t\t\tif (currentBalance(account, i) > 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tdates = new uint256[](count);\n\t\tstakes = new uint96[](count);\n\n\t\t/// @dev We need to iterate from first possible stake date after deployment to the latest from current time.\n\t\tuint256 j = 0;\n\t\tfor (uint256 i = kickoffTS + TWO_WEEKS; i <= latest; i += TWO_WEEKS) {\n\t\t\tuint96 balance = currentBalance(account, i);\n\t\t\tif (balance > 0) {\n\t\t\t\tdates[j] = i;\n\t\t\t\tstakes[j] = balance;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Overrides default ApprovalReceiver._getToken function to\n\t * register SOV token on this contract.\n\t * @return The address of SOV token.\n\t * */\n\tfunction _getToken() internal view returns (address) {\n\t\treturn address(SOVToken);\n\t}\n\n\t/**\n\t * @notice Overrides default ApprovalReceiver._getSelectors function to\n\t * register stakeWithApproval selector on this contract.\n\t * @return The array of registered selectors on this contract.\n\t * */\n\tfunction _getSelectors() internal view returns (bytes4[] memory) {\n\t\tbytes4[] memory selectors = new bytes4[](1);\n\t\tselectors[0] = this.stakeWithApproval.selector;\n\t\treturn selectors;\n\t}\n}\n"
    },
    "contracts/fish/governance/IFeeSharingProxy.sol": {
      "content": "pragma solidity ^0.5.17;\n\n/**\n * @title Interface for contract governance/FeeSharingProxy.sol\n * @dev Interfaces are used to cast a contract address into a callable instance.\n * */\ninterface IFeeSharingProxy {\n\tfunction withdrawFees(address _token) external;\n\n\tfunction transferTokens(address _token, uint96 _amount) external;\n\n\tfunction withdraw(\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints,\n\t\taddress _receiver\n\t) external;\n}\n"
    },
    "contracts/fish/governance/Vesting/IVesting.sol": {
      "content": "pragma solidity ^0.5.17;\n\n/**\n * @title Interface for Vesting contract.\n * @dev Interfaces are used to cast a contract address into a callable instance.\n * This interface is used by VestingLogic contract to implement stakeTokens function\n * and on VestingRegistry contract to call IVesting(vesting).stakeTokens function\n * at a vesting instance.\n */\ninterface IVesting {\n\tfunction duration() external returns (uint256);\n\n\tfunction endDate() external returns (uint256);\n\n\tfunction stakeTokens(uint256 amount) external;\n}\n"
    },
    "contracts/fish/governance/Vesting/VestingStorage.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../Staking/Staking.sol\";\nimport \"../IFeeSharingProxy.sol\";\n\n/**\n * @title Vesting Storage Contract.\n *\n * @notice This contract is just the storage required for vesting.\n * It is parent of VestingLogic and TeamVesting.\n *\n * @dev Use Ownable as a parent to align storage structure for Logic and Proxy contracts.\n * */\ncontract VestingStorage is Ownable {\n\t/// @notice The SOV token contract.\n\tIERC20 public SOV;\n\n\t/// @notice The staking contract address.\n\tStaking public staking;\n\n\t/// @notice The owner of the vested tokens.\n\taddress public tokenOwner;\n\n\t/// @notice Fee sharing Proxy.\n\tIFeeSharingProxy public feeSharingProxy;\n\n\t/// @notice The cliff. After this time period the tokens begin to unlock.\n\tuint256 public cliff;\n\n\t/// @notice The duration. After this period all tokens will have been unlocked.\n\tuint256 public duration;\n\n\t/// @notice The start date of the vesting.\n\tuint256 public startDate;\n\n\t/// @notice The end date of the vesting.\n\tuint256 public endDate;\n\n\t/// @notice Constant used for computing the vesting dates.\n\tuint256 constant FOUR_WEEKS = 4 weeks;\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/fish/governance/Staking/WeightedStaking.sol": {
      "content": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"./Checkpoints.sol\";\n\n/**\n * @title Weighted Staking contract.\n * @notice Computation of power and votes used by FeeSharingProxy and\n * GovernorAlpha and Staking contracts w/ mainly 3 public functions:\n *   + getPriorTotalVotingPower => Total voting power.\n *   + getPriorVotes  => Delegatee voting power.\n *   + getPriorWeightedStake  => User Weighted Stake.\n * Staking contract inherits WeightedStaking.\n * FeeSharingProxy and GovernorAlpha invoke Staking instance functions.\n * */\ncontract WeightedStaking is Checkpoints {\n\t/************* TOTAL VOTING POWER COMPUTATION ************************/\n\n\t/**\n\t * @notice Compute the total voting power at a given time.\n\t * @param time The timestamp for which to calculate the total voting power.\n\t * @return The total voting power at the given time.\n\t * */\n\tfunction getPriorTotalVotingPower(uint32 blockNumber, uint256 time) public view returns (uint96 totalVotingPower) {\n\t\t/// @dev Start the computation with the exact or previous unlocking date (voting weight remians the same until the next break point).\n\t\tuint256 start = timestampToLockDate(time);\n\t\tuint256 end = start + MAX_DURATION;\n\n\t\t/// @dev Max 78 iterations.\n\t\tfor (uint256 i = start; i <= end; i += TWO_WEEKS) {\n\t\t\ttotalVotingPower = add96(\n\t\t\t\ttotalVotingPower,\n\t\t\t\t_totalPowerByDate(i, start, blockNumber),\n\t\t\t\t\"WeightedStaking::getPriorTotalVotingPower: overflow on total voting power computation\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Compute the voting power for a specific date.\n\t * Power = stake * weight\n\t * @param date The staking date to compute the power for.\n\t * @param startDate The date for which we need to know the power of the stake.\n\t * @param blockNumber The block number, needed for checkpointing.\n\t * */\n\tfunction _totalPowerByDate(\n\t\tuint256 date,\n\t\tuint256 startDate,\n\t\tuint256 blockNumber\n\t) internal view returns (uint96 power) {\n\t\tuint96 weight = computeWeightByDate(date, startDate);\n\t\tuint96 staked = getPriorTotalStakesForDate(date, blockNumber);\n\t\t/// @dev weight is multiplied by some factor to allow decimals.\n\t\tpower = mul96(staked, weight, \"WeightedStaking::_totalPowerByDate: multiplication overflow\") / WEIGHT_FACTOR;\n\t}\n\n\t/**\n\t * @notice Determine the prior number of stake for an unlocking date as of a block number.\n\t * @dev Block number must be a finalized block or else this function will\n\t * revert to prevent misinformation.\n\t * TODO: WeightedStaking::getPriorTotalStakesForDate should probably better\n\t * be internal instead of a public function.\n\t * @param date The date to check the stakes for.\n\t * @param blockNumber The block number to get the vote balance at.\n\t * @return The number of votes the account had as of the given block.\n\t * */\n\tfunction getPriorTotalStakesForDate(uint256 date, uint256 blockNumber) public view returns (uint96) {\n\t\trequire(blockNumber < block.number, \"WeightedStaking::getPriorTotalStakesForDate: not yet determined\");\n\n\t\tuint32 nCheckpoints = numTotalStakingCheckpoints[date];\n\t\tif (nCheckpoints == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// First check most recent balance\n\t\tif (totalStakingCheckpoints[date][nCheckpoints - 1].fromBlock <= blockNumber) {\n\t\t\treturn totalStakingCheckpoints[date][nCheckpoints - 1].stake;\n\t\t}\n\n\t\t// Next check implicit zero balance\n\t\tif (totalStakingCheckpoints[date][0].fromBlock > blockNumber) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint32 lower = 0;\n\t\tuint32 upper = nCheckpoints - 1;\n\t\twhile (upper > lower) {\n\t\t\tuint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n\t\t\tCheckpoint memory cp = totalStakingCheckpoints[date][center];\n\t\t\tif (cp.fromBlock == blockNumber) {\n\t\t\t\treturn cp.stake;\n\t\t\t} else if (cp.fromBlock < blockNumber) {\n\t\t\t\tlower = center;\n\t\t\t} else {\n\t\t\t\tupper = center - 1;\n\t\t\t}\n\t\t}\n\t\treturn totalStakingCheckpoints[date][lower].stake;\n\t}\n\n\t/****************************** DELEGATED VOTING POWER COMPUTATION ************************/\n\n\t/**\n\t * @notice Determine the prior number of votes for a delegatee as of a block number.\n\t * Iterate through checkpoints adding up voting power.\n\t * @dev Block number must be a finalized block or else this function will revert\n\t * to prevent misinformation.\n\t *      Used for Voting, not for fee sharing.\n\t * @param account The address of the account to check.\n\t * @param blockNumber The block number to get the vote balance at.\n\t * @return The number of votes the delegatee had as of the given block.\n\t * */\n\tfunction getPriorVotes(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) public view returns (uint96 votes) {\n\t\t/// @dev If date is not an exact break point, start weight computation from the previous break point (alternative would be the next).\n\t\tuint256 start = timestampToLockDate(date);\n\t\tuint256 end = start + MAX_DURATION;\n\n\t\t/// @dev Max 78 iterations.\n\t\tfor (uint256 i = start; i <= end; i += TWO_WEEKS) {\n\t\t\tvotes = add96(\n\t\t\t\tvotes,\n\t\t\t\t_totalPowerByDateForDelegatee(account, i, start, blockNumber),\n\t\t\t\t\"WeightedStaking::getPriorVotes: overflow on total voting power computation\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Compute the voting power for a specific date.\n\t * Power = stake * weight\n\t * @param date The staking date to compute the power for.\n\t * @param startDate The date for which we need to know the power of the stake.\n\t * @param blockNumber The block number, needed for checkpointing.\n\t * */\n\tfunction _totalPowerByDateForDelegatee(\n\t\taddress account,\n\t\tuint256 date,\n\t\tuint256 startDate,\n\t\tuint256 blockNumber\n\t) internal view returns (uint96 power) {\n\t\tuint96 weight = computeWeightByDate(date, startDate);\n\t\tuint96 staked = getPriorStakeByDateForDelegatee(account, date, blockNumber);\n\t\tpower = mul96(staked, weight, \"WeightedStaking::_totalPowerByDateForDelegatee: multiplication overflow\") / WEIGHT_FACTOR;\n\t}\n\n\t/**\n\t * @notice Determine the prior number of stake for an account as of a block number.\n\t * @dev Block number must be a finalized block or else this function will\n\t * revert to prevent misinformation.\n\t * TODO: WeightedStaking::getPriorStakeByDateForDelegatee should probably better\n\t * be internal instead of a public function.\n\t * @param account The address of the account to check.\n\t * @param blockNumber The block number to get the vote balance at.\n\t * @return The number of votes the account had as of the given block.\n\t * */\n\tfunction getPriorStakeByDateForDelegatee(\n\t\taddress account,\n\t\tuint256 date,\n\t\tuint256 blockNumber\n\t) public view returns (uint96) {\n\t\trequire(blockNumber < block.number, \"WeightedStaking::getPriorStakeByDateForDelegatee: not yet determined\");\n\n\t\tuint32 nCheckpoints = numDelegateStakingCheckpoints[account][date];\n\t\tif (nCheckpoints == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t/// @dev First check most recent balance.\n\t\tif (delegateStakingCheckpoints[account][date][nCheckpoints - 1].fromBlock <= blockNumber) {\n\t\t\treturn delegateStakingCheckpoints[account][date][nCheckpoints - 1].stake;\n\t\t}\n\n\t\t/// @dev Next check implicit zero balance.\n\t\tif (delegateStakingCheckpoints[account][date][0].fromBlock > blockNumber) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint32 lower = 0;\n\t\tuint32 upper = nCheckpoints - 1;\n\t\twhile (upper > lower) {\n\t\t\tuint32 center = upper - (upper - lower) / 2; /// @dev ceil, avoiding overflow.\n\t\t\tCheckpoint memory cp = delegateStakingCheckpoints[account][date][center];\n\t\t\tif (cp.fromBlock == blockNumber) {\n\t\t\t\treturn cp.stake;\n\t\t\t} else if (cp.fromBlock < blockNumber) {\n\t\t\t\tlower = center;\n\t\t\t} else {\n\t\t\t\tupper = center - 1;\n\t\t\t}\n\t\t}\n\t\treturn delegateStakingCheckpoints[account][date][lower].stake;\n\t}\n\n\t/*************************** User Weighted Stake computation for fee sharing *******************************/\n\n\t/**\n\t * @notice Determine the prior weighted stake for an account as of a block number.\n\t * Iterate through checkpoints adding up voting power.\n\t * @dev Block number must be a finalized block or else this function will\n\t * revert to prevent misinformation.\n\t *      Used for fee sharing, not voting.\n\t * TODO: WeightedStaking::getPriorWeightedStake is using the variable name \"votes\"\n\t * to add up token stake, and that could be misleading.\n\t *\n\t * @param account The address of the account to check.\n\t * @param blockNumber The block number to get the vote balance at.\n\t * @return The weighted stake the account had as of the given block.\n\t * */\n\tfunction getPriorWeightedStake(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) public view returns (uint96 votes) {\n\t\t/// @dev If date is not an exact break point, start weight computation from the previous break point (alternative would be the next).\n\t\tuint256 start = timestampToLockDate(date);\n\t\tuint256 end = start + MAX_DURATION;\n\n\t\t/// @dev Max 78 iterations.\n\t\tfor (uint256 i = start; i <= end; i += TWO_WEEKS) {\n\t\t\tuint96 weightedStake = weightedStakeByDate(account, i, start, blockNumber);\n\t\t\tif (weightedStake > 0) {\n\t\t\t\tvotes = add96(votes, weightedStake, \"WeightedStaking::getPriorWeightedStake: overflow on total weight computation\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @notice Compute the voting power for a specific date.\n\t * Power = stake * weight\n\t * TODO: WeightedStaking::weightedStakeByDate should probably better\n\t * be internal instead of a public function.\n\t * @param date The staking date to compute the power for.\n\t * @param startDate The date for which we need to know the power of the stake.\n\t * @param blockNumber The block number, needed for checkpointing.\n\t * */\n\tfunction weightedStakeByDate(\n\t\taddress account,\n\t\tuint256 date,\n\t\tuint256 startDate,\n\t\tuint256 blockNumber\n\t) public view returns (uint96 power) {\n\t\tuint96 staked = getPriorUserStakeByDate(account, date, blockNumber);\n\t\tif (staked > 0) {\n\t\t\tuint96 weight = computeWeightByDate(date, startDate);\n\t\t\tpower = mul96(staked, weight, \"WeightedStaking::weightedStakeByDate: multiplication overflow\") / WEIGHT_FACTOR;\n\t\t} else {\n\t\t\tpower = 0;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Determine the prior number of stake for an account until a\n\t * certain lock date as of a block number.\n\t * @dev Block number must be a finalized block or else this function\n\t * will revert to prevent misinformation.\n\t * @param account The address of the account to check.\n\t * @param date The lock date.\n\t * @param blockNumber The block number to get the vote balance at.\n\t * @return The number of votes the account had as of the given block.\n\t * */\n\tfunction getPriorUserStakeByDate(\n\t\taddress account,\n\t\tuint256 date,\n\t\tuint256 blockNumber\n\t) public view returns (uint96) {\n\t\trequire(blockNumber < block.number, \"WeightedStaking::getPriorUserStakeAndDate: not yet determined\");\n\n\t\tdate = _adjustDateForOrigin(date);\n\t\tuint32 nCheckpoints = numUserStakingCheckpoints[account][date];\n\t\tif (nCheckpoints == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t/// @dev First check most recent balance.\n\t\tif (userStakingCheckpoints[account][date][nCheckpoints - 1].fromBlock <= blockNumber) {\n\t\t\treturn userStakingCheckpoints[account][date][nCheckpoints - 1].stake;\n\t\t}\n\n\t\t/// @dev Next check implicit zero balance.\n\t\tif (userStakingCheckpoints[account][date][0].fromBlock > blockNumber) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint32 lower = 0;\n\t\tuint32 upper = nCheckpoints - 1;\n\t\twhile (upper > lower) {\n\t\t\tuint32 center = upper - (upper - lower) / 2; /// @dev ceil, avoiding overflow.\n\t\t\tCheckpoint memory cp = userStakingCheckpoints[account][date][center];\n\t\t\tif (cp.fromBlock == blockNumber) {\n\t\t\t\treturn cp.stake;\n\t\t\t} else if (cp.fromBlock < blockNumber) {\n\t\t\t\tlower = center;\n\t\t\t} else {\n\t\t\t\tupper = center - 1;\n\t\t\t}\n\t\t}\n\t\treturn userStakingCheckpoints[account][date][lower].stake;\n\t}\n\n\t/**************** SHARED FUNCTIONS *********************/\n\n\t/**\n\t * @notice Compute the weight for a specific date.\n\t * @param date The unlocking date.\n\t * @param startDate We compute the weight for the tokens staked until 'date' on 'startDate'.\n\t * */\n\tfunction computeWeightByDate(uint256 date, uint256 startDate) public pure returns (uint96 weight) {\n\t\trequire(date >= startDate, \"WeightedStaking::computeWeightByDate: date needs to be bigger than startDate\");\n\t\tuint256 remainingTime = (date - startDate);\n\t\trequire(MAX_DURATION >= remainingTime, \"Staking::computeWeightByDate:remaining time can't be bigger than max duration\");\n\t\t/// @dev x = max days - remaining days\n\t\tuint96 x = uint96(MAX_DURATION - remainingTime) / (1 days);\n\t\t/// @dev w = (m^2 - x^2)/m^2 +1 (multiplied by the weight factor)\n\t\tweight = add96(\n\t\t\tWEIGHT_FACTOR,\n\t\t\tmul96(\n\t\t\t\tMAX_VOTING_WEIGHT * WEIGHT_FACTOR,\n\t\t\t\tsub96(MAX_DURATION_POW_2, x * x, \"underflow on weight calculation\"),\n\t\t\t\t\"multiplication overflow on weight computation\"\n\t\t\t) / MAX_DURATION_POW_2,\n\t\t\t\"overflow on weight computation\"\n\t\t);\n\t}\n\n\t/**\n\t * @notice Unstaking is possible every 2 weeks only. This means, to\n\t * calculate the key value for the staking checkpoints, we need to\n\t * map the intended timestamp to the closest available date.\n\t * @param timestamp The unlocking timestamp.\n\t * @return The actual unlocking date (might be up to 2 weeks shorter than intended).\n\t * */\n\tfunction timestampToLockDate(uint256 timestamp) public view returns (uint256 lockDate) {\n\t\trequire(timestamp >= kickoffTS, \"WeightedStaking::timestampToLockDate: timestamp lies before contract creation\");\n\t\t/**\n\t\t * @dev If staking timestamp does not match any of the unstaking dates\n\t\t * , set the lockDate to the closest one before the timestamp.\n\t\t * E.g. Passed timestamps lies 7 weeks after kickoff -> only stake for 6 weeks.\n\t\t * */\n\t\tuint256 periodFromKickoff = (timestamp - kickoffTS) / TWO_WEEKS;\n\t\tlockDate = periodFromKickoff * TWO_WEEKS + kickoffTS;\n\t}\n\n\tfunction _adjustDateForOrigin(uint256 date) internal view returns (uint256) {\n\t\tuint256 adjustedDate = timestampToLockDate(date);\n\t\t//origin vesting contracts have different dates\n\t\t//we need to add 2 weeks to get end of period (by default, it's start)\n\t\tif (adjustedDate != date) {\n\t\t\tdate = adjustedDate + TWO_WEEKS;\n\t\t}\n\t\treturn date;\n\t}\n}\n"
    },
    "contracts/fish/governance/Staking/IStaking.sol": {
      "content": "pragma solidity ^0.5.17;\n\n/**\n * @title Interface for contract governance/Staking/Staking.sol\n * @dev Interfaces are used to cast a contract address into a callable instance.\n */\ninterface IStaking {\n\tfunction stakesBySchedule(\n\t\tuint256 amount,\n\t\tuint256 cliff,\n\t\tuint256 duration,\n\t\tuint256 intervalLength,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) external;\n\n\tfunction stake(\n\t\tuint96 amount,\n\t\tuint256 until,\n\t\taddress stakeFor,\n\t\taddress delegatee\n\t) external;\n\n\tfunction getPriorVotes(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) external view returns (uint96);\n\n\tfunction getPriorTotalVotingPower(uint32 blockNumber, uint256 time) external view returns (uint96);\n\n\tfunction getPriorWeightedStake(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) external view returns (uint96);\n\n\tfunction timestampToLockDate(uint256 timestamp) external view returns (uint256 lockDate);\n}\n"
    },
    "contracts/fish/rsk/RSKAddrValidator.sol": {
      "content": "// SPDX-License-Identifier:MIT\npragma solidity ^0.5.17;\n\nlibrary RSKAddrValidator {\n\t/*\n\t * @param addr it is an address to check that it does not originates from\n\t * signing with PK = ZERO. RSK has a small difference in which @ZERO_PK_ADDR is\n\t * also an address from PK = ZERO. So we check for both of them.\n\t * */\n\tfunction checkPKNotZero(address addr) internal pure returns (bool) {\n\t\treturn (addr != 0xdcc703c0E500B653Ca82273B7BFAd8045D85a470 && addr != address(0));\n\t}\n\n\t/*\n\t * Safely compares two addresses, checking they do not originate from\n\t * a zero private key.\n\t * */\n\tfunction safeEquals(address addr1, address addr2) internal pure returns (bool) {\n\t\treturn (addr1 == addr2 && addr1 != 0xdcc703c0E500B653Ca82273B7BFAd8045D85a470 && addr1 != address(0));\n\t}\n}\n"
    },
    "contracts/fish/governance/Vesting/ITeamVesting.sol": {
      "content": "pragma solidity ^0.5.17;\n\n/**\n * @title Interface for TeamVesting contract.\n * @dev Interfaces are used to cast a contract address into a callable instance.\n * This interface is used by Staking contract to call governanceWithdrawTokens\n * function having the vesting contract instance address.\n */\ninterface ITeamVesting {\n\tfunction governanceWithdrawTokens(address receiver) external;\n}\n"
    },
    "contracts/fish/governance/Staking/Checkpoints.sol": {
      "content": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"./StakingStorage.sol\";\nimport \"./SafeMath96.sol\";\n\n/**\n * @title Checkpoints contract.\n * @notice Increases and decreases storage values for users, delegatees and\n * total daily stake.\n * */\ncontract Checkpoints is StakingStorage, SafeMath96 {\n\t/// @notice An event emitted when an account changes its delegate.\n\tevent DelegateChanged(address indexed delegator, uint256 lockedUntil, address indexed fromDelegate, address indexed toDelegate);\n\n\t/// @notice An event emitted when a delegate account's stake balance changes.\n\tevent DelegateStakeChanged(address indexed delegate, uint256 lockedUntil, uint256 previousBalance, uint256 newBalance);\n\n\t/// @notice An event emitted when tokens get staked.\n\tevent TokensStaked(address indexed staker, uint256 amount, uint256 lockedUntil, uint256 totalStaked);\n\n\t/// @notice An event emitted when tokens get withdrawn.\n\tevent TokensWithdrawn(address indexed staker, address receiver, uint256 amount);\n\n\t/// @notice An event emitted when vesting tokens get withdrawn.\n\tevent VestingTokensWithdrawn(address vesting, address receiver);\n\n\t/// @notice An event emitted when the owner unlocks all tokens.\n\tevent TokensUnlocked(uint256 amount);\n\n\t/// @notice An event emitted when a staking period gets extended.\n\tevent ExtendedStakingDuration(address indexed staker, uint256 previousDate, uint256 newDate);\n\n\t/**\n\t * @notice Increases the user's stake for a giving lock date and writes a checkpoint.\n\t * @param account The user address.\n\t * @param lockedTS The lock date.\n\t * @param value The value to add to the staked balance.\n\t * */\n\tfunction _increaseUserStake(\n\t\taddress account,\n\t\tuint256 lockedTS,\n\t\tuint96 value\n\t) internal {\n\t\tuint32 nCheckpoints = numUserStakingCheckpoints[account][lockedTS];\n\t\tuint96 staked = userStakingCheckpoints[account][lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = add96(staked, value, \"Staking::_increaseUserStake: staked amount overflow\");\n\t\t_writeUserCheckpoint(account, lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice Decreases the user's stake for a giving lock date and writes a checkpoint.\n\t * @param account The user address.\n\t * @param lockedTS The lock date.\n\t * @param value The value to substract to the staked balance.\n\t * */\n\tfunction _decreaseUserStake(\n\t\taddress account,\n\t\tuint256 lockedTS,\n\t\tuint96 value\n\t) internal {\n\t\tuint32 nCheckpoints = numUserStakingCheckpoints[account][lockedTS];\n\t\tuint96 staked = userStakingCheckpoints[account][lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = sub96(staked, value, \"Staking::_decreaseUserStake: staked amount underflow\");\n\t\t_writeUserCheckpoint(account, lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice Writes on storage the user stake.\n\t * @param account The user address.\n\t * @param lockedTS The lock date.\n\t * @param nCheckpoints The number of checkpoints, to find out the last one index.\n\t * @param newStake The new staked balance.\n\t * */\n\tfunction _writeUserCheckpoint(\n\t\taddress account,\n\t\tuint256 lockedTS,\n\t\tuint32 nCheckpoints,\n\t\tuint96 newStake\n\t) internal {\n\t\tuint32 blockNumber = safe32(block.number, \"Staking::_writeStakingCheckpoint: block number exceeds 32 bits\");\n\n\t\tif (nCheckpoints > 0 && userStakingCheckpoints[account][lockedTS][nCheckpoints - 1].fromBlock == blockNumber) {\n\t\t\tuserStakingCheckpoints[account][lockedTS][nCheckpoints - 1].stake = newStake;\n\t\t} else {\n\t\t\tuserStakingCheckpoints[account][lockedTS][nCheckpoints] = Checkpoint(blockNumber, newStake);\n\t\t\tnumUserStakingCheckpoints[account][lockedTS] = nCheckpoints + 1;\n\t\t}\n\t}\n\n\t/**\n\t * @notice Increases the delegatee's stake for a giving lock date and writes a checkpoint.\n\t * @param delegatee The delegatee address.\n\t * @param lockedTS The lock date.\n\t * @param value The value to add to the staked balance.\n\t * */\n\tfunction _increaseDelegateStake(\n\t\taddress delegatee,\n\t\tuint256 lockedTS,\n\t\tuint96 value\n\t) internal {\n\t\tuint32 nCheckpoints = numDelegateStakingCheckpoints[delegatee][lockedTS];\n\t\tuint96 staked = delegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = add96(staked, value, \"Staking::_increaseDelegateeStake: staked amount overflow\");\n\t\t_writeDelegateCheckpoint(delegatee, lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice Decreases the delegatee's stake for a giving lock date and writes a checkpoint.\n\t * @param delegatee The delegatee address.\n\t * @param lockedTS The lock date.\n\t * @param value The value to substract to the staked balance.\n\t * */\n\tfunction _decreaseDelegateStake(\n\t\taddress delegatee,\n\t\tuint256 lockedTS,\n\t\tuint96 value\n\t) internal {\n\t\tuint32 nCheckpoints = numDelegateStakingCheckpoints[delegatee][lockedTS];\n\t\tuint96 staked = delegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = sub96(staked, value, \"Staking::_decreaseDelegateStake: staked amount underflow\");\n\t\t_writeDelegateCheckpoint(delegatee, lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice Writes on storage the delegate stake.\n\t * @param delegatee The delegate address.\n\t * @param lockedTS The lock date.\n\t * @param nCheckpoints The number of checkpoints, to find out the last one index.\n\t * @param newStake The new staked balance.\n\t * */\n\tfunction _writeDelegateCheckpoint(\n\t\taddress delegatee,\n\t\tuint256 lockedTS,\n\t\tuint32 nCheckpoints,\n\t\tuint96 newStake\n\t) internal {\n\t\tuint32 blockNumber = safe32(block.number, \"Staking::_writeStakingCheckpoint: block number exceeds 32 bits\");\n\t\tuint96 oldStake = delegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].stake;\n\n\t\tif (nCheckpoints > 0 && delegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].fromBlock == blockNumber) {\n\t\t\tdelegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints - 1].stake = newStake;\n\t\t} else {\n\t\t\tdelegateStakingCheckpoints[delegatee][lockedTS][nCheckpoints] = Checkpoint(blockNumber, newStake);\n\t\t\tnumDelegateStakingCheckpoints[delegatee][lockedTS] = nCheckpoints + 1;\n\t\t}\n\t\temit DelegateStakeChanged(delegatee, lockedTS, oldStake, newStake);\n\t}\n\n\t/**\n\t * @notice Increases the total stake for a giving lock date and writes a checkpoint.\n\t * @param lockedTS The lock date.\n\t * @param value The value to add to the staked balance.\n\t * */\n\tfunction _increaseDailyStake(uint256 lockedTS, uint96 value) internal {\n\t\tuint32 nCheckpoints = numTotalStakingCheckpoints[lockedTS];\n\t\tuint96 staked = totalStakingCheckpoints[lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = add96(staked, value, \"Staking::_increaseDailyStake: staked amount overflow\");\n\t\t_writeStakingCheckpoint(lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice Decreases the total stake for a giving lock date and writes a checkpoint.\n\t * @param lockedTS The lock date.\n\t * @param value The value to substract to the staked balance.\n\t * */\n\tfunction _decreaseDailyStake(uint256 lockedTS, uint96 value) internal {\n\t\tuint32 nCheckpoints = numTotalStakingCheckpoints[lockedTS];\n\t\tuint96 staked = totalStakingCheckpoints[lockedTS][nCheckpoints - 1].stake;\n\t\tuint96 newStake = sub96(staked, value, \"Staking::_decreaseDailyStake: staked amount underflow\");\n\t\t_writeStakingCheckpoint(lockedTS, nCheckpoints, newStake);\n\t}\n\n\t/**\n\t * @notice Writes on storage the total stake.\n\t * @param lockedTS The lock date.\n\t * @param nCheckpoints The number of checkpoints, to find out the last one index.\n\t * @param newStake The new staked balance.\n\t * */\n\tfunction _writeStakingCheckpoint(\n\t\tuint256 lockedTS,\n\t\tuint32 nCheckpoints,\n\t\tuint96 newStake\n\t) internal {\n\t\tuint32 blockNumber = safe32(block.number, \"Staking::_writeStakingCheckpoint: block number exceeds 32 bits\");\n\n\t\tif (nCheckpoints > 0 && totalStakingCheckpoints[lockedTS][nCheckpoints - 1].fromBlock == blockNumber) {\n\t\t\ttotalStakingCheckpoints[lockedTS][nCheckpoints - 1].stake = newStake;\n\t\t} else {\n\t\t\ttotalStakingCheckpoints[lockedTS][nCheckpoints] = Checkpoint(blockNumber, newStake);\n\t\t\tnumTotalStakingCheckpoints[lockedTS] = nCheckpoints + 1;\n\t\t}\n\t}\n}\n"
    },
    "contracts/fish/governance/Staking/StakingStorage.sol": {
      "content": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../IFeeSharingProxy.sol\";\n\n/**\n * @title Staking Storage contact.\n * @notice Just the storage part of stacking contract, no functions,\n * only constant, variables and required structures (mappings).\n * Used by StackingProxy and Checkpoints contracts.\n *\n * What is SOV staking?\n * The purpose of the SOV token is to provide a pseudonymous,\n * censorship-resistant mechanism for governing the parameters of the Sovryn\n * protocol, while aligning the incentives of protocol governors with the\n * long-term success of the protocol. Any SOV token holder can choose to\n * stake (lock up) their tokens for a fixed period of time in return for\n * voting rights in the Bitocracy. Stakers are further incentivised through\n * fee and slashing rewards.\n * */\ncontract StakingStorage is Ownable {\n\t/// @notice 2 weeks in seconds.\n\tuint256 constant TWO_WEEKS = 1209600;\n\n\t/// @notice The maximum possible voting weight before adding +1 (actually 10, but need 9 for computation).\n\tuint96 public constant MAX_VOTING_WEIGHT = 9;\n\n\t/// @notice weight is multiplied with this factor (for allowing decimals, like 1.2x).\n\t/// @dev MAX_VOTING_WEIGHT * WEIGHT_FACTOR needs to be < 792, because there are 100,000,000 SOV with 18 decimals\n\tuint96 public constant WEIGHT_FACTOR = 10;\n\n\t/// @notice The maximum duration to stake tokens for.\n\tuint256 public constant MAX_DURATION = 1092 days;\n\n\t/// @notice The maximum duration ^2\n\tuint96 constant MAX_DURATION_POW_2 = 1092 * 1092;\n\n\t/// @notice Default weight scaling.\n\tuint96 constant DEFAULT_WEIGHT_SCALING = 3;\n\n\t/// @notice Range for weight scaling.\n\tuint96 constant MIN_WEIGHT_SCALING = 1;\n\tuint96 constant MAX_WEIGHT_SCALING = 9;\n\n\t/// @notice The timestamp of contract creation. Base for the staking period calculation.\n\tuint256 public kickoffTS;\n\n\tstring name = \"SOVStaking\";\n\n\t/// @notice The token to be staked.\n\tIERC20 public SOVToken;\n\n\t/// @notice A record of each accounts delegate.\n\tmapping(address => mapping(uint256 => address)) public delegates;\n\n\t/// @notice If this flag is set to true, all tokens are unlocked immediately.\n\tbool public allUnlocked = false;\n\n\t/// @notice The EIP-712 typehash for the contract's domain.\n\tbytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n\t/// @notice The EIP-712 typehash for the delegation struct used by the contract.\n\tbytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 lockDate,uint256 nonce,uint256 expiry)\");\n\n\t/// @notice Used for stake migrations to a new staking contract with a different storage structure.\n\taddress public newStakingContract;\n\n\t/*************************** Checkpoints *******************************/\n\n\t/// @notice A checkpoint for marking the stakes from a given block\n\tstruct Checkpoint {\n\t\tuint32 fromBlock;\n\t\tuint96 stake;\n\t}\n\n\t/// @notice A record of tokens to be unstaked at a given time in total.\n\t/// For total voting power computation. Voting weights get adjusted bi-weekly.\n\t/// @dev totalStakingCheckpoints[date][index] is a checkpoint.\n\tmapping(uint256 => mapping(uint32 => Checkpoint)) public totalStakingCheckpoints;\n\n\t/// @notice The number of total staking checkpoints for each date.\n\t/// @dev numTotalStakingCheckpoints[date] is a number.\n\tmapping(uint256 => uint32) public numTotalStakingCheckpoints;\n\n\t/// @notice A record of tokens to be unstaked at a given time which were delegated to a certain address.\n\t/// For delegatee voting power computation. Voting weights get adjusted bi-weekly.\n\t/// @dev delegateStakingCheckpoints[delegatee][date][index] is a checkpoint.\n\tmapping(address => mapping(uint256 => mapping(uint32 => Checkpoint))) public delegateStakingCheckpoints;\n\n\t/// @notice The number of total staking checkpoints for each date per delegate.\n\t/// @dev numDelegateStakingCheckpoints[delegatee][date] is a number.\n\tmapping(address => mapping(uint256 => uint32)) public numDelegateStakingCheckpoints;\n\n\t/// @notice A record of tokens to be unstaked at a given time which per user address (address -> lockDate -> stake checkpoint)\n\t/// @dev userStakingCheckpoints[user][date][index] is a checkpoint.\n\tmapping(address => mapping(uint256 => mapping(uint32 => Checkpoint))) public userStakingCheckpoints;\n\n\t/// @notice The number of total staking checkpoints for each date per user.\n\t/// @dev numUserStakingCheckpoints[user][date] is a number.\n\tmapping(address => mapping(uint256 => uint32)) public numUserStakingCheckpoints;\n\n\t/// @notice A record of states for signing / validating signatures\n\t/// @dev nonces[user] is a number.\n\tmapping(address => uint256) public nonces;\n\n\t/*************************** Slashing *******************************/\n\n\t/// @notice the address of FeeSharingProxy contract, we need it for unstaking with slashing.\n\tIFeeSharingProxy public feeSharing;\n\n\t/// @notice used for weight scaling when unstaking with slashing.\n\tuint96 public weightScaling = DEFAULT_WEIGHT_SCALING;\n\n\t/// @notice List of vesting contracts, tokens for these contracts won't be slashed if unstaked by governance.\n\t/// @dev vestingWhitelist[contract] is true/false.\n\tmapping(address => bool) public vestingWhitelist;\n}\n"
    },
    "contracts/fish/governance/Staking/SafeMath96.sol": {
      "content": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\n/**\n * @title SafeMath96 contract.\n * @notice Improved Solidity's arithmetic operations with added overflow checks.\n * @dev SafeMath96 uses uint96, unsigned integers of 96 bits length, so every\n * integer from 0 to 2^96-1 can be operated.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * SafeMath restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this contract instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n * */\ncontract SafeMath96 {\n\tfunction safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n\t\trequire(n < 2**32, errorMessage);\n\t\treturn uint32(n);\n\t}\n\n\tfunction safe64(uint256 n, string memory errorMessage) internal pure returns (uint64) {\n\t\trequire(n < 2**64, errorMessage);\n\t\treturn uint64(n);\n\t}\n\n\tfunction safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n\t\trequire(n < 2**96, errorMessage);\n\t\treturn uint96(n);\n\t}\n\n\t/**\n\t * @notice Adds two unsigned integers, reverting on overflow.\n\t * @dev Counterpart to Solidity's `+` operator.\n\t * @param a First integer.\n\t * @param b Second integer.\n\t * @param errorMessage The revert message on overflow.\n\t * @return The safe addition a+b.\n\t * */\n\tfunction add96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\tuint96 c = a + b;\n\t\trequire(c >= a, errorMessage);\n\t\treturn c;\n\t}\n\n\t/**\n\t * @notice Substracts two unsigned integers, reverting on underflow.\n\t * @dev Counterpart to Solidity's `-` operator.\n\t * @param a First integer.\n\t * @param b Second integer.\n\t * @param errorMessage The revert message on underflow.\n\t * @return The safe substraction a-b.\n\t * */\n\tfunction sub96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\trequire(b <= a, errorMessage);\n\t\treturn a - b;\n\t}\n\n\t/**\n\t * @notice Multiplies two unsigned integers, reverting on overflow.\n\t * @dev Counterpart to Solidity's `*` operator.\n\t * @param a First integer.\n\t * @param b Second integer.\n\t * @param errorMessage The revert message on overflow.\n\t * @return The safe product a*b.\n\t * */\n\tfunction mul96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint96 c = a * b;\n\t\trequire(c / a == b, errorMessage);\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * @notice Divides two unsigned integers, reverting on overflow.\n\t * @dev Counterpart to Solidity's `/` operator.\n\t * @param a First integer.\n\t * @param b Second integer.\n\t * @param errorMessage The revert message on overflow.\n\t * @return The safe division a/b.\n\t * */\n\tfunction div96(\n\t\tuint96 a,\n\t\tuint96 b,\n\t\tstring memory errorMessage\n\t) internal pure returns (uint96) {\n\t\t// Solidity only automatically asserts when dividing by 0\n\t\trequire(b > 0, errorMessage);\n\t\tuint96 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n\t\treturn c;\n\t}\n}\n"
    },
    "contracts/fish/governance/Vesting/VestingRegistry3.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../Staking/IStaking.sol\";\nimport \"../IFeeSharingProxy.sol\";\nimport \"./IVestingFactory.sol\";\nimport \"./IVesting.sol\";\nimport \"./ITeamVesting.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract VestingRegistry3 is Ownable {\n\tusing SafeMath for uint256;\n\n\tIVestingFactory public vestingFactory;\n\n\t///@notice the SOV token contract\n\taddress public SOV;\n\n\t///@notice the staking contract address\n\taddress public staking;\n\t//@notice fee sharing proxy\n\taddress public feeSharingProxy;\n\t//@notice the vesting owner (e.g. governance timelock address)\n\taddress public vestingOwner;\n\n\t//TODO add to the documentation: address can have only one vesting of each type\n\t//user => vesting type => vesting contract\n\tmapping(address => mapping(uint256 => address)) public vestingContracts;\n\n\t//user => flag whether user has admin role\n\tmapping(address => bool) public admins;\n\n\tenum VestingType {\n\t\tTeamVesting, //MultisigVesting\n\t\tVesting //TokenHolderVesting\n\t}\n\n\tevent SOVTransferred(address indexed receiver, uint256 amount);\n\tevent VestingCreated(address indexed tokenOwner, address vesting, uint256 cliff, uint256 duration, uint256 amount);\n\tevent TeamVestingCreated(address indexed tokenOwner, address vesting, uint256 cliff, uint256 duration, uint256 amount);\n\tevent TokensStaked(address indexed vesting, uint256 amount);\n\tevent AdminAdded(address admin);\n\tevent AdminRemoved(address admin);\n\n\tconstructor(\n\t\taddress _vestingFactory,\n\t\taddress _SOV,\n\t\taddress _staking,\n\t\taddress _feeSharingProxy,\n\t\taddress _vestingOwner\n\t) public {\n\t\trequire(_SOV != address(0), \"SOV address invalid\");\n\t\trequire(_staking != address(0), \"staking address invalid\");\n\t\trequire(_feeSharingProxy != address(0), \"feeSharingProxy address invalid\");\n\t\trequire(_vestingOwner != address(0), \"vestingOwner address invalid\");\n\n\t\t_setVestingFactory(_vestingFactory);\n\n\t\tSOV = _SOV;\n\t\tstaking = _staking;\n\t\tfeeSharingProxy = _feeSharingProxy;\n\t\tvestingOwner = _vestingOwner;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner or admin.\n\t */\n\tmodifier onlyAuthorized() {\n\t\trequire(isOwner() || admins[msg.sender], \"unauthorized\");\n\t\t_;\n\t}\n\n\tfunction addAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = true;\n\t\temit AdminAdded(_admin);\n\t}\n\n\tfunction removeAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = false;\n\t\temit AdminRemoved(_admin);\n\t}\n\n\t/**\n\t * @notice sets vesting factory address\n\t * @param _vestingFactory the address of vesting factory contract\n\t */\n\tfunction setVestingFactory(address _vestingFactory) public onlyOwner {\n\t\t_setVestingFactory(_vestingFactory);\n\t}\n\n\tfunction _setVestingFactory(address _vestingFactory) internal {\n\t\trequire(_vestingFactory != address(0), \"vestingFactory address invalid\");\n\t\tvestingFactory = IVestingFactory(_vestingFactory);\n\t}\n\n\t/**\n\t * @notice transfers SOV tokens to given address\n\t * @param _receiver the address of the SOV receiver\n\t * @param _amount the amount to be transferred\n\t */\n\tfunction transferSOV(address _receiver, uint256 _amount) public onlyOwner {\n\t\trequire(_receiver != address(0), \"receiver address invalid\");\n\t\trequire(_amount != 0, \"amount invalid\");\n\n\t\tIERC20(SOV).transfer(_receiver, _amount);\n\t\temit SOVTransferred(_receiver, _amount);\n\t}\n\n\t/**\n\t * @notice creates Vesting contract\n\t * @param _tokenOwner the owner of the tokens\n\t * @param _amount the amount to be staked\n\t * @param _cliff the cliff in seconds\n\t * @param _duration the total duration in seconds\n\t */\n\tfunction createVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _amount,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) public onlyAuthorized {\n\t\taddress vesting = _getOrCreateVesting(_tokenOwner, _cliff, _duration);\n\t\temit VestingCreated(_tokenOwner, vesting, _cliff, _duration, _amount);\n\t}\n\n\t/**\n\t * @notice creates Team Vesting contract\n\t * @param _tokenOwner the owner of the tokens\n\t * @param _amount the amount to be staked\n\t * @param _cliff the cliff in seconds\n\t * @param _duration the total duration in seconds\n\t */\n\tfunction createTeamVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _amount,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) public onlyAuthorized {\n\t\taddress vesting = _getOrCreateTeamVesting(_tokenOwner, _cliff, _duration);\n\t\temit TeamVestingCreated(_tokenOwner, vesting, _cliff, _duration, _amount);\n\t}\n\n\t/**\n\t * @notice stakes tokens according to the vesting schedule\n\t * @param _vesting the address of Vesting contract\n\t * @param _amount the amount of tokens to stake\n\t */\n\tfunction stakeTokens(address _vesting, uint256 _amount) public onlyAuthorized {\n\t\trequire(_vesting != address(0), \"vesting address invalid\");\n\t\trequire(_amount > 0, \"amount invalid\");\n\n\t\tIERC20(SOV).approve(_vesting, _amount);\n\t\tIVesting(_vesting).stakeTokens(_amount);\n\t\temit TokensStaked(_vesting, _amount);\n\t}\n\n\t/**\n\t * @notice returns vesting contract address for the given token owner\n\t * @param _tokenOwner the owner of the tokens\n\t */\n\tfunction getVesting(address _tokenOwner) public view returns (address) {\n\t\treturn vestingContracts[_tokenOwner][uint256(VestingType.Vesting)];\n\t}\n\n\t/**\n\t * @notice returns team vesting contract address for the given token owner\n\t * @param _tokenOwner the owner of the tokens\n\t */\n\tfunction getTeamVesting(address _tokenOwner) public view returns (address) {\n\t\treturn vestingContracts[_tokenOwner][uint256(VestingType.TeamVesting)];\n\t}\n\n\tfunction _getOrCreateVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) internal returns (address) {\n\t\tuint256 type_ = uint256(VestingType.Vesting);\n\t\tif (vestingContracts[_tokenOwner][type_] == address(0)) {\n\t\t\t//TODO Owner of OwnerVesting contracts - the same address as tokenOwner\n\t\t\taddress vesting = vestingFactory.deployVesting(SOV, staking, _tokenOwner, _cliff, _duration, feeSharingProxy, _tokenOwner);\n\t\t\tvestingContracts[_tokenOwner][type_] = vesting;\n\t\t}\n\t\treturn vestingContracts[_tokenOwner][type_];\n\t}\n\n\tfunction _getOrCreateTeamVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) internal returns (address) {\n\t\tuint256 type_ = uint256(VestingType.TeamVesting);\n\t\tif (vestingContracts[_tokenOwner][type_] == address(0)) {\n\t\t\taddress vesting = vestingFactory.deployTeamVesting(SOV, staking, _tokenOwner, _cliff, _duration, feeSharingProxy, vestingOwner);\n\t\t\tvestingContracts[_tokenOwner][type_] = vesting;\n\t\t}\n\t\treturn vestingContracts[_tokenOwner][type_];\n\t}\n}\n"
    },
    "contracts/fish/governance/Vesting/IVestingFactory.sol": {
      "content": "pragma solidity ^0.5.17;\n\n/**\n * @title Interface for Vesting Factory contract.\n * @dev Interfaces are used to cast a contract address into a callable instance.\n * This interface is used by VestingFactory contract to override empty\n * implemention of deployVesting and deployTeamVesting functions\n * and on VestingRegistry contract to use an instance of VestingFactory.\n */\ninterface IVestingFactory {\n\tfunction deployVesting(\n\t\taddress _SOV,\n\t\taddress _staking,\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration,\n\t\taddress _feeSharing,\n\t\taddress _owner\n\t) external returns (address);\n\n\tfunction deployTeamVesting(\n\t\taddress _SOV,\n\t\taddress _staking,\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration,\n\t\taddress _feeSharing,\n\t\taddress _owner\n\t) external returns (address);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/masset/versions/Masset.sol": {
      "content": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC777Recipient } from \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport { IERC1820Registry } from \"@openzeppelin/contracts/introspection/IERC1820Registry.sol\";\nimport { InitializableOwnable } from \"../../helpers/InitializableOwnable.sol\";\nimport { InitializableReentrancyGuard } from \"../../helpers/InitializableReentrancyGuard.sol\";\nimport { IBridge } from \"../IBridge.sol\";\nimport { BasketManager } from \"./BasketManager.sol\";\nimport \"../Token.sol\";\n\ncontract Masset is IERC777Recipient, InitializableOwnable, InitializableReentrancyGuard {\n\n    using SafeMath for uint256;\n\n    // Events\n\n    event Minted(\n        address indexed minter,\n        address indexed recipient,\n        uint256 massetQuantity,\n        address bAsset,\n        uint256 bassetQuantity\n    );\n\n    event Redeemed(\n        address indexed redeemer,\n        address indexed recipient,\n        uint256 massetQuantity,\n        address bAsset,\n        uint256 bassetQuantity\n    );\n\n    event onTokensReceivedCalled(\n        address operator,\n        address from,\n        address to,\n        uint amount,\n        bytes userData,\n        bytes operatorData\n    );\n\n    event onTokensMintedCalled(\n        address indexed sender,\n        uint256 orderAmount,\n        address tokenAddress,\n        bytes userData\n    );\n\n    // state\n    string private version;\n    BasketManager private basketManager;\n    Token private token;\n\n    // internal\n\n    function registerAsERC777Recipient() internal {\n        IERC1820Registry ERC1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n        ERC1820.setInterfaceImplementer(address(this), keccak256(\"ERC777TokensRecipient\"), address(this));\n    }\n\n    // public\n\n    function initialize(\n        address _basketManagerAddress,\n        address _tokenAddress,\n        bool _registerAsERC777RecipientFlag) public {\n\n        require(address(basketManager) == address(0) && address(token) == address(0), \"already initialized\");\n        require(_basketManagerAddress != address(0), \"invalid basket manager\");\n        require(_tokenAddress != address(0), \"invalid token\");\n\n        InitializableOwnable._initialize();\n        InitializableReentrancyGuard._initialize();\n\n        basketManager = BasketManager(_basketManagerAddress);\n        token = Token(_tokenAddress);\n        if(_registerAsERC777RecipientFlag) {\n            registerAsERC777Recipient();\n        }\n\n        version = \"1.0\";\n    }\n\n    /***************************************\n                MINTING (PUBLIC)\n    ****************************************/\n\n    /**\n     * @dev Mint a single bAsset, at a 1:1 ratio with the bAsset. This contract\n     *      must have approval to spend the senders bAsset\n     * @param _bAsset         Address of the bAsset to mint\n     * @param _bAssetQuantity Quantity in bAsset units\n     * @return massetMinted   Number of newly minted mAssets\n     */\n    function mint(\n        address _bAsset,\n        uint256 _bAssetQuantity\n    )\n    external\n    nonReentrant\n    returns (uint256 massetMinted)\n    {\n        return _mintTo(_bAsset, _bAssetQuantity, msg.sender);\n    }\n\n    /**\n     * @dev Mint a single bAsset, at a 1:1 ratio with the bAsset. This contract\n     *      must have approval to spend the senders bAsset\n     * @param _bAsset         Address of the bAsset to mint\n     * @param _bAssetQuantity Quantity in bAsset units\n     * @param _recipient receipient of the newly minted mAsset tokens\n     * @return massetMinted   Number of newly minted mAssets\n     */\n    function mintTo(\n        address _bAsset,\n        uint256 _bAssetQuantity,\n        address _recipient\n    )\n    external\n    nonReentrant\n    returns (uint256 massetMinted)\n    {\n        return _mintTo(_bAsset, _bAssetQuantity, _recipient);\n    }\n\n    /***************************************\n              MINTING (INTERNAL)\n    ****************************************/\n\n    function _mintTo(\n        address _basset,\n        uint256 _bassetQuantity,\n        address _recipient\n    )\n    internal\n    returns (uint256 massetMinted)\n    {\n        require(_recipient != address(0), \"must be a valid recipient\");\n        require(_bassetQuantity > 0, \"quantity must not be 0\");\n\n        require(basketManager.isValidBasset(_basset), \"invalid basset\");\n        require(basketManager.checkBasketBalanceForDeposit(_basset, _bassetQuantity), \"invalid basket\");\n\n        uint256 massetQuantity = basketManager.convertBassetToMassetQuantity(_basset, _bassetQuantity);\n\n        IERC20(_basset).transferFrom(msg.sender, address(this), _bassetQuantity);\n\n        token.mint(_recipient, massetQuantity);\n        emit Minted(msg.sender, _recipient, massetQuantity, _basset, _bassetQuantity);\n\n        return massetQuantity;\n    }\n\n    /***************************************\n              REDEMPTION (PUBLIC)\n    ****************************************/\n\n    /**\n     * @dev Credits the sender with a certain quantity of selected bAsset, in exchange for burning the\n     *      relative mAsset quantity from the sender. Sender also incurs a small mAsset fee, if any.\n     * @param _bAsset           Address of the bAsset to redeem\n     * @param _massetQuantity   Units of the masset to redeem\n     * @return massetMinted     Relative number of mAsset units burned to pay for the bAssets\n     */\n    function redeem(\n        address _bAsset,\n        uint256 _massetQuantity\n    ) external nonReentrant returns (uint256 massetRedeemed) {\n        return _redeemTo(_bAsset, _massetQuantity, msg.sender, false);\n    }\n\n    /**\n     * @dev Credits a recipient with a certain quantity of selected bAsset, in exchange for burning the\n     *      relative Masset quantity from the sender. Sender also incurs a small fee, if any.\n     * @param _bAsset           Address of the bAsset to redeem\n     * @param _massetQuantity   Units of the masset to redeem\n     * @param _recipient        Address to credit with withdrawn bAssets\n     * @return massetMinted     Relative number of mAsset units burned to pay for the bAssets\n     */\n    function redeemTo(\n        address _bAsset,\n        uint256 _massetQuantity,\n        address _recipient\n    ) external nonReentrant returns (uint256 massetRedeemed) {\n        return _redeemTo(_bAsset, _massetQuantity, _recipient, false);\n    }\n\n    /***************************************\n              REDEMPTION (INTERNAL)\n    ****************************************/\n\n    function _redeemTo(\n        address _basset,\n        uint256 _massetQuantity,\n        address _recipient,\n        bool bridgeFlag\n    ) internal returns (uint256 massetRedeemed) {\n        require(_recipient != address(0), \"must be a valid recipient\");\n        require(_massetQuantity > 0, \"masset quantity must be greater than 0\");\n        require(basketManager.isValidBasset(_basset), \"invalid basset\");\n\n        uint256 bassetQuantity = basketManager.convertMassetToBassetQuantity(_basset, _massetQuantity);\n\n        require(basketManager.checkBasketBalanceForWithdrawal(_basset, bassetQuantity), \"invalid basket\");\n\n        if(bridgeFlag) {\n            address bridgeAddress = basketManager.getBridge(_basset);\n            require(bridgeAddress != address(0), \"invalid bridge\");\n            IERC20(_basset).approve(bridgeAddress, bassetQuantity);\n            require(\n                IBridge(bridgeAddress).receiveTokensAt(_basset, bassetQuantity, _recipient, bytes(\"\")),\n                \"call to bridge failed\");\n        } else {\n            IERC20(_basset).transfer(_recipient, bassetQuantity);\n        }\n\n        token.burn(msg.sender, _massetQuantity);\n        emit Redeemed(msg.sender, _recipient, _massetQuantity, _basset, bassetQuantity);\n\n        return _massetQuantity;\n    }\n\n    // For the BRIDGE\n\n    /**\n     * @dev Credits a recipient with a certain quantity of selected bAsset, in exchange for burning the\n     *      relative Masset quantity from the sender. Sender also incurs a small fee, if any.\n     *      This function is designed to also call the bridge in order to have the basset tokens sent to\n     *      another blockchain.\n     * @param _basset           Address of the bAsset to redeem\n     * @param _massetQuantity   Units of the masset to redeem\n     * @param _recipient        Address to credit with withdrawn bAssets\n     * @param _bridgeAddress    This is ignored and is left here for backward compatibility with the FE\n     * @return massetMinted     Relative number of mAsset units burned to pay for the bAssets\n     */\n    function redeemToBridge(\n        address _basset,\n        uint256 _massetQuantity,\n        address _recipient,\n        address _bridgeAddress // IGNORED! for backward compatibility\n    ) external nonReentrant returns (uint256 massetRedeemed) {\n        return _redeemTo(_basset, _massetQuantity, _recipient, true);\n    }\n\n    /**\n     * @dev Credits a recipient with a certain quantity of selected bAsset, in exchange for burning the\n     *      relative Masset quantity from the sender. Sender also incurs a small fee, if any.\n     *      This function is designed to also call the bridge in order to have the basset tokens sent to\n     *      another blockchain.\n     * @param _basset           Address of the bAsset to redeem\n     * @param _massetQuantity   Units of the masset to redeem\n     * @param _recipient        Address to credit with withdrawn bAssets\n     * @return massetMinted     Relative number of mAsset units burned to pay for the bAssets\n     */\n    function redeemToBridge(\n        address _basset,\n        uint256 _massetQuantity,\n        address _recipient\n    ) external nonReentrant returns (uint256 massetRedeemed) {\n        return _redeemTo(_basset, _massetQuantity, _recipient, true);\n    }\n\n    function _decodeAddress(bytes memory data) private pure returns (address) {\n        address addr = abi.decode(data, (address));\n        require(addr != address(0), \"Converter: Error decoding extraData\");\n        return addr;\n    }\n\n    function _encodeAddress(address _address) private pure returns (bytes memory) {\n        require(_address != address(0), \"Converter: Error encoding extraData\");\n        return abi.encode(_address);\n    }\n\n    function tokensReceived(\n        address _operator,\n        address _from,\n        address _to,\n        uint _amount,\n        bytes calldata _userData,\n        bytes calldata _operatorData\n    ) external {\n        emit onTokensReceivedCalled(\n            _operator,\n            _from,\n            _to,\n            _amount,\n            _userData,\n            _operatorData\n        );\n    }\n\n    /**\n     * @dev This is called by the bridge to let us know the user has sent tokens through it and\n     *      into the masset.\n     * @param _orderAmount      Units of the masset to redeem\n     * @param _tokenAddress     Address of the bAsset to redeem\n     * @param _userData         Address of the final recipient as ABI encoded bytes\n     */\n    function onTokensMinted(\n        uint256 _orderAmount,\n        address _tokenAddress,\n        bytes calldata _userData\n    ) external nonReentrant {\n        emit onTokensMintedCalled(msg.sender, _orderAmount, _tokenAddress, _userData);\n\n        require(_orderAmount > 0, \"amount must be > 0\");\n\n        address recipient =  _decodeAddress(_userData);\n        address basset = _tokenAddress;\n\n        address bridgeAddress = basketManager.getBridge(basset);\n        require(msg.sender == bridgeAddress, \"only bridge may call\");\n\n        require(basketManager.isValidBasset(basset), \"invalid basset\");\n        require(basketManager.checkBasketBalanceForDeposit(basset, _orderAmount), \"basket out of balance\");\n\n        uint256 massetQuantity = basketManager.convertBassetToMassetQuantity(basset, _orderAmount);\n        token.mint(recipient, massetQuantity);\n        emit Minted(msg.sender, recipient, massetQuantity, basset, _orderAmount);\n    }\n\n    // Getters\n\n    function getVersion() external view returns (string memory) {\n        return version;\n    }\n\n    function getToken() external view returns (address) {\n        return address(token);\n    }\n\n    function getBasketManager() external view returns (address) {\n        return address(basketManager);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an {IERC777} token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/introspection/IERC1820Registry.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as `account`'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     *  @param account Address of the contract for which to update the cache.\n     *  @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\n     *  If the result is not cached a direct lookup on the contract address is performed.\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     *  {updateERC165Cache} with the contract address.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n"
    },
    "contracts/helpers/InitializableOwnable.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract InitializableOwnable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function _initialize() internal {\n        require(_owner == address(0), \"already initialized\");\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _onlyOwner();\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    * this method is called and separated from modifier to optimize bytecode and save gas.\n    */\n\n    function _onlyOwner() internal view {\n        require(isOwner(), \"InitializableOwnable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"InitializableOwnable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/helpers/InitializableReentrancyGuard.sol": {
      "content": "pragma solidity ^0.5.17;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\n * metering changes introduced in the Istanbul hardfork.\n */\ncontract InitializableReentrancyGuard {\n    /**\n     * 1 - not entered\n     * 2 - entered\n     */\n    uint256 private _notEntered;\n\n    function _initialize() internal {\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive, but in exchange the refund on every call to nonReentrant\n        // will be lower in amount. Since refunds are capped to a percetange of\n        // the total transaction's gas, it is best to keep them low in cases\n        // like this one, to increase the likelihood of the full refund coming\n        // into effect.\n        _notEntered = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        _nonReentrant();\n\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = 2;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = 1;\n    }\n\n    /**\n    * @dev Prevents a contract from calling itself, directly or indirectly.\n    * this method is called and separated from modifier to optimize bytecode and save gas.\n    */\n    function _nonReentrant() internal view {\n        require(_notEntered == 1, \"ReentrancyGuard: reentrant call\");\n    }\n}\n"
    },
    "contracts/masset/IBridge.sol": {
      "content": "pragma solidity ^0.5.17;\n\n/**\n * @title IBridge\n * @dev Interface of the bridge. Bridge is used to exchange basset tokens from another blockchains.\n */\n\ninterface IBridge {\n    /**\n     * @dev Returns the version.\n     */\n    function version() external pure returns (string memory);\n\n    /**\n     * @dev Returns the fee percentage.\n     */\n    function getFeePercentage() external view returns(uint);\n\n    /**\n     * @dev Calculates maximal withdraw.\n     */\n    function calcMaxWithdraw() external view returns (uint);\n\n    /**\n     * @dev ERC-20 tokens approve and transferFrom pattern\n     * See https://eips.ethereum.org/EIPS/eip-20#transferfrom for details.\n     */\n    function receiveTokens(address tokenToUse, uint256 amount) external returns(bool);\n\n    /**\n     * @dev ERC-20 tokens approve and transferFrom pattern\n     * See https://eips.ethereum.org/EIPS/eip-20#transferfrom for details.\n     */\n    function receiveTokensAt(\n        address tokenToUse,\n        uint256 amount,\n        address receiver,\n        bytes calldata extraData\n    ) external returns(bool);\n\n    /**\n     * @dev ERC-777 tokensReceived hook allows to send tokens to a contract and notify it in a single transaction\n     * See https://eips.ethereum.org/EIPS/eip-777#motivation for details.\n     */\n    function tokensReceived (\n        address operator,\n        address from,\n        address to,\n        uint amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Accepts the transaction from the other chain that was voted and sent by the federation contract.\n     * @return Returns a boolean value indicating whether transfer was accepted.\n     */\n    function acceptTransfer(\n        address originalTokenAddress,\n        address receiver,\n        uint256 amount,\n        string calldata symbol,\n        bytes32 blockHash,\n        bytes32 transactionHash,\n        uint32 logIndex,\n        uint8 decimals,\n        uint256 granularity\n    ) external returns(bool);\n\n    /**\n     * @dev Accepts the transaction from the other chain that was voted and sent by the federation contract.\n     * @return Returns a boolean value indicating whether transfer was accepted.\n     */\n    function acceptTransferAt(\n        address originalTokenAddress,\n        address receiver,\n        uint256 amount,\n        string calldata symbol,\n        bytes32 blockHash,\n        bytes32 transactionHash,\n        uint32 logIndex,\n        uint8 decimals,\n        uint256 granularity,\n        bytes calldata userData\n    ) external returns(bool);\n\n    /**\n     * @dev Emitted when cross occured.\n     */\n    event Cross(address indexed _tokenAddress, address indexed _to, uint256 _amount, string _symbol, bytes _userData,\n        uint8 _decimals, uint256 _granularity);\n\n    /**\n     * @dev Emitted when new side token is deployed.\n     */\n    event NewSideToken(address indexed _newSideTokenAddress, address indexed _originalTokenAddress, string _newSymbol, uint256 _granularity);\n\n    /**\n     * @dev Emitted when cross transfer is accepted.\n     */\n    event AcceptedCrossTransfer(address indexed _tokenAddress, address indexed _to, uint256 _amount, uint8 _decimals, uint256 _granularity,\n        uint256 _formattedAmount, uint8 _calculatedDecimals, uint256 _calculatedGranularity, bytes _userData);\n\n    /**\n     * @dev Emitted when fee percentage has changed.\n     */\n    event FeePercentageChanged(uint256 _amount);\n\n    /**\n     * @dev Emitted when error while receiving token occured.\n     */\n    event ErrorTokenReceiver(bytes _errorData);\n}\n"
    },
    "contracts/masset/versions/BasketManager.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract BasketManager {\n\n    using SafeMath for uint256;\n\n    // state\n    address[] private bassetsArray;\n    mapping(address => bool) private bassetsMap;\n    mapping(address => int256) private factorMap;\n    mapping(address => address) private bridgeMap;\n\n    function _isValidBasset(address _basset) internal view returns(bool) {\n        return _basset != address(0) && bassetsMap[_basset];\n    }\n\n    // external\n    constructor(address[] memory _bassets, int256[] memory _factors, address[] memory _bridges) public {\n        require(_bassets.length > 0, \"some basset required\");\n        require(_bassets.length == _factors.length, \"factor array length mismatch\");\n        require(_bridges.length == _factors.length, \"bridge array length mismatch\");\n\n        bassetsArray = _bassets;\n        for(uint i=0; i<bassetsArray.length; i++) {\n            address basset = bassetsArray[i];\n            require(basset != address(0), \"invalid basset address\");\n            require(!bassetsMap[basset], \"basset not unique\");\n            bassetsMap[basset] = true;\n            require(_factors[i] != 0, \"invalid factor\");\n            factorMap[basset] = _factors[i];\n            if(_bridges[i] != address(0)) {\n                bridgeMap[basset] = _bridges[i];\n            }\n        }\n    }\n\n    function isValidBasset(address _basset) external view returns(bool) {\n        return _isValidBasset(_basset);\n    }\n\n    function checkBasketBalanceForDeposit(address _basset, uint256 _bassetQuantity) external view returns(bool) {\n        return _isValidBasset(_basset);\n    }\n\n    function checkBasketBalanceForWithdrawal(address _basset, uint256 _bassetQuantity) external view returns(bool) {\n        return _isValidBasset(_basset);\n    }\n\n    function convertBassetToMassetQuantity(address _basset, uint256 _bassetQuantity) external view returns(uint256) {\n        require(_isValidBasset(_basset), \"invalid basset\");\n        int256 factor = factorMap[_basset];\n        if(factor > 0) {\n            return _bassetQuantity.div(uint256(factor));\n        }\n        return _bassetQuantity.mul(uint256(-factor));\n    }\n\n    function convertMassetToBassetQuantity(address _basset, uint256 _massetQuantity) external view returns(uint256) {\n        require(_isValidBasset(_basset), \"invalid basset\");\n        int256 factor = factorMap[_basset];\n        if(factor > 0) {\n            return _massetQuantity.mul(uint256(factor));\n        }\n        return _massetQuantity.div(uint256(-factor));\n    }\n\n    function getBridge(address _basset) external view returns(address) {\n        return bridgeMap[_basset];\n    }\n\n    function getVersion() external pure returns(string memory) {\n        return \"2.0\";\n    }\n}\n"
    },
    "contracts/masset/Token.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\n\n/**\n * @title Token\n * @dev Implementation of masset Token.\n * Inherits from ERC20 and ERC20Detailed with implemented\n * mint and burn functions.\n */\n\ncontract Token is ERC20, ERC20Detailed, Ownable {\n\n    /**\n     * @notice Constructor called on deployment, initiates the contract.\n     * @param _name The name of the token.\n     * @param _symbol The symbol of the token.\n     * @param _decimals The decimals of the token.\n     * */\n    constructor(string memory _name, string memory _symbol, uint8 _decimals) public\n    ERC20Detailed(_name, _symbol, _decimals) {}\n\n    /**\n     * @notice Creates new tokens and sends them to the recipient.\n     * @param _account The recipient address to get the minted tokens.\n     * @param _amount The amount of tokens to be minted.\n     * */\n    function mint(address _account, uint256 _amount) public onlyOwner {\n        _mint(_account, _amount);\n    }\n\n    /**\n     * @notice Burns tokens for the given account.\n     * @param _account The recipient address to get the minted tokens.\n     * @param _amount The amount of tokens to be minted.\n     * */\n    function burn(address _account, uint256 _amount) public onlyOwner {\n        _burn(_account, _amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n"
    },
    "contracts/mynt/MyntToken.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"../interfaces/IApproveAndCall.sol\";\n\n/**\n * @title Token\n * @dev Implementation of staking Token.\n * Inherits from ERC20 and ERC20Detailed with implemented\n * mint and burn functions.\n */\n\ncontract MyntToken is ERC20, ERC20Detailed, Ownable {\n    // events\n\n    /**\n     * @dev Emitted when market maker address is changed.\n     * @param _address          Address of new market maker.\n     */\n    event MarketMakerChanged(address indexed _address);\n\n    /**\n     * @dev Emitted when presale address is changed.\n     * @param _address          Address of new presale.\n     */\n    event PresaleChanged(address indexed _address);\n\n    // state\n\n    address public marketMaker = address(0);\n    address public presale = address(0);\n\n    /**\n     * @notice Constructor called on deployment, initiates the contract.\n     */\n    constructor() public ERC20Detailed(\"Sovryn Mynt\", \"MYNT\", 18) {}\n\n    /**\n     * @notice setMarketMaker sets the token's market maker address\n     * @param _address The address of the market maker contract\n     */\n    function setMarketMaker(address _address) public onlyOwner {\n        require(_address != address(0), \"invalid address\");\n        marketMaker = _address;\n        emit MarketMakerChanged(_address);\n    }\n\n    /**\n     * @notice setPresale sets the token's presale contract\n     * @param _address The address of the presale contract\n     */\n    function setPresale(address _address) public onlyOwner {\n        require(_address != address(0), \"invalid address\");\n        presale = _address;\n        emit PresaleChanged(_address);\n    }\n\n    /**\n     * @notice Creates new tokens and sends them to the recipient.\n     * @param _account The recipient address to get the minted tokens.\n     * @param _amount The amount of tokens to be minted.\n     */\n    function mint(address _account, uint256 _amount) public {\n        // only the presale contract and the market maker are allowed to mint\n        require(msg.sender == presale || msg.sender == marketMaker, \"not allowed\");\n        _mint(_account, _amount);\n    }\n\n    /**\n     * @notice Burns tokens for the given account.\n     * @param _account The recipient address to get the minted tokens.\n     * @param _amount The amount of tokens to be minted.\n     */\n    function burn(address _account, uint256 _amount) public {\n        // only the market maker is allowed to burn tokens,\n        // ...and the user is allowed to burn his own tokens\n        require(msg.sender == marketMaker || msg.sender == _account, \"not allowed\");\n        _burn(_account, _amount);\n    }\n\n    /**\n     * @notice Approves and then calls the receiving contract.\n     * Useful to encapsulate sending tokens to a contract in one call.\n     * Solidity has no native way to send tokens to contracts.\n     * ERC-20 tokens require approval to be spent by third parties, such as a contract in this case.\n     * @param _spender The contract address to spend the tokens.\n     * @param _amount The amount of tokens to be sent.\n     * @param _data Parameters for the contract call, such as endpoint signature.\n     */\n    function approveAndCall(\n        address _spender,\n        uint256 _amount,\n        bytes memory _data\n    ) public {\n        approve(_spender, _amount);\n        IApproveAndCall(_spender).receiveApproval(msg.sender, _amount, address(this), _data);\n    }\n}\n"
    },
    "contracts/interfaces/IApproveAndCall.sol": {
      "content": "pragma solidity ^0.5.17;\n\n/**\n * @title Interface for contract governance/ApprovalReceiver.sol\n * @dev Interfaces are used to cast a contract address into a callable instance.\n */\ninterface IApproveAndCall {\n    /**\n     * @notice Receives approval from SOV token.\n     * @param _sender The sender of SOV.approveAndCall function.\n     * @param _amount The amount was approved.\n     * @param _token The address of token.\n     * @param _data The data will be used for low level call.\n     * */\n    function receiveApproval(\n        address _sender,\n        uint256 _amount,\n        address _token,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "contracts/mocks/mynt/MockApprovalReceiver.sol": {
      "content": "pragma solidity ^0.5.17;\nimport \"../../interfaces/IApproveAndCall.sol\";\n\n/**\n * @title Interface for contract governance/ApprovalReceiver.sol\n * @dev Interfaces are used to cast a contract address into a callable instance.\n */\ncontract MockApprovalReceiver is IApproveAndCall {\n\n    address public sender;\n    uint256 public amount;\n    address public token;\n    bytes public data;\n\n    function receiveApproval(\n        address _sender,\n        uint256 _amount,\n        address _token,\n        bytes calldata _data\n    ) external {\n        sender = _sender;\n        amount = _amount;\n        token = _token;\n        data = _data;\n    }\n}\n"
    },
    "contracts/meta-asset-token/MetaAssetToken.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"../interfaces/IApproveAndCall.sol\";\nimport \"../interfaces/IProxy.sol\";\nimport \"../shared/ERC20Permit.sol\";\n\n/**\n * @title Token\n * @dev Implementation of staking Token.\n * Inherits from ERC20 and ERC20Detailed with implemented\n * mint and burn functions.\n */\n\ncontract MetaAssetToken is ERC20Permit, ERC20Detailed, Ownable {\n    // events\n\n    /**\n     * @dev Emitted when mAsset config is changed.\n     * @param _newAssetProxy                    Address of new mAsset proxy.\n     */\n    event AssetProxyChanged(address indexed _newAssetProxy);\n\n    /**\n     * @dev Emitted when Basket Manager config is changed.\n     * @param _newBasketManagerProxy                    Address of new Basket Manager proxy.\n     */\n    event BasketManagerProxyChanged(address indexed _newBasketManagerProxy);\n\n    // state\n\n    address public assetProxy;\n    address public basketManagerProxy;\n\n    // modifiers\n    modifier onlyAssetProxy() {\n      require(msg.sender == assetProxy, \"DLLR:unauthorized mAsset proxy\");\n      _;\n    }\n\n    modifier requireValidRecipient(address _recipient) {\n        require(\n            _recipient != address(0) && _recipient != address(this),\n            \"DLLR: Invalid address. Cannot transfer DLLR directly to the DLLR contract or the null address\"\n        );\n\n        address assetImplementation = assetImplementation();\n        address basketManagerImplementation = basketManagerImplementation();\n        require(\n            _recipient != assetProxy && _recipient != assetImplementation && _recipient != basketManagerProxy && _recipient != basketManagerImplementation,\n            \"DLLR: Invalid address. Cannot transfer DLLR directly to a Sovryn protocol address\"\n        );\n\n        _;\n    }\n\n    /**\n     * @notice Constructor called on deployment, initiates the contract.\n     */\n    constructor(string memory _tokenName, string memory _symbol) public ERC20Detailed(_tokenName, _symbol, 18) {}\n\n    /**\n     * @dev getter function of asset implementation address\n     *\n     * @return asset implementation address\n     */\n    function assetImplementation() public view returns(address) {\n        return IProxy(assetProxy).implementation();\n    }\n\n    /**\n     * @dev getter function of basket manager implementation address\n     *\n     * @return basket manager implementation address\n     */\n    function basketManagerImplementation() public view returns(address) {\n        return IProxy(basketManagerProxy).implementation();\n    }\n\n    /**\n     * @notice setAssetConfig sets the mAsset proxy address\n     * @param _assetProxy The address of the mAsset proxy contract\n     */\n    function setAssetProxy(address _assetProxy) external onlyOwner {\n        require(_assetProxy != address(0), \"invalid address\");\n        assetProxy = _assetProxy;\n\n        emit AssetProxyChanged(assetProxy);\n    }\n\n     /**\n     * @notice setBasketManagerConfig sets the Basket Manager proxy address\n     * @param _basketManagerProxy The address of the Basket Manager proxy contract\n     */\n    function setBasketManagerProxy(address _basketManagerProxy) external onlyOwner {\n        require(_basketManagerProxy != address(0), \"invalid address\");\n        basketManagerProxy = _basketManagerProxy;\n        emit BasketManagerProxyChanged(basketManagerProxy);\n    }\n\n    /**\n     * @notice Creates new tokens and sends them to the recipient.\n     * @notice Can be minted only by the mAsset proxy contract.\n     *\n     * @param _account The recipient address to get the minted tokens.\n     * @param _amount The amount of tokens to be minted.\n     */\n    function mint(address _account, uint256 _amount) external onlyAssetProxy {\n        _mint(_account, _amount);\n    }\n\n    /**\n     * @notice Burns tokens for the given account.\n     * @notice Can be burned only by the mAsset proxy contract.\n     *\n     * @param _account The recipient address to get the minted tokens.\n     * @param _amount The amount of tokens to be minted.\n     */\n    function burn(address _account, uint256 _amount) external onlyAssetProxy {\n        _burn(_account, _amount);\n    }\n\n    /**\n     * @notice Only owner who can transfer the token.\n     * @notice destination cannot be:\n     * - Zero address.\n     * - DDLR contract address.\n     * - Sovryn mAsset proxy & implementation address.\n     * - Sovryn Basket Manager proxy & implementation address.\n     *\n     * @param _recipient Recipient of the token.\n     * @param _amount The amount of token that will be transferred.\n     *\n     * @return true / false.\n     */\n    function transfer(address _recipient, uint256 _amount) public requireValidRecipient(_recipient) returns (bool) {\n        _transfer(_msgSender(), _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Only owner who can transfer the token.\n     * @notice destination cannot be:\n     * - Zero address.\n     * - DDLR contract address.\n     * - Sovryn mAsset proxy & implementation address.\n     * - Sovryn Basket Manager proxy & implementation address.\n     *\n     * @param _from Sender of the token.\n     * @param _to Recipient of the token.\n     * @param _amount The amount of token that will be transferred.\n     *\n     * @return true / false.\n     */\n    function transferFrom(address _from, address _to, uint256 _amount) public requireValidRecipient(_to) returns (bool) {\n        _approve(\n            _from,\n            msg.sender,\n            allowance(_from, msg.sender).sub(_amount, \"ERC20: transfer amount exceeds allowance\")\n        );\n        _transfer(_from, _to, _amount);\n        return true;\n    }\n\n    /**\n     * @notice transfer utilizing EIP-2612, to reduce the additional sending transaction for doing the approval to the spender.\n     *\n     * @notice destination cannot be:\n     * - Zero address.\n     * - DDLR contract address.\n     * - Sovryn mAsset proxy & implementation address.\n     * - Sovryn Basket Manager proxy & implementation address.\n     *\n     * @dev By calling this function, the allowance will be overwritten by the total amount.\n     *\n     * @param _from Sender of the token.\n     * @param _to Recipient of the token.\n     * @param _amount The amount of the token that will be transferred.\n     * @param _deadline Expiration time of the signature.\n     * @param _v Last 1 byte of ECDSA signature.\n     * @param _r First 32 bytes of ECDSA signature.\n     * @param _s 32 bytes after _r in ECDSA signature.\n     */\n    function transferWithPermit(address _from, address _to, uint256 _amount, uint256 _deadline, uint8 _v, bytes32 _r, bytes32 _s) external requireValidRecipient(_to) {\n        permit(_from, msg.sender, _amount, _deadline, _v, _r, _s);\n        transferFrom(_from, _to, _amount);\n    }\n\n    /**\n     * @notice Approves and then calls the receiving contract.\n     * Useful to encapsulate sending tokens to a contract in one call.\n     * Solidity has no native way to send tokens to contracts.\n     * ERC-20 tokens require approval to be spent by third parties, such as a contract in this case.\n     * @param _spender The contract address to spend the tokens.\n     * @param _amount The amount of tokens to be sent.\n     * @param _data Parameters for the contract call, such as endpoint signature.\n     */\n    function approveAndCall(\n        address _spender,\n        uint256 _amount,\n        bytes calldata _data\n    ) external {\n        approve(_spender, _amount);\n        IApproveAndCall(_spender).receiveApproval(msg.sender, _amount, address(this), _data);\n    }\n}\n"
    },
    "contracts/interfaces/IProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.5.17;\n\ninterface IProxy {\n  function implementation() external view returns (address);\n}"
    },
    "contracts/shared/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.5.17;\n\nimport \"../interfaces/IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n */\ncontract ERC20Permit is ERC20, IERC20Permit {\n    mapping (address => uint256) private _nonces;\n\n    bytes32 private constant EIP712DOMAIN_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    bytes32 private constant NAME_HASH = keccak256(\"MetaAsset\");\n    bytes32 private constant VERSION_HASH = keccak256(\"1\");\n\n    bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"MetaAsset:AUTH_EXPIRED\");\n\n        bytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _nonces[owner]++, deadline));\n        _validateSignedData(owner, encodeData, v, r, s);\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view returns (uint256) {\n        return _nonces[owner];\n    }\n\n    function _validateSignedData(address signer, bytes32 encodeData, uint8 v, bytes32 r, bytes32 s) internal view {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR(),\n                encodeData\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\n        require(recoveredAddress != address(0) && recoveredAddress == signer, \"MetaAsset:INVALID_SIGNATURE\");\n    }\n\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                EIP712DOMAIN_HASH,\n                NAME_HASH,\n                VERSION_HASH,\n                getChainID(),\n                address(this)\n            )\n        );\n    }\n\n    function getChainID() public pure returns (uint256) {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n}"
    },
    "contracts/interfaces/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.5.17;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}"
    },
    "contracts/mocks/masset/MockMetaAssetToken.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"../../meta-asset-token/MetaAssetToken.sol\";\n\ncontract MockMetaAssetToken is MetaAssetToken {\n\n  address private assetImpl;\n  address private basketManagerImpl;\n\n  constructor(\n    string memory _tokenName,\n    string memory _symbol,\n    address _assetImplementation,\n    address _basketManagerImplementation\n  ) public MetaAssetToken(_tokenName, _symbol) {\n    assetImpl = _assetImplementation;\n    basketManagerImpl = _basketManagerImplementation;\n  }\n\n  function assetImplementation() public view returns(address) {\n      return assetImpl;\n  }\n\n    /**\n     * @dev getter function of basket manager implementation address\n     *\n     * @return basket manager implementation address\n     */\n  function basketManagerImplementation() public view returns(address) {\n      return basketManagerImpl;\n  }\n}"
    },
    "contracts/mocks/shared/MockERC20Permit.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"../../shared/ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\n\ncontract MockERC20Permit is ERC20Permit, ERC20Detailed {\n  /**\n  * @notice Constructor called on deployment, initiates the contract.\n  */\n  constructor(string memory _tokenName, string memory _symbol, address _initialHolder, uint256 _initialSupply) public ERC20Detailed(_tokenName, _symbol, 18) {\n    _mint(_initialHolder, _initialSupply);\n  }\n}"
    },
    "contracts/mocks/shared/MockERC20.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Mintable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC777Recipient } from \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\n\ncontract MockERC20 is ERC20, ERC20Detailed, ERC20Mintable {\n\n    function () external payable {\n    }\n\n    constructor (\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _initialRecipient,\n        uint256 _initialMint\n    ) ERC20Detailed(_name, _symbol, _decimals) public {\n        _mint(_initialRecipient, _initialMint.mul(10 ** uint256(_decimals)));\n    }\n\n    function giveMe(uint256 amount) external {\n        _mint(msg.sender, amount);\n    }\n\n    function callTokensReceived(\n        address aggregator,\n        address operator,\n        address from,\n        address to,\n        uint amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n        ) external {\n        IERC777Recipient(aggregator).tokensReceived(operator, from, to, amount, userData, operatorData);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Mintable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\nimport \"../../access/roles/MinterRole.sol\";\n\n/**\n * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},\n * which have permission to mint (create) new tokens as they see fit.\n *\n * At construction, the deployer of the contract is the only minter.\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the {MinterRole}.\n     */\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/roles/MinterRole.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"../Roles.sol\";\n\ncontract MinterRole is Context {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(_msgSender());\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(_msgSender()), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(_msgSender());\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Roles.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"
    },
    "contracts/masset/MassetV3.sol": {
      "content": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport { IERC777Recipient } from \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport { IERC1820Registry } from \"@openzeppelin/contracts/introspection/IERC1820Registry.sol\";\nimport { InitializableOwnable } from \"../helpers/InitializableOwnable.sol\";\nimport { InitializableReentrancyGuard } from \"../helpers/InitializableReentrancyGuard.sol\";\nimport { IBridge } from \"./IBridge.sol\";\nimport { BasketManagerV3 } from \"./BasketManagerV3.sol\";\nimport { FeesVault } from \"../vault/FeesVault.sol\";\nimport { FeesManager } from \"./FeesManager.sol\";\nimport \"./Token.sol\";\n\n/**\n * @title MassetV3\n * @dev Contract is responsible for managing mAsset and bAsset.\n * Used for minting and burning tokens, calculating fees and calling the bridge\n * if transaction based on token from another blockchain.\n */\n\ncontract MassetV3 is IERC777Recipient, InitializableOwnable, InitializableReentrancyGuard {\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for Token;\n\n    // events\n\n    /**\n     * @dev Emitted when deposit is completed.\n     * @param minter            Address of the minter.\n     * @param recipient         Address of the recipient.\n     * @param massetQuantity    Masset quantity.\n     * @param bAsset            Address of the bAsset.\n     * @param bassetQuantity    Basset quantity.\n     */\n    event Minted(\n        address indexed minter,\n        address indexed recipient,\n        uint256 massetQuantity,\n        address bAsset,\n        uint256 bassetQuantity\n    );\n\n    /**\n     * @dev Emitted when withdrawal is completed.\n     * @param redeemer          Address of the redeemer.\n     * @param recipient         Address of the recipient.\n     * @param massetQuantity    Masset quantity.\n     * @param bAsset            Address of the bAsset.\n     * @param bassetQuantity    Basset quantity.\n     */\n    event Redeemed(\n        address indexed redeemer,\n        address indexed recipient,\n        uint256 massetQuantity,\n        address bAsset,\n        uint256 bassetQuantity\n    );\n\n    /**\n     * @dev Emitted when tokensReceived method is called by the bridge.\n     * @param operator         Address operator requesting the transfer.\n     * @param from             Address token holder address.\n     * @param to               Address recipient address.\n     * @param amount           uint256 amount of tokens to transfer.\n     * @param userData         Bytes extra information provided by the token holder (if any).\n     * @param operatorData     Bytes extra information provided by the operator (if any).\n     */\n    event onTokensReceivedCalled(\n        address operator,\n        address from,\n        address to,\n        uint amount,\n        bytes userData,\n        bytes operatorData\n    );\n\n    /**\n     * @dev Emitted when onTokensMinted method is called by the bridge.\n     * @param sender           Address of the sender.\n     * @param orderAmount      Units of the masset to redeem.\n     * @param tokenAddress     Address of the bAsset to redeem.\n     * @param userData         Address of the final recipient as ABI encoded bytes.\n     */\n    event onTokensMintedCalled(\n        address indexed sender,\n        uint256 orderAmount,\n        address tokenAddress,\n        bytes userData\n    );\n\n    // state\n\n    bytes32 constant ERC777_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");\n\n    string private version;\n\n    BasketManagerV3 private basketManager;\n    Token private token;\n\n    FeesVault private feesVault;\n    FeesManager private feesManager;\n\n    // internal\n\n    /**\n     * @dev Register this contracts as implementer of the \"ERC777 Tokens Recipient\" interface in the ERC1820 registry.\n     */\n    function registerAsERC777Recipient() internal {\n        IERC1820Registry ERC1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n        ERC1820.setInterfaceImplementer(address(this), ERC777_RECIPIENT_INTERFACE_HASH, address(this));\n    }\n\n    // public\n\n    /**\n   * @dev Contract initializer.\n   * @param _basketManagerAddress           Address of the basket manager.\n   * @param _tokenAddress                   Address of the mAsset token.\n   * @param _registerAsERC777RecipientFlag  Bool determine if contract should be register as ERC777 recipient.\n   */\n    function initialize(\n        address _basketManagerAddress,\n        address _tokenAddress,\n        bool _registerAsERC777RecipientFlag) public {\n\n        require(address(basketManager) == address(0) && address(token) == address(0), \"already initialized\");\n        require(_basketManagerAddress != address(0), \"invalid basket manager\");\n        require(_tokenAddress != address(0), \"invalid token\");\n\n        InitializableOwnable._initialize();\n        InitializableReentrancyGuard._initialize();\n\n        basketManager = BasketManagerV3(_basketManagerAddress);\n        token = Token(_tokenAddress);\n        if(_registerAsERC777RecipientFlag) {\n            registerAsERC777Recipient();\n        }\n\n        version = \"1.0\";\n    }\n\n    /***************************************\n                MINTING (PUBLIC)\n    ****************************************/\n\n    /**\n     * @dev Mint a single mAsset, at a 1:1 ratio with the bAsset. This contract\n     *      must have approval to spend the senders bAsset.\n     * @param _bAsset         Address of the bAsset.\n     * @param _bAssetQuantity Quantity in bAsset units.\n     * @return massetMinted   Number of newly minted mAssets.\n     */\n    function mint(\n        address _bAsset,\n        uint256 _bAssetQuantity\n    )\n    external\n    nonReentrant\n    returns (uint256 massetMinted)\n    {\n        return _mintTo(_bAsset, _bAssetQuantity, msg.sender);\n    }\n\n    /**\n     * @dev Mint a single mAsset to recipient address, at a 1:1 ratio with the bAsset.\n     *      This contract must have approval to spend the senders bAsset.\n     * @param _bAsset         Address of the bAsset.\n     * @param _bAssetQuantity Quantity in bAsset units.\n     * @param _recipient      Receipient of the newly minted mAsset tokens.\n     * @return massetMinted   Number of newly minted mAssets.\n     */\n    function mintTo(\n        address _bAsset,\n        uint256 _bAssetQuantity,\n        address _recipient\n    )\n    external\n    nonReentrant\n    returns (uint256 massetMinted)\n    {\n        return _mintTo(_bAsset, _bAssetQuantity, _recipient);\n    }\n\n    /***************************************\n              MINTING (INTERNAL)\n    ****************************************/\n\n    /**\n     * @dev Mint a single mAsset to recipient address, at a 1:1 ratio with the bAsset.\n     *      This contract must have approval to spend the senders bAsset.\n     * @param _basset         Address of the bAsset.\n     * @param _bassetQuantity Quantity in bAsset units.\n     * @param _recipient      Receipient of the newly minted mAsset tokens.\n     * @return massetMinted   Number of newly minted mAssets.\n     */\n    function _mintTo(\n        address _basset,\n        uint256 _bassetQuantity,\n        address _recipient\n    )\n    internal\n    returns (uint256 massetMinted)\n    {\n        require(_recipient != address(0), \"must be a valid recipient\");\n        require(_bassetQuantity > 0, \"quantity must not be 0\");\n\n        require(basketManager.isValidBasset(_basset), \"invalid basset\");\n        require(basketManager.checkBasketBalanceForDeposit(_basset, _bassetQuantity), \"invalid basket\");\n\n        (uint256 massetQuantity, uint256 bassetQuantity) = basketManager.convertBassetToMassetQuantity(_basset, _bassetQuantity);\n\n        IERC20(_basset).safeTransferFrom(msg.sender, address(this), bassetQuantity);\n\n        uint256 massetsToMint = _mintAndCalulateFee(massetQuantity, false);\n        token.mint(_recipient, massetsToMint);\n\n        emit Minted(msg.sender, _recipient, massetsToMint, _basset, bassetQuantity);\n\n        return massetsToMint;\n    }\n\n    /**\n     * @dev Mints fee to vault contract and return the amount of massets that goes to the user.\n     * @param massetQuantity    Amount of massets.\n     * @param _bridgeFlag       Flag that indicates if the proces is used with conjunction with bridge.\n     * @return massetsToMint    Amount of massets that is left to mint for user.\n     */\n    function _mintAndCalulateFee(uint256 massetQuantity, bool _bridgeFlag) internal returns (uint256 massetsToMint) {\n        uint256 fee;\n        if (_bridgeFlag) {\n            fee = feesManager.calculateDepositBridgeFee(massetQuantity);\n        } else {\n            fee = feesManager.calculateDepositFee(massetQuantity);\n        }\n\n        massetsToMint = massetQuantity.sub(fee);\n\n        token.mint(address(feesVault), fee);\n\n        return massetsToMint;\n    }\n\n    /***************************************\n              REDEMPTION (PUBLIC)\n    ****************************************/\n\n    /**\n     * @dev Credits the sender with a certain quantity of selected bAsset, in exchange for burning the\n     *      relative mAsset quantity from the sender. Sender also incurs a small mAsset fee, if any.\n     * @param _bAsset           Address of the bAsset to redeem.\n     * @param _massetQuantity   Units of the masset to redeem.\n     * @return massetRedeemed   Relative number of mAsset units burned to pay for the bAssets.\n     */\n    function redeem(\n        address _bAsset,\n        uint256 _massetQuantity\n    ) external nonReentrant returns (uint256 massetRedeemed) {\n        return _redeemTo(_bAsset, _massetQuantity, msg.sender, false, false);\n    }\n\n    /**\n     * @dev Credits a recipient with a certain quantity of selected bAsset, in exchange for burning the\n     *      relative mAsset quantity from the sender. Sender also incurs a small fee, if any.\n     * @param _bAsset           Address of the bAsset to redeem.\n     * @param _massetQuantity   Units of the masset to redeem.\n     * @param _recipient        Address to credit with withdrawn bAssets.\n     * @return massetRedeemed   Relative number of mAsset units burned to pay for the bAssets.\n     */\n    function redeemTo(\n        address _bAsset,\n        uint256 _massetQuantity,\n        address _recipient\n    ) external nonReentrant returns (uint256 massetRedeemed) {\n        return _redeemTo(_bAsset, _massetQuantity, _recipient, false, false);\n    }\n\n    /***************************************\n              REDEMPTION (INTERNAL)\n    ****************************************/\n\n    /**\n     * @dev Credits a recipient with a certain quantity of selected bAsset, in exchange for burning the\n     *      relative mAsset quantity from the sender. Sender also incurs a small fee, if any.\n     * @param _basset           Address of the bAsset to redeem.\n     * @param _massetQuantity   Units of the masset to redeem.\n     * @param _recipient        Address to credit with withdrawn bAssets.\n     * @param _bridgeFlag       Flag that indicates if the reedem proces is used with conjunction with bridge.\n     * @param _useCallback      Flag that indicates if this method should call onTokensMinted in case of usage of bridge.\n     * @return massetMinted     Relative number of mAsset units burned to pay for the bAssets.\n     */\n    function _redeemTo(\n        address _basset,\n        uint256 _massetQuantity,\n        address _recipient,\n        bool _bridgeFlag,\n        bool _useCallback\n    ) internal returns (uint256 massetRedeemed) {\n        require(_recipient != address(0), \"must be a valid recipient\");\n        require(_massetQuantity > 0, \"masset quantity must be greater than 0\");\n        require(basketManager.isValidBasset(_basset), \"invalid basset\");\n\n        address massetSource = (_bridgeFlag && !_useCallback) ? _recipient : msg.sender;\n\n        // massetsToBurn is the amount of massets that is left to burn after the fee was taken.\n        // It is used to calculate amount of bassets that are transfered to user.\n        uint256 massetsAfterFee = _transferAndCalulateFee(_massetQuantity, massetSource, _bridgeFlag);\n        (uint256 bassetQuantity, uint256 massetsToBurn) = basketManager.convertMassetToBassetQuantity(_basset, massetsAfterFee);\n\n        require(basketManager.checkBasketBalanceForWithdrawal(_basset, bassetQuantity), \"invalid basket\");\n\n        token.burn(massetSource, massetsToBurn);\n        // In case of withdrawal to bridge the receiveTokensAt is called instead of transfer.\n        if(_bridgeFlag && _useCallback) {\n            address bridgeAddress = basketManager.getBridge(_basset);\n            require(bridgeAddress != address(0), \"invalid bridge\");\n\n            IERC20(_basset).approve(bridgeAddress, bassetQuantity);\n            require(\n                IBridge(bridgeAddress).receiveTokensAt(_basset, bassetQuantity, _recipient, bytes(\"\")),\n                \"call to bridge failed\");\n        } else {\n            IERC20(_basset).safeTransfer(_recipient, bassetQuantity);\n        }\n\n        emit Redeemed(massetSource, _recipient, _massetQuantity, _basset, bassetQuantity);\n\n        return massetsToBurn;\n    }\n\n    /**\n     * @dev Transfers fee to vault contract and return the amount of massets that will be burned\n     *      must have approval to spend the senders Masset.\n     * @param massetQuantity        Amount of massets to withdraw.\n     * @param sender                Owner of massets.\n     * @param _bridgeFlag           Flag that indicates if the proces is used with conjunction with bridge.\n     * @return massetsToBurn        Amount of massets that is left to burn.\n     */\n    function _transferAndCalulateFee(uint256 massetQuantity, address sender, bool _bridgeFlag) internal returns (uint256 massetsToBurn) {\n        uint256 fee;\n        if (_bridgeFlag) {\n            fee = feesManager.calculateRedeemBridgeFee(massetQuantity);\n        } else {\n            fee = feesManager.calculateRedeemFee(massetQuantity);\n        }\n\n        massetsToBurn = massetQuantity.sub(fee);\n\n        token.safeTransferFrom(sender, address(feesVault), fee);\n\n        return massetsToBurn;\n    }\n\n    // For the BRIDGE\n\n    /**\n     * @dev Credits a recipient with a certain quantity of selected bAsset, in exchange for burning the\n     *      relative mAsset quantity from the sender. Sender also incurs a small fee, if any.\n     *      This function is designed to also call the bridge in order to have the basset tokens sent to\n     *      another blockchain.\n     * @param _basset           Address of the bAsset to redeem.\n     * @param _massetQuantity   Units of the mAsset to redeem.\n     * @param _recipient        Address to credit with withdrawn bAssets.\n     * @param _bridgeAddress    This is ignored and is left here for backward compatibility with the FE.\n     * @return massetRedeemed   Relative number of mAsset units burned to pay for the bAssets.\n     */\n    function redeemToBridge(\n        address _basset,\n        uint256 _massetQuantity,\n        address _recipient,\n        address _bridgeAddress // IGNORED! for backward compatibility\n    ) external nonReentrant returns (uint256 massetRedeemed) {\n        return _redeemTo(_basset, _massetQuantity, _recipient, true, true);\n    }\n\n    /**\n     * @dev Credits a recipient with a certain quantity of selected bAsset, in exchange for burning the\n     *      relative mAsset quantity from the sender. Sender also incurs a small fee, if any.\n     *      This function is designed to also call the bridge in order to have the basset tokens sent to\n     *      another blockchain.\n     * @param _basset           Address of the bAsset to redeem.\n     * @param _massetQuantity   Units of the mAsset to redeem.\n     * @param _recipient        Address to credit with withdrawn bAssets.\n     * @return massetRedeemed   Relative number of mAsset units burned to pay for the bAssets.\n     */\n    function redeemToBridge(\n        address _basset,\n        uint256 _massetQuantity,\n        address _recipient\n    ) external nonReentrant returns (uint256 massetRedeemed) {\n        return _redeemTo(_basset, _massetQuantity, _recipient, true, true);\n    }\n\n    /**\n     * @dev Credits a recipient with a certain quantity of selected bAsset, in exchange for burning the\n     *      relative mAsset quantity from the sender. Sender also incurs a small fee, if any.\n     *      This function is designed to be called by the bridge in order to have diffrent fees.\n     * @param _basset           Address of the bAsset to redeem.\n     * @param _massetQuantity   Units of the mAsset to redeem.\n     * @param _recipient        Address to credit with withdrawn bAssets.\n     * @return massetMinted     Relative number of mAsset units burned to pay for the bAssets.\n     */\n    function redeemByBridge(\n        address _basset,\n        uint256 _massetQuantity,\n        address _recipient\n    ) external nonReentrant returns (uint256 massetRedeemed) {\n        address bridgeAddress = basketManager.getBridge(_basset);\n        require(bridgeAddress != address(0), \"invalid bridge\");\n        require(bridgeAddress == msg.sender, \"must be called by bridge\");\n\n        return _redeemTo(_basset, _massetQuantity, _recipient, true, false);\n    }\n\n    /**\n     * @dev Decode bytes data to address.\n     * @param data              Data to decode.\n     * @return address          Decoded address.\n     */\n    function _decodeAddress(bytes memory data) private pure returns (address) {\n        address addr = abi.decode(data, (address));\n        require(addr != address(0), \"Converter: Error decoding extraData\");\n        return addr;\n    }\n\n    /**\n     * @dev Encode address to bytes data.\n     * @param _address          Address to encode.\n     * @return address          Decoded address.\n     */\n    function _encodeAddress(address _address) private pure returns (bytes memory) {\n        require(_address != address(0), \"Converter: Error encoding extraData\");\n        return abi.encode(_address);\n    }\n\n    /**\n     * @dev This is called by the bridge to let us know tokens have been received.\n     * @param _operator         Address operator requesting the transfer.\n     * @param _from             Address token holder address.\n     * @param _to               Address recipient address.\n     * @param _amount           uint256 amount of tokens to transfer.\n     * @param _userData         Bytes extra information provided by the token holder (if any).\n     * @param _operatorData     Bytes extra information provided by the operator (if any).\n     */\n    function tokensReceived(\n        address _operator,\n        address _from,\n        address _to,\n        uint _amount,\n        bytes calldata _userData,\n        bytes calldata _operatorData\n    ) external {\n        emit onTokensReceivedCalled(\n            _operator,\n            _from,\n            _to,\n            _amount,\n            _userData,\n            _operatorData\n        );\n    }\n\n    /**\n     * @dev This is called by the bridge to let us know the user has sent tokens through it and\n     *      into the mAsset.\n     * @param _orderAmount      Units of the mAsset to redeem.\n     * @param _tokenAddress     Address of the bAsset to redeem.\n     * @param _userData         Address of the final recipient as ABI encoded bytes.\n     */\n    function onTokensMinted(\n        uint256 _orderAmount,\n        address _tokenAddress,\n        bytes calldata _userData\n    ) external nonReentrant {\n        emit onTokensMintedCalled(msg.sender, _orderAmount, _tokenAddress, _userData);\n\n        require(_orderAmount > 0, \"amount must be > 0\");\n\n        address recipient =  _decodeAddress(_userData);\n        address basset = _tokenAddress;\n\n        address bridgeAddress = basketManager.getBridge(basset);\n        require(msg.sender == bridgeAddress, \"only bridge may call\");\n\n        require(basketManager.isValidBasset(basset), \"invalid basset\");\n        require(basketManager.checkBasketBalanceForDeposit(basset, _orderAmount), \"basket out of balance\");\n\n        (uint256 massetQuantity, uint256 bassetQuantity) = basketManager.convertBassetToMassetQuantity(basset, _orderAmount);\n        uint256 massetsToMint = _mintAndCalulateFee(massetQuantity, true);\n        token.mint(recipient, massetsToMint);\n\n        emit Minted(msg.sender, recipient, massetsToMint, basset, bassetQuantity);\n    }\n\n    // Getters\n\n    function getFeesVault() external view returns (address) {\n        return address(feesVault);\n    }\n\n    function getFeesManager() external view returns (address) {\n        return address(feesManager);\n    }\n\n    function getVersion() external view returns (string memory) {\n        return version;\n    }\n\n    function getToken() external view returns (address) {\n        return address(token);\n    }\n\n    function getBasketManager() external view returns (address) {\n        return address(basketManager);\n    }\n\n    // v3 migration\n    /**\n     * @dev Migration to V3 version.\n     * @param _basketManagerAddress     Address of new BasketManagerV3.\n     * @param _tokenAddress             Address of mAsset token.\n     * @param _feesVaultAddress         Address of FeesVault contract.\n     * @param _feesManagerAddress       Adress of FeesManager contract.\n     */\n    function upgradeToV3(\n        address _basketManagerAddress,\n        address _tokenAddress,\n        address _feesVaultAddress,\n        address _feesManagerAddress\n    ) external {\n        require(\n            keccak256(bytes(version)) == keccak256(bytes(\"1.0\")) ||\n            keccak256(bytes(version)) == keccak256(bytes(\"2.0\")), \"wrong version (1)\");\n        require(keccak256(bytes(BasketManagerV3(_basketManagerAddress).getVersion())) == keccak256(bytes(\"3.0\")), \"wrong version (2)\");\n        require(_feesVaultAddress != address(0), \"invalid vault address\");\n        require(_feesManagerAddress != address(0), \"invalid fees manager address\");\n\n        feesVault = FeesVault(_feesVaultAddress);\n        feesManager = FeesManager(_feesManagerAddress);\n        basketManager = BasketManagerV3(_basketManagerAddress);\n        token = Token(_tokenAddress);\n        version = \"3.0\";\n        InitializableReentrancyGuard._initialize();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/masset/BasketManagerV3.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { InitializableOwnable } from \"../helpers/InitializableOwnable.sol\";\n\n\n/**\n * @title BasketManagerV3\n * @dev Contract is responsible for mAsset and bAsset exchange process and\n * managing basket with bAsset tokens.\n * Allows to add and/or remove bAsset, calculate balances, converts tokens quantity\n * to adjust precisions or set/get parameters: bridge, factor, range and paused.\n */\n\ncontract BasketManagerV3 is InitializableOwnable {\n\n    using SafeMath for uint256;\n\n    // Events\n\n    /**\n     * @dev Event emitted when basset is added.\n     * @param basset Address of the bAsset contract.\n     */\n    event BassetAdded (address basset);\n\n    /**\n     * @dev Event emitted when basset is removed.\n     * @param basset Address of the bAsset contract.\n     */\n    event BassetRemoved (address basset);\n\n    /**\n     * @dev Event emitted when factor is changed.\n     * @param basset Address of the bAsset contract.\n     * @param factor Factor of fees.\n     */\n    event FactorChanged (address basset, int256 factor);\n\n    /**\n     * @dev Event emitted when bridge is changed.\n     * @param basset Address of the bAsset contract.\n     * @param bridge Address of bridge.\n     */\n    event BridgeChanged (address basset, address bridge);\n\n    /**\n     * @dev Event emitted when range is changed.\n     * @param basset    Address of the bAsset contract.\n     * @param min       Minimal value of range.\n     * @param max       Maximal value of range.\n     */\n    event RangeChanged (address basset, uint256 min, uint256 max);\n\n    /**\n     * @dev Event emitted when paused is changed.\n     * @param basset    Address of the bAsset contract.\n     * @param paused    Determine if paused or not.\n     */\n    event PausedChanged (address basset, bool paused);\n\n    uint256 constant MAX_VALUE = 1000;\n\n    // state\n    string version;\n    address masset;\n    address[] private bassetsArray;\n    mapping(address => int256) private factorMap;\n    mapping(address => address) private bridgeMap;\n    mapping(address => uint256) private minMap;\n    mapping(address => uint256) private maxMap;\n    mapping(address => bool) private pausedMap;\n\n    // Modifiers\n\n    /**\n    * @dev Prevents a contract from making actions on paused bAssets.\n    */\n    modifier notPaused(address _basset) {\n        _notPaused(_basset);\n        _;\n    }\n\n    /**\n    * @dev Prevents a contract from making actions on invalid bAssets.\n    */\n    modifier validBasset(address _basset) {\n        _validBasset(_basset);\n        _;\n    }\n\n    /**\n    * @dev Prevents a contract from making actions on paused bAssets.\n    * This method is called and separated from modifier to optimize bytecode and save gas.\n    */\n    function _notPaused(address _basset) internal view {\n        require(!pausedMap[_basset], \"basset is paused\");\n    }\n\n\n    /**\n    * @dev Prevents a contract from making actions on invalid bAssets.\n    * This method is called and separated from modifier to optimize bytecode and save gas.\n    */\n    function _validBasset(address _basset) internal view {\n        require(factorMap[_basset] != 0, \"invalid basset\");\n    }\n\n    // Initializer\n\n    /**\n   * @dev Contract initializer.\n   * @param _masset     Address of the mAsset contract.\n   */\n    function initialize(address _masset) external {\n        require(masset == address(0), \"already initialized\");\n        _initialize();\n        masset = _masset;\n        version = \"3.0\";\n    }\n\n    // Methods for Masset logic\n\n    /**\n     * @dev Checks if bAasset is valid by checking its presence in the bAssets factors list.\n     */\n    function isValidBasset(address _basset) public view returns(bool) {\n        return (factorMap[_basset] != 0);\n    }\n\n    /**\n     * @dev Checks if ratio of bAssets in basket is within limits to make a deposit of specific asset.\n     * @param _basset           Address of bAsset to deposit.\n     * @param _bassetQuantity   Amount of bAssets to deposit.\n     * @return Flag indicating whether a deposit can be made.\n     */\n    function checkBasketBalanceForDeposit(\n        address _basset,\n        uint256 _bassetQuantity) public view validBasset(_basset) notPaused(_basset) returns(bool) {\n\n        (uint256 massetQuantity, ) = convertBassetToMassetQuantity(_basset, _bassetQuantity);\n        uint256 bassetBalance = IERC20(_basset).balanceOf(masset);\n\n        (uint256 totalBassetBalanceInMasset, ) = convertBassetToMassetQuantity(_basset, bassetBalance);\n\n        uint256 balance = totalBassetBalanceInMasset.add(massetQuantity);\n        uint256 total = getTotalMassetBalance().add(massetQuantity);\n        uint256 ratio = balance.mul(MAX_VALUE).div(total);\n        uint256 max = maxMap[_basset];\n        return ratio <= max;\n    }\n\n    /**\n     * @dev Checks if ratio of bAssets in basket is within limits to make a withdrawal of specific asset.\n     * @param _basset           Address of bAsset to redeem.\n     * @param _bassetQuantity   Amount of bAssets to redeem.\n     * @return Flag indicating whether a withdrawal can be made.\n     */\n    function checkBasketBalanceForWithdrawal(\n        address _basset,\n        uint256 _bassetQuantity) public view validBasset(_basset) notPaused(_basset) returns(bool) {\n\n        (uint256 massetQuantity, ) = convertBassetToMassetQuantity(_basset, _bassetQuantity);\n        uint256 bassetBalance = IERC20(_basset).balanceOf(masset);\n        (uint256 totalBassetBalanceInMasset, ) = convertBassetToMassetQuantity(_basset, bassetBalance);\n\n        require(totalBassetBalanceInMasset >= massetQuantity, \"basset balance is not sufficient\");\n\n        uint256 balance = totalBassetBalanceInMasset.sub(massetQuantity);\n        uint256 total = getTotalMassetBalance().sub(massetQuantity);\n\n        uint256 min = minMap[_basset];\n        if (total == 0) return min == 0;\n\n        uint256 ratio = balance.mul(MAX_VALUE).div(total);\n        return ratio >= min;\n    }\n\n    /**\n     * @dev Converts bAsset to mAsset quantity. This is used to adjust precision.\n     *      Despite bAssets and mAssets having 1:1 ratio, they may have diffrent decimal factors.\n     *      Since the ratio may cause fractions, the bAsset is adjusted to match nearest non fraction amount and returned.\n     * @param _basset           Address of bAsset.\n     * @param _bassetQuantity   Amount of bAssets to check.\n     * @return Calculated amount of mAssets and Adjusted amount of bAssets.\n     */\n    function convertBassetToMassetQuantity(\n        address _basset,\n        uint256 _bassetQuantity) public view validBasset(_basset) returns(uint256 massetQuantity, uint256 bassetQuantity) {\n\n        int256 factor = factorMap[_basset];\n        if(factor > 0) {\n            massetQuantity = _bassetQuantity.div(uint256(factor));\n            bassetQuantity = massetQuantity.mul(uint256(factor));\n            return (massetQuantity, bassetQuantity);\n        }\n        massetQuantity = _bassetQuantity.mul(uint256(-factor));\n        return (massetQuantity, _bassetQuantity);\n    }\n\n    /**\n     * @dev Converts mAsset to bAsset quantity. This is used to adjust precisions.\n     *      Despite bAssets and mAssets having 1:1 ratio, they may have diffrent decimal factors.\n     *      Since the ratio may cause fractions, the mAsset is adjusted to match nearest non fraction amount and returned.\n     * @param _basset           Address of bAsset.\n     * @param _massetQuantity   Amount of mAssets to check.\n     * @return Calculated amount of bAssets and Adjusted amount of mAssets.\n     */\n    function convertMassetToBassetQuantity(\n        address _basset,\n        uint256 _massetQuantity) public view validBasset(_basset) returns(uint256 bassetQuantity, uint256 massetQuantity) {\n\n        int256 factor = factorMap[_basset];\n        if(factor > 0) {\n            bassetQuantity = _massetQuantity.mul(uint256(factor));\n            return (bassetQuantity, _massetQuantity);\n        }\n        bassetQuantity = _massetQuantity.div(uint256(-factor));\n        massetQuantity = bassetQuantity.mul(uint256(-factor));\n        return (bassetQuantity, massetQuantity);\n    }\n\n    // Getters\n\n    /**\n     * @dev Calculates total mAsset balance.\n     * @return Calculated total balance.\n     */\n    function getTotalMassetBalance() public view returns (uint256 total) {\n        for(uint i=0; i<bassetsArray.length; i++) {\n            address basset = bassetsArray[i];\n            uint256 balance = IERC20(basset).balanceOf(masset);\n            (uint256 massetQuantity, ) = convertBassetToMassetQuantity(basset, balance);\n            total += massetQuantity;\n        }\n    }\n\n    function getBassetBalance(address _basset) public view returns (uint256) {\n        return IERC20(_basset).balanceOf(masset);\n    }\n\n    function getVersion() external view returns(string memory) {\n        return version;\n    }\n\n    function getBassets() public view returns(address[] memory) {\n        return bassetsArray;\n    }\n\n    function getFactor(address _basset) public view validBasset(_basset) returns(int256) {\n        return factorMap[_basset];\n    }\n\n    function getBridge(address _basset) public view validBasset(_basset) returns(address) {\n        return bridgeMap[_basset];\n    }\n\n    function getRange(address _basset) public view validBasset(_basset) returns(uint256 min, uint256 max) {\n        min = minMap[_basset];\n        max = maxMap[_basset];\n    }\n\n    function getPaused(address _basset) public view validBasset(_basset) returns(bool) {\n        return pausedMap[_basset];\n    }\n\n    // Admin methods\n\n    /**\n     * @dev Adds a new bAsset.\n     * @param _basset       Address of bAsset.\n     * @param _factor       Factor amount.\n     * @param _bridge       Address of bridge.\n     * @param _min          Minimum ratio in basket.\n     * @param _max          Maximum ratio in basket.\n     * @param _paused       Flag to determine if basset should be paused.\n     */\n    function addBasset(address _basset, int256 _factor, address _bridge, uint256 _min, uint256 _max, bool _paused) public onlyOwner {\n        require(_basset != address(0), \"invalid basset address\");\n        require(factorMap[_basset] == 0, \"basset already exists\");\n        require(_factor != 0, \"invalid factor\");\n\n        bassetsArray.push(_basset);\n\n        setFactor(_basset, _factor);\n        setRange(_basset, _min, _max);\n        setBridge(_basset, _bridge);\n        setPaused(_basset, _paused);\n\n        emit BassetAdded(_basset);\n    }\n\n    /**\n     * @dev Adds multiple bAssets.\n     * @notice All parameters must be arrays with proper order and equal length.\n     */\n    function addBassets(\n        address[] memory _bassets, int256[] memory _factors, address[] memory _bridges,\n        uint256[] memory _mins, uint256[] memory _maxs, bool[] memory _pausedFlags) public onlyOwner {\n\n        uint length = _bassets.length;\n        require(\n            _factors.length == length &&\n            _bridges.length == length &&\n            _mins.length == length &&\n            _maxs.length == length &&\n            _pausedFlags.length == length, \"invalid lengths\");\n\n        for(uint i=0; i<length; i++) {\n            addBasset(_bassets[i], _factors[i], _bridges[i], _mins[i], _maxs[i], _pausedFlags[i]);\n        }\n    }\n\n    function setRange(address _basset, uint256 _min, uint256 _max) public validBasset(_basset) onlyOwner {\n        require(_min <= MAX_VALUE, \"invalid minimum\");\n        require(_max <= MAX_VALUE, \"invalid maximum\");\n        require(_max >= _min, \"invalid range\");\n        minMap[_basset] = _min;\n        maxMap[_basset] = _max;\n\n        emit RangeChanged(_basset, _min, _max);\n    }\n\n    /**\n     * @dev Returns true if the number is power of ten.\n     * @param x     Number to be checked.\n     * @return      Is the number power of ten.\n     */\n    function isPowerOfTen(int256 x) public pure returns (bool result) {\n        uint256 number;\n\n        if (x < 0) number = uint256(-x);\n        else number = uint256(x);\n\n        while (number >= 10 && number % 10 == 0) {\n            number /= 10;\n        }\n\n        result = number == 1;\n    }\n\n    function setFactor(address _basset, int256 _factor) public onlyOwner {\n        require(_factor != 0, \"invalid factor\");\n        require(_factor == 1 || isPowerOfTen(_factor), \"factor must be power of 10\");\n        factorMap[_basset] = _factor;\n\n        emit FactorChanged(_basset, _factor);\n    }\n\n    function setBridge(address _basset, address _bridge) public validBasset(_basset) onlyOwner {\n        bridgeMap[_basset] = _bridge;\n\n        emit BridgeChanged(_basset, _bridge);\n    }\n\n    function setPaused(address _basset, bool _flag) public validBasset(_basset) onlyOwner {\n        pausedMap[_basset] = _flag;\n\n        emit PausedChanged(_basset, _flag);\n    }\n\n    /**\n     * @dev Removes bAsset\n     * @param _basset       Address of bAsset to remove.\n     */\n    function removeBasset(address _basset) public validBasset(_basset) onlyOwner {\n        require(getBassetBalance(_basset) == 0, \"balance not zero\");\n        factorMap[_basset] = 0;\n\n        uint256 index;\n        for(uint i = 0; i < bassetsArray.length - 1; i++) {\n            if (bassetsArray[i] == _basset) {\n                index = i;\n                break;\n            }\n        }\n\n        bassetsArray[index] = bassetsArray[bassetsArray.length - 1];\n        bassetsArray.pop();\n\n        emit BassetRemoved(_basset);\n    }\n}\n"
    },
    "contracts/vault/FeesVault.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport { InitializableOwnable } from \"../helpers/InitializableOwnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n/**\n * @title FeesVault\n * @dev Contract is used to store fees.\n */\ncontract FeesVault is InitializableOwnable {\n    using SafeERC20 for IERC20;\n\n    function initialize() external {\n        _initialize();\n    }\n\n    /**\n     * @dev Withdraw collected fees.\n     * @param _token            Address of token to withdraw.\n     * @param _amount           Amount to withdraw.\n     * @param _recipient        Recipient of withdrawn tokens.\n     */\n    function withdraw (address _token, uint256 _amount, address _recipient) public onlyOwner {\n        IERC20(_token).safeTransfer(_recipient, _amount);\n    }\n}\n"
    },
    "contracts/masset/FeesManager.sol": {
      "content": "pragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { InitializableOwnable } from \"../helpers/InitializableOwnable.sol\";\n\n/**\n * @title FeesManager\n * @dev Contract is responsible for fees calculations.\n */\ncontract FeesManager is InitializableOwnable {\n    using SafeMath for uint256;\n\n    // State\n\n    /**\n     * @dev Factor of fees.\n     * @notice a value of 10000 means that 223 equals 2.23% and 10000 equals 100%\n     */\n    uint256 constant public PRECISION = 10000;\n\n    uint256 private depositFee;\n    uint256 private depositBridgeFee;\n    uint256 private withdrawalFee;\n    uint256 private withdrawalBridgeFee;\n\n    // Events\n\n    /**\n     * @dev Emitted when deposit fee has changed.\n     * @param depositFee            Amount of the fee.\n     */\n    event DepositFeeChanged (uint256 depositFee);\n\n    /**\n     * @dev Emitted when deposit bridge fee has changed.\n     * @param depositBridgeFee      Amount of the fee.\n     */\n    event DepositBridgeFeeChanged (uint256 depositBridgeFee);\n\n    /**\n     * @dev Emitted when withdrawal fee has changed.\n     * @param withdrawalFee         Amount of the fee.\n     */\n    event WithdrawalFeeChanged (uint256 withdrawalFee);\n\n    /**\n     * @dev Emitted when withdrawal bridge fee has changed.\n     * @param withdrawalBridgeFee   Amount of the fee.\n     */\n    event WithdrawalBridgeFeeChanged (uint256 withdrawalBridgeFee);\n\n    // Initializer\n\n    /**\n     * @dev Contract initializer.\n     * @param _depositFee           Amount of deposit fee in promils.\n     * @param _depositBridgeFee     Amount of deposit through bridge fee in promils.\n     * @param _withdrawalFee        Amount of redeem fee in promils.\n     * @param _withdrawalBridgeFee  Amount of redeem through bridge fee in promils.\n    */\n    function initialize(\n        uint256 _depositFee,\n        uint256 _depositBridgeFee,\n        uint256 _withdrawalFee,\n        uint256 _withdrawalBridgeFee\n    ) external {\n        InitializableOwnable._initialize();\n\n        setDepositFee(_depositFee);\n        setDepositBridgeFee(_depositBridgeFee);\n        setWithdrawalFee(_withdrawalFee);\n        setWithdrawalBridgeFee(_withdrawalBridgeFee);\n    }\n\n    // Internal\n\n    /**\n     * @dev Calculate and return fee amount based on massetAmount and type of fee.\n     */\n    function _calculateFee(uint256 _massetAmount, uint256 _fee) internal pure returns(uint256) {\n        return _massetAmount.mul(_fee).div(PRECISION);\n    }\n\n    // Public\n\n    /**\n     * @dev Calculate and return deposit fee amount based on massetAmount.\n     * @param _massetAmount  Amount of masset to deposit.\n     * @return fee           Calculated fee amount.\n     */\n    function calculateDepositFee(uint256 _massetAmount) external view returns(uint256) {\n        return _calculateFee(_massetAmount, depositFee);\n    }\n\n    /**\n     * @dev Calculate and return fee for deposit through bridge.\n     * @param _massetAmount  Amount of masset to deposit.\n     * @return fee           Calculated fee amount.\n     */\n    function calculateDepositBridgeFee(uint256 _massetAmount) external view returns(uint256) {\n        return _calculateFee(_massetAmount, depositBridgeFee);\n    }\n\n    /**\n     * @dev Calculate and return redeem fee amount based on massetAmount.\n     * @param _massetAmount  Amount of masset.\n     * @return fee           Calculated fee amount.\n     */\n    function calculateRedeemFee(uint256 _massetAmount) external view returns(uint256) {\n        return _calculateFee(_massetAmount, withdrawalFee);\n    }\n\n    /**\n     * @dev Calculate and return fee for redeem through bridge.\n     * @param _massetAmount  Amount of masset.\n     * @return fee           Calculated fee amount.\n     */\n    function calculateRedeemBridgeFee(uint256 _massetAmount) external view returns(uint256) {\n        return _calculateFee(_massetAmount, withdrawalBridgeFee);\n    }\n\n    // Getters\n\n    function getDepositFee () external view returns(uint256) {\n        return depositFee;\n    }\n\n    function getDepositBridgeFee () external view returns(uint256) {\n        return depositBridgeFee;\n    }\n\n    function getWithdrawalFee () external view returns(uint256) {\n        return withdrawalFee;\n    }\n\n    function getWithdrawalBridgeFee () external view returns(uint256) {\n        return withdrawalBridgeFee;\n    }\n\n    // Governance methods\n\n    function setDepositFee (uint256 _amount) public onlyOwner {\n        require(_amount <= PRECISION, \"invalid fee amount\");\n\n        depositFee = _amount;\n        emit DepositFeeChanged(_amount);\n    }\n\n    function setDepositBridgeFee (uint256 _amount) public onlyOwner {\n        require(_amount <= PRECISION, \"invalid fee amount\");\n\n        depositBridgeFee = _amount;\n        emit DepositBridgeFeeChanged(_amount);\n    }\n\n    function setWithdrawalFee (uint256 _amount) public onlyOwner {\n        require(_amount <= PRECISION, \"invalid fee amount\");\n\n        withdrawalFee = _amount;\n        emit WithdrawalFeeChanged(_amount);\n    }\n\n    function setWithdrawalBridgeFee (uint256 _amount) public onlyOwner {\n        require(_amount <= PRECISION, \"invalid fee amount\");\n\n        withdrawalBridgeFee = _amount;\n        emit WithdrawalBridgeFeeChanged(_amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following \n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    },
    "contracts/mocks/masset/MockBridge.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { MassetV3 } from \"../../masset/MassetV3.sol\";\n\ncontract MockBridge {\n    function receiveTokensAt(\n        address tokenToUse,\n        uint256 amount,\n        address receiver,\n        bytes calldata extraData\n    ) external returns(bool) {\n        require(IERC20(tokenToUse).transferFrom(msg.sender, address(this), amount), \"transfer failed\");\n\n        return true;\n    }\n\n    // It is used to test the case, when bridge is calling the onTokensMinted method on MassetV3\n    function callOnTokensMinted(\n        address masset,\n        uint256 _orderAmount,\n        address _tokenAddress,\n        address _userData\n    ) external {\n        MassetV3(masset).onTokensMinted(_orderAmount, _tokenAddress, abi.encode(_userData));\n    }\n\n    // It is used to test the case, when bridge is calling the redeemByBridge method on Masset\n    function callRedeemByBridge(\n        address masset,\n        address _basset,\n        uint256 _massetQuantity,\n        address _recipient\n    ) external returns (uint256 massetRedeemed) {\n        return MassetV3(masset).redeemByBridge(_basset, _massetQuantity, _recipient);\n    }\n}\n"
    },
    "contracts/mocks/masset/MockBasketManager.sol": {
      "content": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport { BasketManagerV3 } from \"../../masset/BasketManagerV3.sol\";\n\ncontract MockBasketManager is BasketManagerV3 {\n}\n"
    },
    "contracts/mocks/helpers/InitializableOwnableWrapper.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport { InitializableOwnable } from \"../../helpers/InitializableOwnable.sol\";\n\ncontract InitializableOwnableWrapper is InitializableOwnable {\n    function initialize() public {\n        _initialize();\n    }\n}\n"
    },
    "contracts/fish/governance/FeeSharingProxy.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"./Staking/SafeMath96.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./IFeeSharingProxy.sol\";\nimport \"./Staking/IStaking.sol\";\n\n/**\n * @title The FeeSharingProxy contract.\n * @notice Staking is not only granting voting rights, but also access to fee\n * sharing according to the own voting power in relation to the total. Whenever\n * somebody decides to collect the fees from the protocol, they get transferred\n * to a proxy contract which invests the funds in the lending pool and keeps\n * the pool tokens.\n *\n * The fee sharing proxy will be set as feesController of the protocol contract.\n * This allows the fee sharing proxy to withdraw the fees. The fee sharing\n * proxy holds the pool tokens and keeps track of which user owns how many\n * tokens. In order to know how many tokens a user owns, the fee sharing proxy\n * needs to know the userâ€™s weighted stake in relation to the total weighted\n * stake (aka total voting power).\n *\n * Because both values are subject to change, they may be different on each fee\n * withdrawal. To be able to calculate a userâ€™s share of tokens when he wants\n * to withdraw, we need checkpoints.\n *\n * This contract is intended to be set as the protocol fee collector.\n * Anybody can invoke the withdrawFees function which uses\n * protocol.withdrawFees to obtain available fees from operations on a\n * certain token. These fees are deposited in the corresponding loanPool.\n * Also, the staking contract sends slashed tokens to this contract. When a\n * user calls the withdraw function, the contract transfers the fee sharing\n * rewards in proportion to the userâ€™s weighted stake since the last withdrawal.\n *\n * The protocol is collecting fees in all sorts of currencies and then automatically\n * supplies them to the respective lending pools. Therefore, all fees are\n * generating interest for the SOV holders. If one of them withdraws fees, it will\n * get pool tokens. It is planned to add the option to convert anything to rBTC\n * before withdrawing, but not yet implemented.\n * */\ncontract FeeSharingProxy is SafeMath96, IFeeSharingProxy {\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for IERC20;\n\n\t/* Storage */\n\n\t/// @dev TODO FEE_WITHDRAWAL_INTERVAL, MAX_CHECKPOINTS\n\tuint256 constant FEE_WITHDRAWAL_INTERVAL = 86400;\n\n\tuint32 constant MAX_CHECKPOINTS = 100;\n\n\tIProtocol public protocol;\n\tIStaking public staking;\n\n\t/// @notice Checkpoints by index per pool token address\n\tmapping(address => mapping(uint256 => Checkpoint)) public tokenCheckpoints;\n\n\t/// @notice The number of checkpoints for each pool token address.\n\tmapping(address => uint32) public numTokenCheckpoints;\n\n\t/// @notice\n\t/// user => token => processed checkpoint\n\tmapping(address => mapping(address => uint32)) public processedCheckpoints;\n\n\t/// @notice Last time fees were withdrawn per pool token address:\n\t/// token => time\n\tmapping(address => uint256) public lastFeeWithdrawalTime;\n\n\t/// @notice Amount of tokens that were transferred, but not saved in checkpoints.\n\t/// token => amount\n\tmapping(address => uint96) public unprocessedAmount;\n\n\tstruct Checkpoint {\n\t\tuint32 blockNumber;\n\t\tuint32 timestamp;\n\t\tuint96 totalWeightedStake;\n\t\tuint96 numTokens;\n\t}\n\n\t/* Events */\n\n\t/// @notice An event emitted when fee get withdrawn.\n\tevent FeeWithdrawn(address indexed sender, address indexed token, uint256 amount);\n\n\t/// @notice An event emitted when tokens transferred.\n\tevent TokensTransferred(address indexed sender, address indexed token, uint256 amount);\n\n\t/// @notice An event emitted when checkpoint added.\n\tevent CheckpointAdded(address indexed sender, address indexed token, uint256 amount);\n\n\t/// @notice An event emitted when user fee get withdrawn.\n\tevent UserFeeWithdrawn(address indexed sender, address indexed receiver, address indexed token, uint256 amount);\n\n\t/* Functions */\n\n\tconstructor(IProtocol _protocol, IStaking _staking) public {\n\t\tprotocol = _protocol;\n\t\tstaking = _staking;\n\t}\n\n\t/**\n\t * @notice Withdraw fees for the given token:\n\t * lendingFee + tradingFee + borrowingFee\n\t * @param _token Address of the token\n\t * */\n\tfunction withdrawFees(address _token) public {\n\t\trequire(_token != address(0), \"FeeSharingProxy::withdrawFees: invalid address\");\n\n\t\taddress loanPoolToken = protocol.underlyingToLoanPool(_token);\n\t\trequire(loanPoolToken != address(0), \"FeeSharingProxy::withdrawFees: loan token not found\");\n\n\t\tuint256 amount = protocol.withdrawFees(_token, address(this));\n\t\trequire(amount > 0, \"FeeSharingProxy::withdrawFees: no tokens to withdraw\");\n\n\t\t/// @dev TODO can be also used - function addLiquidity(IERC20Token _reserveToken, uint256 _amount, uint256 _minReturn)\n\t\tIERC20(_token).approve(loanPoolToken, amount);\n\t\tuint256 poolTokenAmount = ILoanToken(loanPoolToken).mint(address(this), amount);\n\n\t\t/// @notice Update unprocessed amount of tokens\n\t\tuint96 amount96 = safe96(poolTokenAmount, \"FeeSharingProxy::withdrawFees: pool token amount exceeds 96 bits\");\n\t\tunprocessedAmount[loanPoolToken] = add96(\n\t\t\tunprocessedAmount[loanPoolToken],\n\t\t\tamount96,\n\t\t\t\"FeeSharingProxy::withdrawFees: unprocessedAmount exceeds 96 bits\"\n\t\t);\n\n\t\t_addCheckpoint(loanPoolToken);\n\n\t\temit FeeWithdrawn(msg.sender, loanPoolToken, poolTokenAmount);\n\t}\n\n\t/**\n\t * @notice Transfer tokens to this contract.\n\t * @dev We just update amount of tokens here and write checkpoint in a separate methods\n\t * in order to prevent adding checkpoints too often.\n\t * @param _token Address of the token.\n\t * @param _amount Amount to be transferred.\n\t * */\n\tfunction transferTokens(address _token, uint96 _amount) public {\n\t\trequire(_token != address(0), \"FeeSharingProxy::transferTokens: invalid address\");\n\t\trequire(_amount > 0, \"FeeSharingProxy::transferTokens: invalid amount\");\n\n\t\t/// @notice Transfer tokens from msg.sender\n\t\tbool success = IERC20(_token).transferFrom(address(msg.sender), address(this), _amount);\n\t\trequire(success, \"Staking::transferTokens: token transfer failed\");\n\n\t\t/// @notice Update unprocessed amount of tokens.\n\t\tunprocessedAmount[_token] = add96(unprocessedAmount[_token], _amount, \"FeeSharingProxy::transferTokens: amount exceeds 96 bits\");\n\n\t\t_addCheckpoint(_token);\n\n\t\temit TokensTransferred(msg.sender, _token, _amount);\n\t}\n\n\t/**\n\t * @notice Add checkpoint with accumulated amount by function invocation.\n\t * @param _token Address of the token.\n\t * */\n\tfunction _addCheckpoint(address _token) internal {\n\t\tif (block.timestamp - lastFeeWithdrawalTime[_token] >= FEE_WITHDRAWAL_INTERVAL) {\n\t\t\tlastFeeWithdrawalTime[_token] = block.timestamp;\n\t\t\tuint96 amount = unprocessedAmount[_token];\n\n\t\t\t/// @notice Reset unprocessed amount of tokens to zero.\n\t\t\tunprocessedAmount[_token] = 0;\n\n\t\t\t/// @notice Write a regular checkpoint.\n\t\t\t_writeTokenCheckpoint(_token, amount);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Withdraw accumulated fee to the message sender.\n\t *\n\t * The Sovryn protocol collects fees on every trade/swap and loan.\n\t * These fees will be distributed to SOV stakers based on their voting\n\t * power as a percentage of total voting power. Therefore, staking more\n\t * SOV and/or staking for longer will increase your share of the fees\n\t * generated, meaning you will earn more from staking.\n\t *\n\t * @param _loanPoolToken Address of the pool token.\n\t * @param _maxCheckpoints Maximum number of checkpoints to be processed.\n\t * @param _receiver The receiver of tokens or msg.sender\n\t * */\n\tfunction withdraw(\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints,\n\t\taddress _receiver\n\t) public {\n\t\t/// @dev Prevents processing all checkpoints because of block gas limit.\n\t\trequire(_maxCheckpoints > 0, \"FeeSharingProxy::withdraw: _maxCheckpoints should be positive\");\n\n\t\taddress user = msg.sender;\n\t\tif (_receiver == address(0)) {\n\t\t\t_receiver = msg.sender;\n\t\t}\n\n\t\tuint256 amount;\n\t\tuint32 end;\n\t\t(amount, end) = _getAccumulatedFees(user, _loanPoolToken, _maxCheckpoints);\n\n\t\tprocessedCheckpoints[user][_loanPoolToken] = end;\n\n\t\trequire(IERC20(_loanPoolToken).transfer(user, amount), \"FeeSharingProxy::withdraw: withdrawal failed\");\n\n\t\temit UserFeeWithdrawn(msg.sender, _receiver, _loanPoolToken, amount);\n\t}\n\n\t/**\n\t * @notice Get the accumulated loan pool fee of the message sender.\n\t * @param _user The address of the user or contract.\n\t * @param _loanPoolToken Address of the pool token.\n\t * @return The accumulated fee for the message sender.\n\t * */\n\tfunction getAccumulatedFees(address _user, address _loanPoolToken) public view returns (uint256) {\n\t\tuint256 amount;\n\t\t(amount, ) = _getAccumulatedFees(_user, _loanPoolToken, 0);\n\t\treturn amount;\n\t}\n\n\t/**\n\t * @notice Whenever fees are withdrawn, the staking contract needs to\n\t * checkpoint the block number, the number of pool tokens and the\n\t * total voting power at that time (read from the staking contract).\n\t * While the total voting power would not necessarily need to be\n\t * checkpointed, it makes sense to save gas cost on withdrawal.\n\t *\n\t * When the user wants to withdraw its share of tokens, we need\n\t * to iterate over all of the checkpoints since the users last\n\t * withdrawal (note: remember last withdrawal block), query the\n\t * userâ€™s balance at the checkpoint blocks from the staking contract,\n\t * compute his share of the checkpointed tokens and add them up.\n\t * The maximum number of checkpoints to process at once should be limited.\n\t *\n\t * @param _user Address of the user's account.\n\t * @param _loanPoolToken Loan pool token address.\n\t * @param _maxCheckpoints Checkpoint index incremental.\n\t * */\n\tfunction _getAccumulatedFees(\n\t\taddress _user,\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints\n\t) internal view returns (uint256, uint32) {\n\t\tuint32 start = processedCheckpoints[_user][_loanPoolToken];\n\t\tuint32 end;\n\t\t/// @dev Additional bool param can't be used because of stack too deep error.\n\t\tif (_maxCheckpoints > 0) {\n\t\t\t/// @dev withdraw -> _getAccumulatedFees\n\t\t\trequire(start < numTokenCheckpoints[_loanPoolToken], \"FeeSharingProxy::withdrawFees: no tokens for a withdrawal\");\n\t\t\tend = _getEndOfRange(start, _loanPoolToken, _maxCheckpoints);\n\t\t} else {\n\t\t\t/// @dev getAccumulatedFees -> _getAccumulatedFees\n\t\t\t/// Don't throw error for getter invocation outside of transaction.\n\t\t\tif (start >= numTokenCheckpoints[_loanPoolToken]) {\n\t\t\t\treturn (0, numTokenCheckpoints[_loanPoolToken]);\n\t\t\t}\n\t\t\tend = numTokenCheckpoints[_loanPoolToken];\n\t\t}\n\n\t\tuint256 amount = 0;\n\t\tuint256 cachedLockDate = 0;\n\t\tuint96 cachedWeightedStake = 0;\n\t\tfor (uint32 i = start; i < end; i++) {\n\t\t\tCheckpoint storage checkpoint = tokenCheckpoints[_loanPoolToken][i];\n\t\t\tuint256 lockDate = staking.timestampToLockDate(checkpoint.timestamp);\n\t\t\tuint96 weightedStake;\n\t\t\tif (lockDate == cachedLockDate) {\n\t\t\t\tweightedStake = cachedWeightedStake;\n\t\t\t} else {\n\t\t\t\t/// @dev We need to use \"checkpoint.blockNumber - 1\" here to calculate weighted stake\n\t\t\t\t/// For the same block like we did for total voting power in _writeTokenCheckpoint\n\t\t\t\tweightedStake = staking.getPriorWeightedStake(_user, checkpoint.blockNumber - 1, checkpoint.timestamp);\n\t\t\t\tcachedWeightedStake = weightedStake;\n\t\t\t\tcachedLockDate = lockDate;\n\t\t\t}\n\t\t\tuint256 share = uint256(checkpoint.numTokens).mul(weightedStake).div(uint256(checkpoint.totalWeightedStake));\n\t\t\tamount = amount.add(share);\n\t\t}\n\t\treturn (amount, end);\n\t}\n\n\t/**\n\t * @notice Withdrawal should only be possible for blocks which were already\n\t * mined. If the fees are withdrawn in the same block as the user withdrawal\n\t * they are not considered by the withdrawing logic (to avoid inconsistencies).\n\t *\n\t * @param start Start of the range.\n\t * @param _loanPoolToken Loan pool token address.\n\t * @param _maxCheckpoints Checkpoint index incremental.\n\t * */\n\tfunction _getEndOfRange(\n\t\tuint32 start,\n\t\taddress _loanPoolToken,\n\t\tuint32 _maxCheckpoints\n\t) internal view returns (uint32) {\n\t\tuint32 nCheckpoints = numTokenCheckpoints[_loanPoolToken];\n\t\tuint32 end;\n\t\tif (_maxCheckpoints == 0) {\n\t\t\t/// @dev All checkpoints will be processed (only for getter outside of a transaction).\n\t\t\tend = nCheckpoints;\n\t\t} else {\n\t\t\tif (_maxCheckpoints > MAX_CHECKPOINTS) {\n\t\t\t\t_maxCheckpoints = MAX_CHECKPOINTS;\n\t\t\t}\n\t\t\tend = safe32(start + _maxCheckpoints, \"FeeSharingProxy::withdraw: checkpoint index exceeds 32 bits\");\n\t\t\tif (end > nCheckpoints) {\n\t\t\t\tend = nCheckpoints;\n\t\t\t}\n\t\t}\n\n\t\t/// @dev Withdrawal should only be possible for blocks which were already mined.\n\t\tuint32 lastBlockNumber = tokenCheckpoints[_loanPoolToken][end - 1].blockNumber;\n\t\tif (block.number == lastBlockNumber) {\n\t\t\tend--;\n\t\t}\n\t\treturn end;\n\t}\n\n\t/**\n\t * @notice Write a regular checkpoint w/ the foolowing data:\n\t * block number, block timestamp, total weighted stake and num of tokens.\n\t * @param _token The pool token address.\n\t * @param _numTokens The amount of pool tokens.\n\t * */\n\tfunction _writeTokenCheckpoint(address _token, uint96 _numTokens) internal {\n\t\tuint32 blockNumber = safe32(block.number, \"FeeSharingProxy::_writeCheckpoint: block number exceeds 32 bits\");\n\t\tuint32 blockTimestamp = safe32(block.timestamp, \"FeeSharingProxy::_writeCheckpoint: block timestamp exceeds 32 bits\");\n\t\tuint32 nCheckpoints = numTokenCheckpoints[_token];\n\n\t\tuint96 totalWeightedStake = staking.getPriorTotalVotingPower(blockNumber - 1, block.timestamp);\n\t\tif (nCheckpoints > 0 && tokenCheckpoints[_token][nCheckpoints - 1].blockNumber == blockNumber) {\n\t\t\ttokenCheckpoints[_token][nCheckpoints - 1].totalWeightedStake = totalWeightedStake;\n\t\t\ttokenCheckpoints[_token][nCheckpoints - 1].numTokens = _numTokens;\n\t\t} else {\n\t\t\ttokenCheckpoints[_token][nCheckpoints] = Checkpoint(blockNumber, blockTimestamp, totalWeightedStake, _numTokens);\n\t\t\tnumTokenCheckpoints[_token] = nCheckpoints + 1;\n\t\t}\n\t\temit CheckpointAdded(msg.sender, _token, _numTokens);\n\t}\n}\n\n/* Interfaces */\n\ninterface IProtocol {\n\tfunction withdrawFees(address token, address receiver) external returns (uint256);\n\n\tfunction underlyingToLoanPool(address token) external returns (address);\n}\n\ninterface ILoanToken {\n\tfunction mint(address receiver, uint256 depositAmount) external returns (uint256 mintAmount);\n}\n"
    },
    "contracts/fish/governance/Vesting/SVR.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"../Staking/SafeMath96.sol\";\nimport \"../Staking/IStaking.sol\";\nimport \"../../token/IApproveAndCall.sol\";\nimport \"../ApprovalReceiver.sol\";\n\n// TODO should be set as protocolTokenAddress (ProtocolSettings.setProtocolTokenAddress)\n// TODO PriceFeeds._protocolTokenAddress ?\n\n/**\n * @title Sovryn Reward Token.\n * @notice The RSOV token (Sovryn Vesting Reward Token) goal is to allow users to get\n * rewards through the generation of protocol fees. The mint function accepts\n * SOV tokens and mints the same amount of RSOV tokens. When burning RSOV\n * tokens, the user gets 1/14th of the tokens sent back to him and the rest\n * get staked in the userâ€™s behalf with a schedule of 4 weeks cliff and period\n * 1 year duration.\n * */\ncontract SVR is ERC20, ERC20Detailed, Ownable, SafeMath96, ApprovalReceiver {\n\t/* Storage */\n\n\tstring constant NAME = \"Sovryn Vesting Reward Token\";\n\tstring constant SYMBOL = \"SVR\";\n\tuint8 constant DECIMALS = 18;\n\n\t/// @notice Constants used for computing the vesting dates.\n\tuint256 constant FOUR_WEEKS = 4 weeks;\n\tuint256 constant YEAR = 52 weeks;\n\t/// @notice Amount of tokens divided by this constant will be transferred.\n\tuint96 constant DIRECT_TRANSFER_PART = 14;\n\n\t/// @notice The SOV token contract.\n\tIERC20 public SOV;\n\t/// @notice The staking contract.\n\tIStaking public staking;\n\n\t/* Events */\n\n\tevent Mint(address indexed sender, uint256 amount);\n\tevent Burn(address indexed sender, uint256 amount);\n\n\t/* Functions */\n\n\t/**\n\t * @notice Create reward token RSOV.\n\t * @param _SOV The SOV token address.\n\t * @param _staking The staking contract address.\n\t * */\n\tconstructor(address _SOV, address _staking) public ERC20Detailed(NAME, SYMBOL, DECIMALS) {\n\t\trequire(_SOV != address(0), \"SVR::SOV address invalid\");\n\t\trequire(_staking != address(0), \"SVR::staking address invalid\");\n\n\t\tSOV = IERC20(_SOV);\n\t\tstaking = IStaking(_staking);\n\t}\n\n\t/**\n\t * @notice Hold SOV tokens and mint the respective amount of SVR tokens.\n\t * @param _amount The amount of tokens to be mint.\n\t * */\n\tfunction mint(uint96 _amount) public {\n\t\t_mintTo(msg.sender, _amount);\n\t}\n\n\t/**\n\t * @notice Hold SOV tokens and mint the respective amount of SVR tokens.\n\t * @dev This function will be invoked from receiveApproval.\n\t * @dev SOV.approveAndCall -> this.receiveApproval -> this.mintWithApproval\n\t * @param _sender The sender of SOV.approveAndCall\n\t * @param _amount The amount of tokens to be mint.\n\t * */\n\tfunction mintWithApproval(address _sender, uint96 _amount) public onlyThisContract {\n\t\t_mintTo(_sender, _amount);\n\t}\n\n\t/**\n\t * @notice The actual minting process, holding SOV and minting RSOV tokens.\n\t * @param _sender The recipient of the minted tokens.\n\t * @param _amount The amount of tokens to be minted.\n\t * */\n\tfunction _mintTo(address _sender, uint96 _amount) internal {\n\t\trequire(_amount > 0, \"SVR::mint: amount invalid\");\n\n\t\t/// @notice Holds SOV tokens.\n\t\tbool success = SOV.transferFrom(_sender, address(this), _amount);\n\t\trequire(success);\n\n\t\t/// @notice Mints SVR tokens.\n\t\t/// @dev uses openzeppelin/ERC20.sol internal _mint function\n\t\t_mint(_sender, _amount);\n\n\t\temit Mint(_sender, _amount);\n\t}\n\n\t/**\n\t * @notice burns SVR tokens and stakes the respective amount SOV tokens in the user's behalf\n\t * @param _amount the amount of tokens to be burnt\n\t */\n\tfunction burn(uint96 _amount) public {\n\t\trequire(_amount > 0, \"SVR:: burn: amount invalid\");\n\n\t\t/// @notice Burns RSOV tokens.\n\t\t_burn(msg.sender, _amount);\n\n\t\t/// @notice Transfer 1/14 of amount directly to the user.\n\t\t/// If amount is too small it won't be transferred.\n\t\tuint96 transferAmount = _amount / DIRECT_TRANSFER_PART;\n\t\tif (transferAmount > 0) {\n\t\t\tSOV.transfer(msg.sender, transferAmount);\n\t\t\t_amount -= transferAmount;\n\t\t}\n\n\t\t/// @notice Stakes SOV tokens in the user's behalf.\n\t\tSOV.approve(address(staking), _amount);\n\n\t\tstaking.stakesBySchedule(_amount, FOUR_WEEKS, YEAR, FOUR_WEEKS, msg.sender, msg.sender);\n\n\t\temit Burn(msg.sender, _amount);\n\t}\n\n\t/**\n\t * @notice Override default ApprovalReceiver._getToken function to\n\t * register SOV token on this contract.\n\t * @return The address of SOV token.\n\t * */\n\tfunction _getToken() internal view returns (address) {\n\t\treturn address(SOV);\n\t}\n\n\t/**\n\t * @notice Override default ApprovalReceiver._getSelectors function to\n\t * register mintWithApproval selector on this contract.\n\t * @return The array of registered selectors on this contract.\n\t * */\n\tfunction _getSelectors() internal view returns (bytes4[] memory) {\n\t\tbytes4[] memory selectors = new bytes4[](1);\n\t\tselectors[0] = this.mintWithApproval.selector;\n\t\treturn selectors;\n\t}\n}\n"
    },
    "contracts/fish/token/Fish.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"./IApproveAndCall.sol\";\n\n/**\n * @title Fish Token: FSH is an ERC-20 token contract for BabelFish governance.\n *\n * @notice This contract accounts for all holders' balances.\n *\n * @dev This contract represents a token with dynamic supply.\n *   The owner of the token contract can mint/burn tokens to/from any account\n *   based upon previous governance voting and approval.\n * */\ncontract Fish is ERC20, ERC20Detailed, Ownable {\n\tstring constant NAME = \"Fish Token\";\n\tstring constant SYMBOL = \"FSH\";\n\tuint8 constant DECIMALS = 18;\n\n\t/**\n\t * @notice Constructor called on deployment, initiates the contract.\n\t * @dev On deployment, some amount of tokens will be minted for the owner.\n\t * @param _initialAmount The amount of tokens to be minted on contract creation.\n\t * */\n\tconstructor(uint256 _initialAmount) public ERC20Detailed(NAME, SYMBOL, DECIMALS) {\n\t\tif (_initialAmount != 0) {\n\t\t\t_mint(msg.sender, _initialAmount);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Creates new tokens and sends them to the recipient.\n\t * @dev Don't create more than 2^96/10 tokens before updating the governance first.\n\t * @param _account The recipient address to get the minted tokens.\n\t * @param _amount The amount of tokens to be minted.\n\t * */\n\tfunction mint(address _account, uint256 _amount) public onlyOwner {\n\t\t_mint(_account, _amount);\n\t}\n\n\t/**\n\t * @notice Approves and then calls the receiving contract.\n\t * Useful to encapsulate sending tokens to a contract in one call.\n\t * Solidity has no native way to send tokens to contracts.\n\t * ERC-20 tokens require approval to be spent by third parties, such as a contract in this case.\n\t * @param _spender The contract address to spend the tokens.\n\t * @param _amount The amount of tokens to be sent.\n\t * @param _data Parameters for the contract call, such as endpoint signature.\n\t * */\n\tfunction approveAndCall(\n\t\taddress _spender,\n\t\tuint256 _amount,\n\t\tbytes memory _data\n\t) public {\n\t\tapprove(_spender, _amount);\n\t\tIApproveAndCall(_spender).receiveApproval(msg.sender, _amount, address(this), _data);\n\t}\n}\n"
    },
    "contracts/fish/governance/mocks/GovernorAlphaMock.sol": {
      "content": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"../Staking/SafeMath96.sol\";\nimport \"../Timelock.sol\";\nimport \"../Staking/Staking.sol\";\nimport \"../../rsk/RSKAddrValidator.sol\";\nimport { StakingInterface, TimelockInterface } from \"../GovernorAlpha.sol\";\n\n/**\n * @dev This contract is a copy of `GovernorAlpha.sol` with changed value of votingPeriod for tests purposes\n * */\ncontract GovernorAlphaMock is SafeMath96 {\n\t/* Storage */\n\n\t/// @notice The name of this contract.\n\tstring public constant NAME = \"Sovryn Governor Alpha\";\n\n\t/// @notice The maximum number of actions that can be included in a proposal.\n\tfunction proposalMaxOperations() public pure returns (uint256) {\n\t\treturn 10;\n\t} // 10 actions\n\n\t/// @notice The delay before voting on a proposal may take place, once proposed.\n\tfunction votingDelay() public pure returns (uint256) {\n\t\treturn 1;\n\t} // 1 block\n\n\t/// @notice The duration of voting on a proposal, in blocks.\n\tfunction votingPeriod() public pure returns (uint256) {\n\t\treturn 70;\n\t} // ~1 day in blocks (assuming 30s blocks)\n\n\t/// @notice The address of the Sovryn Protocol Timelock.\n\tITimelock public timelock;\n\n\t/// @notice The address of the Sovryn staking contract.\n\tIStaking public staking;\n\n\t/// @notice The address of the Governor Guardian.\n\taddress public guardian;\n\n\t/// @notice The total number of proposals.\n\tuint256 public proposalCount;\n\n\t/// @notice Percentage of current total voting power require to vote.\n\tuint96 public quorumPercentageVotes;\n\n\t// @notice Majority percentage.\n\tuint96 public majorityPercentageVotes;\n\n\tstruct Proposal {\n\t\t/// @notice Unique id for looking up a proposal.\n\t\tuint256 id;\n\t\t/// @notice The block at which voting begins: holders must delegate their votes prior to this block.\n\t\tuint32 startBlock;\n\t\t/// @notice The block at which voting ends: votes must be cast prior to this block.\n\t\tuint32 endBlock;\n\t\t/// @notice Current number of votes in favor of this proposal.\n\t\tuint96 forVotes;\n\t\t/// @notice Current number of votes in opposition to this proposal.\n\t\tuint96 againstVotes;\n\t\t///@notice the quorum required for this proposal.\n\t\tuint96 quorum;\n\t\t///@notice the majority percentage required for this proposal.\n\t\tuint96 majorityPercentage;\n\t\t/// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds.\n\t\tuint64 eta;\n\t\t/// @notice the start time is required for the staking contract.\n\t\tuint64 startTime;\n\t\t/// @notice Flag marking whether the proposal has been canceled.\n\t\tbool canceled;\n\t\t/// @notice Flag marking whether the proposal has been executed.\n\t\tbool executed;\n\t\t/// @notice Creator of the proposal.\n\t\taddress proposer;\n\t\t/// @notice the ordered list of target addresses for calls to be made.\n\t\taddress[] targets;\n\t\t/// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made.\n\t\tuint256[] values;\n\t\t/// @notice The ordered list of function signatures to be called.\n\t\tstring[] signatures;\n\t\t/// @notice The ordered list of calldata to be passed to each call.\n\t\tbytes[] calldatas;\n\t\t/// @notice Receipts of ballots for the entire set of voters.\n\t\tmapping(address => Receipt) receipts;\n\t}\n\n\t/// @notice Ballot receipt record for a voter\n\tstruct Receipt {\n\t\t/// @notice Whether or not a vote has been cast.\n\t\tbool hasVoted;\n\t\t/// @notice Whether or not the voter supports the proposal.\n\t\tbool support;\n\t\t/// @notice The number of votes the voter had, which were cast.\n\t\tuint96 votes;\n\t}\n\n\t/// @notice Possible states that a proposal may be in.\n\tenum ProposalState { Pending, Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed }\n\n\t/// @notice The official record of all proposals ever proposed.\n\tmapping(uint256 => Proposal) public proposals;\n\n\t/// @notice The latest proposal for each proposer.\n\tmapping(address => uint256) public latestProposalIds;\n\n\t/// @notice The EIP-712 typehash for the contract's domain.\n\tbytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n\t/// @notice The EIP-712 typehash for the ballot struct used by the contract.\n\tbytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n\t/* Events */\n\n\t/// @notice An event emitted when a new proposal is created.\n\tevent ProposalCreated(\n\t\tuint256 id,\n\t\taddress proposer,\n\t\taddress[] targets,\n\t\tuint256[] values,\n\t\tstring[] signatures,\n\t\tbytes[] calldatas,\n\t\tuint256 startBlock,\n\t\tuint256 endBlock,\n\t\tstring description\n\t);\n\n\t/// @notice An event emitted when a vote has been cast on a proposal.\n\tevent VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n\n\t/// @notice An event emitted when a proposal has been canceled.\n\tevent ProposalCanceled(uint256 id);\n\n\t/// @notice An event emitted when a proposal has been queued in the Timelock.\n\tevent ProposalQueued(uint256 id, uint256 eta);\n\n\t/// @notice An event emitted when a proposal has been executed in the Timelock.\n\tevent ProposalExecuted(uint256 id);\n\n\t/* Functions */\n\n\tconstructor(\n\t\taddress timelock_,\n\t\taddress staking_,\n\t\taddress guardian_,\n\t\tuint96 _quorumPercentageVotes,\n\t\tuint96 _majorityPercentageVotes\n\t) public {\n\t\ttimelock = ITimelock(timelock_);\n\t\tstaking = IStaking(staking_);\n\t\tguardian = guardian_;\n\t\tquorumPercentageVotes = _quorumPercentageVotes;\n\t\tmajorityPercentageVotes = _majorityPercentageVotes;\n\t}\n\n\t/// @notice The number of votes required in order for a voter to become a proposer.\n\tfunction proposalThreshold() public view returns (uint96) {\n\t\tuint96 totalVotingPower =\n\t\t\tstaking.getPriorTotalVotingPower(\n\t\t\t\tsafe32(block.number - 1, \"GovernorAlpha::proposalThreshold: block number overflow\"),\n\t\t\t\tblock.timestamp\n\t\t\t);\n\t\t// 1% of current total voting power.\n\t\treturn totalVotingPower / 100;\n\t}\n\n\t/// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed.\n\tfunction quorumVotes() public view returns (uint96) {\n\t\tuint96 totalVotingPower =\n\t\t\tstaking.getPriorTotalVotingPower(\n\t\t\t\tsafe32(block.number - 1, \"GovernorAlpha::quorumVotes: block number overflow\"),\n\t\t\t\tblock.timestamp\n\t\t\t);\n\t\t// 4% of current total voting power.\n\t\treturn mul96(quorumPercentageVotes, totalVotingPower, \"GovernorAlpha::quorumVotes:multiplication overflow\") / 100;\n\t}\n\n\t/**\n\t * @notice Create a new proposal.\n\t * @param targets Array of contract addresses to perform proposal execution.\n\t * @param values Array of rBTC amounts to send on proposal execution.\n\t * @param signatures Array of function signatures to call on proposal execution.\n\t * @param calldatas Array of payloads for the calls on proposal execution.\n\t * @param description Text describing the purpose of the proposal.\n\t * */\n\tfunction propose(\n\t\taddress[] memory targets,\n\t\tuint256[] memory values,\n\t\tstring[] memory signatures,\n\t\tbytes[] memory calldatas,\n\t\tstring memory description\n\t) public returns (uint256) {\n\t\t// note: passing this block's timestamp, but the number of the previous block.\n\t\t// todo: think if it would be better to pass block.timestamp - 30 (average block time)\n\t\t// (probably not because proposal starts in 1 block from now).\n\t\tuint96 threshold = proposalThreshold();\n\t\trequire(\n\t\t\tstaking.getPriorVotes(msg.sender, sub256(block.number, 1), block.timestamp) > threshold,\n\t\t\t\"GovernorAlpha::propose: proposer votes below proposal threshold\"\n\t\t);\n\t\trequire(\n\t\t\ttargets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,\n\t\t\t\"GovernorAlpha::propose: proposal function information arity mismatch\"\n\t\t);\n\t\trequire(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n\t\trequire(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n\t\tuint256 latestProposalId = latestProposalIds[msg.sender];\n\t\tif (latestProposalId != 0) {\n\t\t\tProposalState proposersLatestProposalState = state(latestProposalId);\n\t\t\trequire(\n\t\t\t\tproposersLatestProposalState != ProposalState.Active,\n\t\t\t\t\"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n\t\t\t);\n\t\t\trequire(\n\t\t\t\tproposersLatestProposalState != ProposalState.Pending,\n\t\t\t\t\"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\"\n\t\t\t);\n\t\t}\n\n\t\tuint256 startBlock = add256(block.number, votingDelay());\n\t\tuint256 endBlock = add256(startBlock, votingPeriod());\n\n\t\tproposalCount++;\n\n\t\t/// @dev quorum: proposalThreshold is 1% of total votes, we can save gas using this pre calculated value.\n\t\t/// @dev startTime: Required by the staking contract. not used by the governance contract itself.\n\t\tProposal memory newProposal =\n\t\t\tProposal({\n\t\t\t\tid: proposalCount,\n\t\t\t\tstartBlock: safe32(startBlock, \"GovernorAlpha::propose: start block number overflow\"),\n\t\t\t\tendBlock: safe32(endBlock, \"GovernorAlpha::propose: end block number overflow\"),\n\t\t\t\tforVotes: 0,\n\t\t\t\tagainstVotes: 0,\n\t\t\t\tquorum: mul96(quorumPercentageVotes, threshold, \"GovernorAlpha::propose: overflow on quorum computation\"),\n\t\t\t\tmajorityPercentage: mul96(\n\t\t\t\t\tmajorityPercentageVotes,\n\t\t\t\t\tthreshold,\n\t\t\t\t\t\"GovernorAlpha::propose: overflow on majorityPercentage computation\"\n\t\t\t\t),\n\t\t\t\teta: 0,\n\t\t\t\tstartTime: safe64(block.timestamp, \"GovernorAlpha::propose: startTime overflow\"),\n\t\t\t\tcanceled: false,\n\t\t\t\texecuted: false,\n\t\t\t\tproposer: msg.sender,\n\t\t\t\ttargets: targets,\n\t\t\t\tvalues: values,\n\t\t\t\tsignatures: signatures,\n\t\t\t\tcalldatas: calldatas\n\t\t\t});\n\n\t\tproposals[newProposal.id] = newProposal;\n\t\tlatestProposalIds[newProposal.proposer] = newProposal.id;\n\n\t\temit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n\t\treturn newProposal.id;\n\t}\n\n\t/**\n\t * @notice Enqueue a proposal and everyone of its calls.\n\t * @param proposalId Proposal index to access the list proposals[] from storage.\n\t * */\n\tfunction queue(uint256 proposalId) public {\n\t\trequire(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\n\t\tProposal storage proposal = proposals[proposalId];\n\t\tuint256 eta = add256(block.timestamp, timelock.delay());\n\n\t\tfor (uint256 i = 0; i < proposal.targets.length; i++) {\n\t\t\t_queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n\t\t}\n\t\tproposal.eta = safe64(eta, \"GovernorAlpha::queue: ETA overflow\");\n\t\temit ProposalQueued(proposalId, eta);\n\t}\n\n\t/**\n\t * @notice Tries to enqueue a proposal, verifying it has not been previously queued.\n\t * @param target Contract addresses to perform proposal execution.\n\t * @param value rBTC amount to send on proposal execution.\n\t * @param signature Function signature to call on proposal execution.\n\t * @param data Payload for the call on proposal execution.\n\t * @param eta Estimated Time of Accomplishment. The timestamp that the\n\t * proposal will be available for execution, set once the vote succeeds.\n\t * */\n\tfunction _queueOrRevert(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring memory signature,\n\t\tbytes memory data,\n\t\tuint256 eta\n\t) internal {\n\t\trequire(\n\t\t\t!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n\t\t\t\"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\"\n\t\t);\n\t\ttimelock.queueTransaction(target, value, signature, data, eta);\n\t}\n\n\t/**\n\t * @notice Execute a proposal by looping and performing everyone of its calls.\n\t * @param proposalId Proposal index to access the list proposals[] from storage.\n\t * */\n\tfunction execute(uint256 proposalId) public payable {\n\t\trequire(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n\t\tProposal storage proposal = proposals[proposalId];\n\t\tproposal.executed = true;\n\n\t\tfor (uint256 i = 0; i < proposal.targets.length; i++) {\n\t\t\ttimelock.executeTransaction.value(proposal.values[i])(\n\t\t\t\tproposal.targets[i],\n\t\t\t\tproposal.values[i],\n\t\t\t\tproposal.signatures[i],\n\t\t\t\tproposal.calldatas[i],\n\t\t\t\tproposal.eta\n\t\t\t);\n\t\t}\n\t\temit ProposalExecuted(proposalId);\n\t}\n\n\t/**\n\t * @notice Cancel a proposal by looping and cancelling everyone of its calls.\n\t * @param proposalId Proposal index to access the list proposals[] from storage.\n\t * */\n\tfunction cancel(uint256 proposalId) public {\n\t\tProposalState state = state(proposalId);\n\t\trequire(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n\n\t\tProposal storage proposal = proposals[proposalId];\n\t\t/// @notice Cancel only if sent by the guardian.\n\t\trequire(msg.sender == guardian, \"GovernorAlpha::cancel: sender isn't a guardian\");\n\n\t\tproposal.canceled = true;\n\n\t\tfor (uint256 i = 0; i < proposal.targets.length; i++) {\n\t\t\ttimelock.cancelTransaction(\n\t\t\t\tproposal.targets[i],\n\t\t\t\tproposal.values[i],\n\t\t\t\tproposal.signatures[i],\n\t\t\t\tproposal.calldatas[i],\n\t\t\t\tproposal.eta\n\t\t\t);\n\t\t}\n\n\t\temit ProposalCanceled(proposalId);\n\t}\n\n\t/**\n\t * @notice Get a proposal list of its calls.\n\t * @param proposalId Proposal index to access the list proposals[] from storage.\n\t * @return Arrays of the 4 call parameters: targets, values, signatures, calldatas.\n\t * */\n\tfunction getActions(uint256 proposalId)\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\taddress[] memory targets,\n\t\t\tuint256[] memory values,\n\t\t\tstring[] memory signatures,\n\t\t\tbytes[] memory calldatas\n\t\t)\n\t{\n\t\tProposal storage p = proposals[proposalId];\n\t\treturn (p.targets, p.values, p.signatures, p.calldatas);\n\t}\n\n\t/**\n\t * @notice Get a proposal receipt.\n\t * @param proposalId Proposal index to access the list proposals[] from storage.\n\t * @param voter A governance stakeholder with voting power.\n\t * @return The voter receipt of the proposal.\n\t * */\n\tfunction getReceipt(uint256 proposalId, address voter) public view returns (Receipt memory) {\n\t\treturn proposals[proposalId].receipts[voter];\n\t}\n\n\t/**\n\t * @notice Casts a vote by sender.\n\t * @param proposalId Proposal index to access the list proposals[] from storage.\n\t * @param support Vote value, yes or no.\n\t * */\n\tfunction castVote(uint256 proposalId, bool support) public {\n\t\treturn _castVote(msg.sender, proposalId, support);\n\t}\n\n\t/**\n\t * @notice Voting with EIP-712 Signatures.\n\t *\n\t * Voting power can be delegated to any address, and then can be used to\n\t * vote on proposals. A key benefit to users of by-signature functionality\n\t * is that they can create a signed vote transaction for free, and have a\n\t * trusted third-party spend rBTC(or ETH) on gas fees and write it to the\n\t * blockchain for them.\n\t *\n\t * The third party in this scenario, submitting the SOV-holderâ€™s signed\n\t * transaction holds a voting power that is for only a single proposal.\n\t * The signatory still holds the power to vote on their own behalf in\n\t * the proposal if the third party has not yet published the signed\n\t * transaction that was given to them.\n\t *\n\t * @dev The signature needs to be broken up into 3 parameters, known as\n\t * v, r and s:\n\t * const r = '0x' + sig.substring(2).substring(0, 64);\n\t * const s = '0x' + sig.substring(2).substring(64, 128);\n\t * const v = '0x' + sig.substring(2).substring(128, 130);\n\t *\n\t * @param proposalId Proposal index to access the list proposals[] from storage.\n\t * @param support Vote value, yes or no.\n\t * @param v The recovery byte of the signature.\n\t * @param r Half of the ECDSA signature pair.\n\t * @param s Half of the ECDSA signature pair.\n\t * */\n\tfunction castVoteBySig(\n\t\tuint256 proposalId,\n\t\tbool support,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public {\n\t\t/**\n\t\t * @dev The DOMAIN_SEPARATOR is a hash that uniquely identifies a\n\t\t * smart contract. It is built from a string denoting it as an\n\t\t * EIP712 Domain, the name of the token contract, the version,\n\t\t * the chainId in case it changes, and the address that the\n\t\t * contract is deployed at.\n\t\t * */\n\t\tbytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), getChainId(), address(this)));\n\n\t\t/// @dev GovernorAlpha uses BALLOT_TYPEHASH, while Staking uses DELEGATION_TYPEHASH\n\t\tbytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\t\taddress signatory = ecrecover(digest, v, r, s);\n\n\t\t/// @dev Verify address is not null and PK is not null either.\n\t\trequire(RSKAddrValidator.checkPKNotZero(signatory), \"GovernorAlpha::castVoteBySig: invalid signature\");\n\t\treturn _castVote(signatory, proposalId, support);\n\t}\n\n\t/**\n\t * @notice Cast a vote, adding it to the total counting.\n\t * @param voter A governance stakeholder with voting power that is casting the vote.\n\t * @param proposalId Proposal index to access the list proposals[] from storage.\n\t * @param support Vote value, yes or no.\n\t * */\n\tfunction _castVote(\n\t\taddress voter,\n\t\tuint256 proposalId,\n\t\tbool support\n\t) internal {\n\t\trequire(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n\t\tProposal storage proposal = proposals[proposalId];\n\t\tReceipt storage receipt = proposal.receipts[voter];\n\t\trequire(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n\t\tuint96 votes = staking.getPriorVotes(voter, proposal.startBlock, proposal.startTime);\n\n\t\tif (support) {\n\t\t\tproposal.forVotes = add96(proposal.forVotes, votes, \"GovernorAlpha::_castVote: vote overflow\");\n\t\t} else {\n\t\t\tproposal.againstVotes = add96(proposal.againstVotes, votes, \"GovernorAlpha::_castVote: vote overflow\");\n\t\t}\n\n\t\treceipt.hasVoted = true;\n\t\treceipt.support = support;\n\t\treceipt.votes = votes;\n\n\t\temit VoteCast(voter, proposalId, support, votes);\n\t}\n\n\t/// @dev Timelock wrapper w/ sender check.\n\tfunction __acceptAdmin() public {\n\t\trequire(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\n\t\ttimelock.acceptAdmin();\n\t}\n\n\t/// @notice Sets guardian address to zero.\n\tfunction __abdicate() public {\n\t\trequire(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n\t\tguardian = address(0);\n\t}\n\n\t/// @dev Timelock wrapper w/ sender check.\n\tfunction __queueSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\n\t\trequire(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n\t\ttimelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n\t}\n\n\t/// @dev Timelock wrapper w/ sender check.\n\tfunction __executeSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\n\t\trequire(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n\t\ttimelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n\t}\n\n\t/**\n\t * @notice Get a proposal state.\n\t * @param proposalId Proposal index to access the list proposals[] from storage.\n\t * @return The state of the proposal: Canceled, Pending, Active, Defeated,\n\t * Succeeded, Executed, Expired.\n\t * */\n\tfunction state(uint256 proposalId) public view returns (ProposalState) {\n\t\trequire(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n\t\tProposal storage proposal = proposals[proposalId];\n\n\t\tif (proposal.canceled) {\n\t\t\treturn ProposalState.Canceled;\n\t\t}\n\n\t\tif (block.number <= proposal.startBlock) {\n\t\t\treturn ProposalState.Pending;\n\t\t}\n\n\t\tif (block.number <= proposal.endBlock) {\n\t\t\treturn ProposalState.Active;\n\t\t}\n\n\t\tuint96 totalVotes = add96(proposal.forVotes, proposal.againstVotes, \"GovernorAlpha:: state: forVotes + againstVotes > uint96\");\n\t\tuint96 totalVotesMajorityPercentage = div96(totalVotes, 100, \"GovernorAlpha:: state: division error\");\n\t\ttotalVotesMajorityPercentage = mul96(\n\t\t\ttotalVotesMajorityPercentage,\n\t\t\tmajorityPercentageVotes,\n\t\t\t\"GovernorAlpha:: state: totalVotes * majorityPercentage > uint96\"\n\t\t);\n\t\tif (proposal.forVotes <= totalVotesMajorityPercentage || totalVotes < proposal.quorum) {\n\t\t\treturn ProposalState.Defeated;\n\t\t}\n\n\t\tif (proposal.eta == 0) {\n\t\t\treturn ProposalState.Succeeded;\n\t\t}\n\n\t\tif (proposal.executed) {\n\t\t\treturn ProposalState.Executed;\n\t\t}\n\n\t\tif (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n\t\t\treturn ProposalState.Expired;\n\t\t}\n\n\t\treturn ProposalState.Queued;\n\t}\n\n\t/// @dev TODO: use OpenZeppelin's SafeMath function instead.\n\tfunction add256(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, \"addition overflow\");\n\t\treturn c;\n\t}\n\n\t/// @dev TODO: use OpenZeppelin's SafeMath function instead.\n\tfunction sub256(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b <= a, \"subtraction underflow\");\n\t\treturn a - b;\n\t}\n\n\t/**\n\t * @notice Retrieve CHAIN_ID of the executing chain.\n\t *\n\t * Chain identifier (chainID) introduced in EIP-155 protects transaction\n\t * included into one chain from being included into another chain.\n\t * Basically, chain identifier is an integer number being used in the\n\t * processes of signing transactions and verifying transaction signatures.\n\t *\n\t * @dev As of version 0.5.12, Solidity includes an assembly function\n\t * chainid() that provides access to the new CHAINID opcode.\n\t *\n\t * TODO: chainId is included in block. So you can get chain id like\n\t * block timestamp or block number: block.chainid;\n\t * */\n\tfunction getChainId() internal pure returns (uint256) {\n\t\tuint256 chainId;\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\t\treturn chainId;\n\t}\n}\n"
    },
    "contracts/fish/governance/Timelock.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./ErrorDecoder.sol\";\n\ninterface ITimelock {\n\tfunction delay() external view returns (uint256);\n\n\tfunction GRACE_PERIOD() external view returns (uint256);\n\n\tfunction acceptAdmin() external;\n\n\tfunction queuedTransactions(bytes32 hash) external view returns (bool);\n\n\tfunction queueTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring calldata signature,\n\t\tbytes calldata data,\n\t\tuint256 eta\n\t) external returns (bytes32);\n\n\tfunction cancelTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring calldata signature,\n\t\tbytes calldata data,\n\t\tuint256 eta\n\t) external;\n\n\tfunction executeTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring calldata signature,\n\t\tbytes calldata data,\n\t\tuint256 eta\n\t) external payable returns (bytes memory);\n}\n\n/**\n * @title Sovryn Protocol Timelock contract, based on Compound system.\n *\n * @notice This contract lets Sovryn governance system set up its\n * own Time Lock instance to execute transactions proposed through the\n * GovernorAlpha contract instance.\n *\n * The Timelock contract allows its admin (Sovryn governance on\n * GovernorAlpha contract) to add arbitrary function calls to a\n * queue. This contract can only execute a function call if the\n * function call has been in the queue for at least 3 hours.\n *\n * Anytime the Timelock contract makes a function call, it must be the\n * case that the function call was first made public by having been publicly\n * added to the queue at least 3 hours prior.\n *\n * The intention is to provide GovernorAlpha contract the functionality to\n * queue proposal actions. This would mean that any changes made by Sovryn\n * governance of any contract would necessarily come with at least an\n * advanced warning. This makes the Sovryn system follow a â€œtime-delayed,\n * opt-outâ€ upgrade pattern (rather than an â€œinstant, forcedâ€ upgrade pattern).\n *\n * Time-delaying admin actions gives users a chance to exit system if its\n * admins become malicious or compromised (or make a change that the users\n * do not like). Downside is that honest admins would be unable\n * to lock down functionality to protect users if a critical bug was found.\n *\n * Delayed transactions reduce the amount of trust required by users of Sovryn\n * and the overall risk for contracts building on top of it, as GovernorAlpha.\n * */\ncontract Timelock is ErrorDecoder, ITimelock {\n\tusing SafeMath for uint256;\n\n\tuint256 public constant GRACE_PERIOD = 14 days;\n\tuint256 public constant MINIMUM_DELAY = 3 hours;\n\tuint256 public constant MAXIMUM_DELAY = 30 days;\n\n\taddress public admin;\n\taddress public pendingAdmin;\n\tuint256 public delay;\n\n\tmapping(bytes32 => bool) public queuedTransactions;\n\n\tevent NewAdmin(address indexed newAdmin);\n\tevent NewPendingAdmin(address indexed newPendingAdmin);\n\tevent NewDelay(uint256 indexed newDelay);\n\tevent CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n\tevent ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n\tevent QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n\n\t/**\n\t * @notice Function called on instance deployment of the contract.\n\t * @param admin_ Governance contract address.\n\t * @param delay_ Time to wait for queued transactions to be executed.\n\t * */\n\tconstructor(address admin_, uint256 delay_) public {\n\t\trequire(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n\t\trequire(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n\t\tadmin = admin_;\n\t\tdelay = delay_;\n\t}\n\n\t/**\n\t * @notice Fallback function is to react to receiving value (rBTC).\n\t * */\n\tfunction() external payable {}\n\n\t/**\n\t * @notice Set a new delay when executing the contract calls.\n\t * @param delay_ The amount of time to wait until execution.\n\t * */\n\tfunction setDelay(uint256 delay_) public {\n\t\trequire(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n\t\trequire(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n\t\trequire(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\t\tdelay = delay_;\n\n\t\temit NewDelay(delay);\n\t}\n\n\t/**\n\t * @notice Accept a new admin for the timelock.\n\t * */\n\tfunction acceptAdmin() public {\n\t\trequire(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n\t\tadmin = msg.sender;\n\t\tpendingAdmin = address(0);\n\n\t\temit NewAdmin(admin);\n\t}\n\n\t/**\n\t * @notice Set a new pending admin for the timelock.\n\t * @param pendingAdmin_ The new pending admin address.\n\t * */\n\tfunction setPendingAdmin(address pendingAdmin_) public {\n\t\trequire(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n\t\tpendingAdmin = pendingAdmin_;\n\n\t\temit NewPendingAdmin(pendingAdmin);\n\t}\n\n\t/**\n\t * @notice Queue a new transaction from the governance contract.\n\t * @param target The contract to call.\n\t * @param value The amount to send in the transaction.\n\t * @param signature The stanndard representation of the function called.\n\t * @param data The ethereum transaction input data payload.\n\t * @param eta Estimated Time of Accomplishment. The timestamp that the\n\t * proposal will be available for execution, set once the vote succeeds.\n\t * */\n\tfunction queueTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring memory signature,\n\t\tbytes memory data,\n\t\tuint256 eta\n\t) public returns (bytes32) {\n\t\trequire(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n\t\trequire(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n\t\tbytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\t\tqueuedTransactions[txHash] = true;\n\n\t\temit QueueTransaction(txHash, target, value, signature, data, eta);\n\t\treturn txHash;\n\t}\n\n\t/**\n\t * @notice Cancel a transaction.\n\t * @param target The contract to call.\n\t * @param value The amount to send in the transaction.\n\t * @param signature The stanndard representation of the function called.\n\t * @param data The ethereum transaction input data payload.\n\t * @param eta Estimated Time of Accomplishment. The timestamp that the\n\t * proposal will be available for execution, set once the vote succeeds.\n\t * */\n\tfunction cancelTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring memory signature,\n\t\tbytes memory data,\n\t\tuint256 eta\n\t) public {\n\t\trequire(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n\t\tbytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\t\tqueuedTransactions[txHash] = false;\n\n\t\temit CancelTransaction(txHash, target, value, signature, data, eta);\n\t}\n\n\t/**\n\t * @notice Executes a previously queued transaction from the governance.\n\t * @param target The contract to call.\n\t * @param value The amount to send in the transaction.\n\t * @param signature The stanndard representation of the function called.\n\t * @param data The ethereum transaction input data payload.\n\t * @param eta Estimated Time of Accomplishment. The timestamp that the\n\t * proposal will be available for execution, set once the vote succeeds.\n\t * */\n\tfunction executeTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring memory signature,\n\t\tbytes memory data,\n\t\tuint256 eta\n\t) public payable returns (bytes memory) {\n\t\trequire(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n\t\tbytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\t\trequire(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n\t\trequire(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n\t\trequire(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n\t\tqueuedTransactions[txHash] = false;\n\n\t\tbytes memory callData;\n\n\t\tif (bytes(signature).length == 0) {\n\t\t\tcallData = data;\n\t\t} else {\n\t\t\tcallData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n\t\t}\n\n\t\t// solium-disable-next-line security/no-call-value\n\t\t(bool success, bytes memory returnData) = target.call.value(value)(callData);\n\t\tif (!success) {\n\t\t\tif (returnData.length <= ERROR_MESSAGE_SHIFT) {\n\t\t\t\trevert(\"Timelock::executeTransaction: Transaction execution reverted.\");\n\t\t\t} else {\n\t\t\t\trevert(_addErrorMessage(\"Timelock::executeTransaction: \", string(returnData)));\n\t\t\t}\n\t\t}\n\n\t\temit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n\t\treturn returnData;\n\t}\n\n\t/**\n\t * @notice A function used to get the current Block Timestamp.\n\t * @dev Timestamp of the current block in seconds since the epoch.\n\t * It is a Unix time stamp. So, it has the complete information about\n\t * the date, hours, minutes, and seconds (in UTC) when the block was\n\t * created.\n\t * */\n\tfunction getBlockTimestamp() internal view returns (uint256) {\n\t\t// solium-disable-next-line security/no-block-members\n\t\treturn block.timestamp;\n\t}\n}\n"
    },
    "contracts/fish/governance/GovernorAlpha.sol": {
      "content": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"./Staking/SafeMath96.sol\";\nimport \"./Timelock.sol\";\nimport \"./Staking/Staking.sol\";\nimport \"../rsk/RSKAddrValidator.sol\";\n\n/**\n * @title Governance Contract.\n * @notice This is an adapted clone of compoundâ€™s governance model. In general,\n * the process is the same: Token holders can make (executable) proposals if\n * they possess enough voting power, vote on proposals during a predefined\n * voting period and in the end evaluate the outcome. If successful, the\n * proposal will be scheduled on the timelock contract. Only after sufficient\n * time passed, it can be executed. A minimum voting power is required for\n * making a proposal as well as a minimum quorum.\n *\n * Voting power in the Bitocracy:\n * Stakers will receive voting power in the Bitocracy in return for their\n * staking commitment. This voting power is weighted by how much SOV is staked\n * and for how long the staking period is - staking more SOV over longer staking\n * periods results in higher voting power. With this voting power, users can\n * vote for or against any SIP in bitocracy.sovryn.app.\n * */\ncontract GovernorAlpha is SafeMath96 {\n\t/* Storage */\n\n\t/// @notice The name of this contract.\n\tstring public constant NAME = \"Sovryn Governor Alpha\";\n\n\t/// @notice The maximum number of actions that can be included in a proposal.\n\tfunction proposalMaxOperations() public pure returns (uint256) {\n\t\treturn 10;\n\t} // 10 actions\n\n\t/// @notice The delay before voting on a proposal may take place, once proposed.\n\tfunction votingDelay() public pure returns (uint256) {\n\t\treturn 1;\n\t} // 1 block\n\n\t/// @notice The duration of voting on a proposal, in blocks.\n\tfunction votingPeriod() public pure returns (uint256) {\n\t\treturn 2880;\n\t} // ~1 day in blocks (assuming 30s blocks)\n\n\t/// @notice The address of the Sovryn Protocol Timelock.\n\tITimelock public timelock;\n\n\t/// @notice The address of the Sovryn staking contract.\n\tIStaking public staking;\n\n\t/// @notice The address of the Governor Guardian.\n\taddress public guardian;\n\n\t/// @notice The total number of proposals.\n\tuint256 public proposalCount;\n\n\t/// @notice Percentage of current total voting power require to vote.\n\tuint96 public quorumPercentageVotes;\n\n\t// @notice Majority percentage.\n\tuint96 public majorityPercentageVotes;\n\n\tstruct Proposal {\n\t\t/// @notice Unique id for looking up a proposal.\n\t\tuint256 id;\n\t\t/// @notice The block at which voting begins: holders must delegate their votes prior to this block.\n\t\tuint32 startBlock;\n\t\t/// @notice The block at which voting ends: votes must be cast prior to this block.\n\t\tuint32 endBlock;\n\t\t/// @notice Current number of votes in favor of this proposal.\n\t\tuint96 forVotes;\n\t\t/// @notice Current number of votes in opposition to this proposal.\n\t\tuint96 againstVotes;\n\t\t///@notice the quorum required for this proposal.\n\t\tuint96 quorum;\n\t\t///@notice the majority percentage required for this proposal.\n\t\tuint96 majorityPercentage;\n\t\t/// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds.\n\t\tuint64 eta;\n\t\t/// @notice the start time is required for the staking contract.\n\t\tuint64 startTime;\n\t\t/// @notice Flag marking whether the proposal has been canceled.\n\t\tbool canceled;\n\t\t/// @notice Flag marking whether the proposal has been executed.\n\t\tbool executed;\n\t\t/// @notice Creator of the proposal.\n\t\taddress proposer;\n\t\t/// @notice the ordered list of target addresses for calls to be made.\n\t\taddress[] targets;\n\t\t/// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made.\n\t\tuint256[] values;\n\t\t/// @notice The ordered list of function signatures to be called.\n\t\tstring[] signatures;\n\t\t/// @notice The ordered list of calldata to be passed to each call.\n\t\tbytes[] calldatas;\n\t\t/// @notice Receipts of ballots for the entire set of voters.\n\t\tmapping(address => Receipt) receipts;\n\t}\n\n\t/// @notice Ballot receipt record for a voter\n\tstruct Receipt {\n\t\t/// @notice Whether or not a vote has been cast.\n\t\tbool hasVoted;\n\t\t/// @notice Whether or not the voter supports the proposal.\n\t\tbool support;\n\t\t/// @notice The number of votes the voter had, which were cast.\n\t\tuint96 votes;\n\t}\n\n\t/// @notice Possible states that a proposal may be in.\n\tenum ProposalState { Pending, Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed }\n\n\t/// @notice The official record of all proposals ever proposed.\n\tmapping(uint256 => Proposal) public proposals;\n\n\t/// @notice The latest proposal for each proposer.\n\tmapping(address => uint256) public latestProposalIds;\n\n\t/// @notice The EIP-712 typehash for the contract's domain.\n\tbytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n\t/// @notice The EIP-712 typehash for the ballot struct used by the contract.\n\tbytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n\t/* Events */\n\n\t/// @notice An event emitted when a new proposal is created.\n\tevent ProposalCreated(\n\t\tuint256 id,\n\t\taddress proposer,\n\t\taddress[] targets,\n\t\tuint256[] values,\n\t\tstring[] signatures,\n\t\tbytes[] calldatas,\n\t\tuint256 startBlock,\n\t\tuint256 endBlock,\n\t\tstring description\n\t);\n\n\t/// @notice An event emitted when a vote has been cast on a proposal.\n\tevent VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n\n\t/// @notice An event emitted when a proposal has been canceled.\n\tevent ProposalCanceled(uint256 id);\n\n\t/// @notice An event emitted when a proposal has been queued in the Timelock.\n\tevent ProposalQueued(uint256 id, uint256 eta);\n\n\t/// @notice An event emitted when a proposal has been executed in the Timelock.\n\tevent ProposalExecuted(uint256 id);\n\n\t/* Functions */\n\n\tconstructor(\n\t\taddress timelock_,\n\t\taddress staking_,\n\t\taddress guardian_,\n\t\tuint96 _quorumPercentageVotes,\n\t\tuint96 _majorityPercentageVotes\n\t) public {\n\t\ttimelock = ITimelock(timelock_);\n\t\tstaking = IStaking(staking_);\n\t\tguardian = guardian_;\n\t\tquorumPercentageVotes = _quorumPercentageVotes;\n\t\tmajorityPercentageVotes = _majorityPercentageVotes;\n\t}\n\n\t/// @notice The number of votes required in order for a voter to become a proposer.\n\tfunction proposalThreshold() public view returns (uint96) {\n\t\tuint96 totalVotingPower =\n\t\t\tstaking.getPriorTotalVotingPower(\n\t\t\t\tsafe32(block.number - 1, \"GovernorAlpha::proposalThreshold: block number overflow\"),\n\t\t\t\tblock.timestamp\n\t\t\t);\n\t\t// 1% of current total voting power.\n\t\treturn totalVotingPower / 100;\n\t}\n\n\t/// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed.\n\tfunction quorumVotes() public view returns (uint96) {\n\t\tuint96 totalVotingPower =\n\t\t\tstaking.getPriorTotalVotingPower(\n\t\t\t\tsafe32(block.number - 1, \"GovernorAlpha::quorumVotes: block number overflow\"),\n\t\t\t\tblock.timestamp\n\t\t\t);\n\t\t// 4% of current total voting power.\n\t\treturn mul96(quorumPercentageVotes, totalVotingPower, \"GovernorAlpha::quorumVotes:multiplication overflow\") / 100;\n\t}\n\n\t/**\n\t * @notice Create a new proposal.\n\t * @param targets Array of contract addresses to perform proposal execution.\n\t * @param values Array of rBTC amounts to send on proposal execution.\n\t * @param signatures Array of function signatures to call on proposal execution.\n\t * @param calldatas Array of payloads for the calls on proposal execution.\n\t * @param description Text describing the purpose of the proposal.\n\t * */\n\tfunction propose(\n\t\taddress[] memory targets,\n\t\tuint256[] memory values,\n\t\tstring[] memory signatures,\n\t\tbytes[] memory calldatas,\n\t\tstring memory description\n\t) public returns (uint256) {\n\t\t// note: passing this block's timestamp, but the number of the previous block.\n\t\t// todo: think if it would be better to pass block.timestamp - 30 (average block time)\n\t\t// (probably not because proposal starts in 1 block from now).\n\t\tuint96 threshold = proposalThreshold();\n\t\trequire(\n\t\t\tstaking.getPriorVotes(msg.sender, sub256(block.number, 1), block.timestamp) > threshold,\n\t\t\t\"GovernorAlpha::propose: proposer votes below proposal threshold\"\n\t\t);\n\t\trequire(\n\t\t\ttargets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,\n\t\t\t\"GovernorAlpha::propose: proposal function information arity mismatch\"\n\t\t);\n\t\trequire(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n\t\trequire(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n\t\tuint256 latestProposalId = latestProposalIds[msg.sender];\n\t\tif (latestProposalId != 0) {\n\t\t\tProposalState proposersLatestProposalState = state(latestProposalId);\n\t\t\trequire(\n\t\t\t\tproposersLatestProposalState != ProposalState.Active,\n\t\t\t\t\"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n\t\t\t);\n\t\t\trequire(\n\t\t\t\tproposersLatestProposalState != ProposalState.Pending,\n\t\t\t\t\"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\"\n\t\t\t);\n\t\t}\n\n\t\tuint256 startBlock = add256(block.number, votingDelay());\n\t\tuint256 endBlock = add256(startBlock, votingPeriod());\n\n\t\tproposalCount++;\n\n\t\t/// @dev quorum: proposalThreshold is 1% of total votes, we can save gas using this pre calculated value.\n\t\t/// @dev startTime: Required by the staking contract. not used by the governance contract itself.\n\t\tProposal memory newProposal =\n\t\t\tProposal({\n\t\t\t\tid: proposalCount,\n\t\t\t\tstartBlock: safe32(startBlock, \"GovernorAlpha::propose: start block number overflow\"),\n\t\t\t\tendBlock: safe32(endBlock, \"GovernorAlpha::propose: end block number overflow\"),\n\t\t\t\tforVotes: 0,\n\t\t\t\tagainstVotes: 0,\n\t\t\t\tquorum: mul96(quorumPercentageVotes, threshold, \"GovernorAlpha::propose: overflow on quorum computation\"),\n\t\t\t\tmajorityPercentage: mul96(\n\t\t\t\t\tmajorityPercentageVotes,\n\t\t\t\t\tthreshold,\n\t\t\t\t\t\"GovernorAlpha::propose: overflow on majorityPercentage computation\"\n\t\t\t\t),\n\t\t\t\teta: 0,\n\t\t\t\tstartTime: safe64(block.timestamp, \"GovernorAlpha::propose: startTime overflow\"),\n\t\t\t\tcanceled: false,\n\t\t\t\texecuted: false,\n\t\t\t\tproposer: msg.sender,\n\t\t\t\ttargets: targets,\n\t\t\t\tvalues: values,\n\t\t\t\tsignatures: signatures,\n\t\t\t\tcalldatas: calldatas\n\t\t\t});\n\n\t\tproposals[newProposal.id] = newProposal;\n\t\tlatestProposalIds[newProposal.proposer] = newProposal.id;\n\n\t\temit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n\t\treturn newProposal.id;\n\t}\n\n\t/**\n\t * @notice Enqueue a proposal and everyone of its calls.\n\t * @param proposalId Proposal index to access the list proposals[] from storage.\n\t * */\n\tfunction queue(uint256 proposalId) public {\n\t\trequire(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\n\t\tProposal storage proposal = proposals[proposalId];\n\t\tuint256 eta = add256(block.timestamp, timelock.delay());\n\n\t\tfor (uint256 i = 0; i < proposal.targets.length; i++) {\n\t\t\t_queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n\t\t}\n\t\tproposal.eta = safe64(eta, \"GovernorAlpha::queue: ETA overflow\");\n\t\temit ProposalQueued(proposalId, eta);\n\t}\n\n\t/**\n\t * @notice Tries to enqueue a proposal, verifying it has not been previously queued.\n\t * @param target Contract addresses to perform proposal execution.\n\t * @param value rBTC amount to send on proposal execution.\n\t * @param signature Function signature to call on proposal execution.\n\t * @param data Payload for the call on proposal execution.\n\t * @param eta Estimated Time of Accomplishment. The timestamp that the\n\t * proposal will be available for execution, set once the vote succeeds.\n\t * */\n\tfunction _queueOrRevert(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring memory signature,\n\t\tbytes memory data,\n\t\tuint256 eta\n\t) internal {\n\t\trequire(\n\t\t\t!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n\t\t\t\"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\"\n\t\t);\n\t\ttimelock.queueTransaction(target, value, signature, data, eta);\n\t}\n\n\t/**\n\t * @notice Execute a proposal by looping and performing everyone of its calls.\n\t * @param proposalId Proposal index to access the list proposals[] from storage.\n\t * */\n\tfunction execute(uint256 proposalId) public payable {\n\t\trequire(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n\t\tProposal storage proposal = proposals[proposalId];\n\t\tproposal.executed = true;\n\n\t\tfor (uint256 i = 0; i < proposal.targets.length; i++) {\n\t\t\ttimelock.executeTransaction.value(proposal.values[i])(\n\t\t\t\tproposal.targets[i],\n\t\t\t\tproposal.values[i],\n\t\t\t\tproposal.signatures[i],\n\t\t\t\tproposal.calldatas[i],\n\t\t\t\tproposal.eta\n\t\t\t);\n\t\t}\n\t\temit ProposalExecuted(proposalId);\n\t}\n\n\t/**\n\t * @notice Cancel a proposal by looping and cancelling everyone of its calls.\n\t * @param proposalId Proposal index to access the list proposals[] from storage.\n\t * */\n\tfunction cancel(uint256 proposalId) public {\n\t\tProposalState state = state(proposalId);\n\t\trequire(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n\n\t\tProposal storage proposal = proposals[proposalId];\n\t\t/// @notice Cancel only if sent by the guardian.\n\t\trequire(msg.sender == guardian, \"GovernorAlpha::cancel: sender isn't a guardian\");\n\n\t\tproposal.canceled = true;\n\n\t\tfor (uint256 i = 0; i < proposal.targets.length; i++) {\n\t\t\ttimelock.cancelTransaction(\n\t\t\t\tproposal.targets[i],\n\t\t\t\tproposal.values[i],\n\t\t\t\tproposal.signatures[i],\n\t\t\t\tproposal.calldatas[i],\n\t\t\t\tproposal.eta\n\t\t\t);\n\t\t}\n\n\t\temit ProposalCanceled(proposalId);\n\t}\n\n\t/**\n\t * @notice Get a proposal list of its calls.\n\t * @param proposalId Proposal index to access the list proposals[] from storage.\n\t * @return Arrays of the 4 call parameters: targets, values, signatures, calldatas.\n\t * */\n\tfunction getActions(uint256 proposalId)\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\taddress[] memory targets,\n\t\t\tuint256[] memory values,\n\t\t\tstring[] memory signatures,\n\t\t\tbytes[] memory calldatas\n\t\t)\n\t{\n\t\tProposal storage p = proposals[proposalId];\n\t\treturn (p.targets, p.values, p.signatures, p.calldatas);\n\t}\n\n\t/**\n\t * @notice Get a proposal receipt.\n\t * @param proposalId Proposal index to access the list proposals[] from storage.\n\t * @param voter A governance stakeholder with voting power.\n\t * @return The voter receipt of the proposal.\n\t * */\n\tfunction getReceipt(uint256 proposalId, address voter) public view returns (Receipt memory) {\n\t\treturn proposals[proposalId].receipts[voter];\n\t}\n\n\t/**\n\t * @notice Casts a vote by sender.\n\t * @param proposalId Proposal index to access the list proposals[] from storage.\n\t * @param support Vote value, yes or no.\n\t * */\n\tfunction castVote(uint256 proposalId, bool support) public {\n\t\treturn _castVote(msg.sender, proposalId, support);\n\t}\n\n\t/**\n\t * @notice Voting with EIP-712 Signatures.\n\t *\n\t * Voting power can be delegated to any address, and then can be used to\n\t * vote on proposals. A key benefit to users of by-signature functionality\n\t * is that they can create a signed vote transaction for free, and have a\n\t * trusted third-party spend rBTC(or ETH) on gas fees and write it to the\n\t * blockchain for them.\n\t *\n\t * The third party in this scenario, submitting the SOV-holderâ€™s signed\n\t * transaction holds a voting power that is for only a single proposal.\n\t * The signatory still holds the power to vote on their own behalf in\n\t * the proposal if the third party has not yet published the signed\n\t * transaction that was given to them.\n\t *\n\t * @dev The signature needs to be broken up into 3 parameters, known as\n\t * v, r and s:\n\t * const r = '0x' + sig.substring(2).substring(0, 64);\n\t * const s = '0x' + sig.substring(2).substring(64, 128);\n\t * const v = '0x' + sig.substring(2).substring(128, 130);\n\t *\n\t * @param proposalId Proposal index to access the list proposals[] from storage.\n\t * @param support Vote value, yes or no.\n\t * @param v The recovery byte of the signature.\n\t * @param r Half of the ECDSA signature pair.\n\t * @param s Half of the ECDSA signature pair.\n\t * */\n\tfunction castVoteBySig(\n\t\tuint256 proposalId,\n\t\tbool support,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public {\n\t\t/**\n\t\t * @dev The DOMAIN_SEPARATOR is a hash that uniquely identifies a\n\t\t * smart contract. It is built from a string denoting it as an\n\t\t * EIP712 Domain, the name of the token contract, the version,\n\t\t * the chainId in case it changes, and the address that the\n\t\t * contract is deployed at.\n\t\t * */\n\t\tbytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), getChainId(), address(this)));\n\n\t\t/// @dev GovernorAlpha uses BALLOT_TYPEHASH, while Staking uses DELEGATION_TYPEHASH\n\t\tbytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\t\taddress signatory = ecrecover(digest, v, r, s);\n\n\t\t/// @dev Verify address is not null and PK is not null either.\n\t\trequire(RSKAddrValidator.checkPKNotZero(signatory), \"GovernorAlpha::castVoteBySig: invalid signature\");\n\t\treturn _castVote(signatory, proposalId, support);\n\t}\n\n\t/**\n\t * @notice Cast a vote, adding it to the total counting.\n\t * @param voter A governance stakeholder with voting power that is casting the vote.\n\t * @param proposalId Proposal index to access the list proposals[] from storage.\n\t * @param support Vote value, yes or no.\n\t * */\n\tfunction _castVote(\n\t\taddress voter,\n\t\tuint256 proposalId,\n\t\tbool support\n\t) internal {\n\t\trequire(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n\t\tProposal storage proposal = proposals[proposalId];\n\t\tReceipt storage receipt = proposal.receipts[voter];\n\t\trequire(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n\t\tuint96 votes = staking.getPriorVotes(voter, proposal.startBlock, proposal.startTime);\n\n\t\tif (support) {\n\t\t\tproposal.forVotes = add96(proposal.forVotes, votes, \"GovernorAlpha::_castVote: vote overflow\");\n\t\t} else {\n\t\t\tproposal.againstVotes = add96(proposal.againstVotes, votes, \"GovernorAlpha::_castVote: vote overflow\");\n\t\t}\n\n\t\treceipt.hasVoted = true;\n\t\treceipt.support = support;\n\t\treceipt.votes = votes;\n\n\t\temit VoteCast(voter, proposalId, support, votes);\n\t}\n\n\t/// @dev Timelock wrapper w/ sender check.\n\tfunction __acceptAdmin() public {\n\t\trequire(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\n\t\ttimelock.acceptAdmin();\n\t}\n\n\t/// @notice Sets guardian address to zero.\n\tfunction __abdicate() public {\n\t\trequire(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n\t\tguardian = address(0);\n\t}\n\n\t/// @dev Timelock wrapper w/ sender check.\n\tfunction __queueSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\n\t\trequire(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n\t\ttimelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n\t}\n\n\t/// @dev Timelock wrapper w/ sender check.\n\tfunction __executeSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\n\t\trequire(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n\t\ttimelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n\t}\n\n\t/**\n\t * @notice Get a proposal state.\n\t * @param proposalId Proposal index to access the list proposals[] from storage.\n\t * @return The state of the proposal: Canceled, Pending, Active, Defeated,\n\t * Succeeded, Executed, Expired.\n\t * */\n\tfunction state(uint256 proposalId) public view returns (ProposalState) {\n\t\trequire(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n\t\tProposal storage proposal = proposals[proposalId];\n\n\t\tif (proposal.canceled) {\n\t\t\treturn ProposalState.Canceled;\n\t\t}\n\n\t\tif (block.number <= proposal.startBlock) {\n\t\t\treturn ProposalState.Pending;\n\t\t}\n\n\t\tif (block.number <= proposal.endBlock) {\n\t\t\treturn ProposalState.Active;\n\t\t}\n\n\t\tuint96 totalVotes = add96(proposal.forVotes, proposal.againstVotes, \"GovernorAlpha:: state: forVotes + againstVotes > uint96\");\n\t\tuint96 totalVotesMajorityPercentage = div96(totalVotes, 100, \"GovernorAlpha:: state: division error\");\n\t\ttotalVotesMajorityPercentage = mul96(\n\t\t\ttotalVotesMajorityPercentage,\n\t\t\tmajorityPercentageVotes,\n\t\t\t\"GovernorAlpha:: state: totalVotes * majorityPercentage > uint96\"\n\t\t);\n\t\tif (proposal.forVotes <= totalVotesMajorityPercentage || totalVotes < proposal.quorum) {\n\t\t\treturn ProposalState.Defeated;\n\t\t}\n\n\t\tif (proposal.eta == 0) {\n\t\t\treturn ProposalState.Succeeded;\n\t\t}\n\n\t\tif (proposal.executed) {\n\t\t\treturn ProposalState.Executed;\n\t\t}\n\n\t\tif (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n\t\t\treturn ProposalState.Expired;\n\t\t}\n\n\t\treturn ProposalState.Queued;\n\t}\n\n\t/// @dev TODO: use OpenZeppelin's SafeMath function instead.\n\tfunction add256(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tuint256 c = a + b;\n\t\trequire(c >= a, \"addition overflow\");\n\t\treturn c;\n\t}\n\n\t/// @dev TODO: use OpenZeppelin's SafeMath function instead.\n\tfunction sub256(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\trequire(b <= a, \"subtraction underflow\");\n\t\treturn a - b;\n\t}\n\n\t/**\n\t * @notice Retrieve CHAIN_ID of the executing chain.\n\t *\n\t * Chain identifier (chainID) introduced in EIP-155 protects transaction\n\t * included into one chain from being included into another chain.\n\t * Basically, chain identifier is an integer number being used in the\n\t * processes of signing transactions and verifying transaction signatures.\n\t *\n\t * @dev As of version 0.5.12, Solidity includes an assembly function\n\t * chainid() that provides access to the new CHAINID opcode.\n\t *\n\t * TODO: chainId is included in block. So you can get chain id like\n\t * block timestamp or block number: block.chainid;\n\t * */\n\tfunction getChainId() internal pure returns (uint256) {\n\t\tuint256 chainId;\n\t\tassembly {\n\t\t\tchainId := chainid()\n\t\t}\n\t\treturn chainId;\n\t}\n}\n\n/* Interfaces */\n\ninterface TimelockInterface {\n\tfunction delay() external view returns (uint256);\n\n\tfunction GRACE_PERIOD() external view returns (uint256);\n\n\tfunction acceptAdmin() external;\n\n\tfunction queuedTransactions(bytes32 hash) external view returns (bool);\n\n\tfunction queueTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring calldata signature,\n\t\tbytes calldata data,\n\t\tuint256 eta\n\t) external returns (bytes32);\n\n\tfunction cancelTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring calldata signature,\n\t\tbytes calldata data,\n\t\tuint256 eta\n\t) external;\n\n\tfunction executeTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring calldata signature,\n\t\tbytes calldata data,\n\t\tuint256 eta\n\t) external payable returns (bytes memory);\n}\n\ninterface StakingInterface {\n\tfunction getPriorVotes(\n\t\taddress account,\n\t\tuint256 blockNumber,\n\t\tuint256 date\n\t) external view returns (uint96);\n\n\tfunction getPriorTotalVotingPower(uint32 blockNumber, uint256 time) external view returns (uint96);\n}\n"
    },
    "contracts/fish/governance/Vesting/TeamVesting.sol": {
      "content": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../Staking/Staking.sol\";\nimport \"../IFeeSharingProxy.sol\";\nimport \"./IVesting.sol\";\nimport \"../ApprovalReceiver.sol\";\nimport \"./VestingStorage.sol\";\nimport \"../proxy/Proxy.sol\";\n\n/**\n * @title Team Vesting Contract.\n *\n * @notice A regular vesting contract, but the owner (governance) is able to\n * withdraw earlier without a slashing.\n *\n * @dev Vesting contracts shouldn't be upgradable,\n * use Proxy instead of UpgradableProxy.\n * */\ncontract TeamVesting is VestingStorage, Proxy {\n\t/**\n\t * @notice Setup the vesting schedule.\n\t * @param _logic The address of logic contract.\n\t * @param _SOV The SOV token address.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @param _cliff The time interval to the first withdraw in seconds.\n\t * @param _duration The total duration in seconds.\n\t * */\n\tconstructor(\n\t\taddress _logic,\n\t\taddress _SOV,\n\t\taddress _stakingAddress,\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration,\n\t\taddress _feeSharingProxy\n\t) public {\n\t\trequire(_SOV != address(0), \"SOV address invalid\");\n\t\trequire(_stakingAddress != address(0), \"staking address invalid\");\n\t\trequire(_tokenOwner != address(0), \"token owner address invalid\");\n\t\trequire(_duration >= _cliff, \"duration must be bigger than or equal to the cliff\");\n\t\trequire(_feeSharingProxy != address(0), \"feeSharingProxy address invalid\");\n\n\t\t_setImplementation(_logic);\n\t\tSOV = IERC20(_SOV);\n\t\tstaking = Staking(_stakingAddress);\n\t\trequire(_duration <= staking.MAX_DURATION(), \"duration may not exceed the max duration\");\n\t\ttokenOwner = _tokenOwner;\n\t\tcliff = _cliff;\n\t\tduration = _duration;\n\t\tfeeSharingProxy = IFeeSharingProxy(_feeSharingProxy);\n\t}\n}\n"
    },
    "contracts/fish/governance/proxy/Proxy.sol": {
      "content": "pragma solidity ^0.5.17;\n\n/**\n * @title Base Proxy contract.\n * @notice The proxy performs delegated calls to the contract implementation\n * it is pointing to. This way upgradable contracts are possible on blockchain.\n *\n * Delegating proxy contracts are widely used for both upgradeability and gas\n * savings. These proxies rely on a logic contract (also known as implementation\n * contract or master copy) that is called using delegatecall. This allows\n * proxies to keep a persistent state (storage and balance) while the code is\n * delegated to the logic contract.\n *\n * Proxy contract is meant to be inherited and its internal functions\n * _setImplementation and _setProxyOwner to be called when upgrades become\n * neccessary.\n *\n * The loan token (iToken) contract as well as the protocol contract act as\n * proxies, delegating all calls to underlying contracts. Therefore, if you\n * want to interact with them using web3, you need to use the ABIs from the\n * contracts containing the actual logic or the interface contract.\n *   ABI for LoanToken contracts: LoanTokenLogicStandard\n *   ABI for Protocol contract: ISovryn\n *\n * @dev UpgradableProxy is the contract that inherits Proxy and wraps these\n * functions.\n * */\ncontract Proxy {\n\tbytes32 private constant KEY_IMPLEMENTATION = keccak256(\"key.implementation\");\n\tbytes32 private constant KEY_OWNER = keccak256(\"key.proxy.owner\");\n\n\tevent OwnershipTransferred(address indexed _oldOwner, address indexed _newOwner);\n\tevent ImplementationChanged(address indexed _oldImplementation, address indexed _newImplementation);\n\n\t/**\n\t * @notice Set sender as an owner.\n\t * */\n\tconstructor() public {\n\t\t_setProxyOwner(msg.sender);\n\t}\n\n\t/**\n\t * @notice Throw error if called not by an owner.\n\t * */\n\tmodifier onlyProxyOwner() {\n\t\trequire(msg.sender == getProxyOwner(), \"Proxy:: access denied\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Set address of the implementation.\n\t * @param _implementation Address of the implementation.\n\t * */\n\tfunction _setImplementation(address _implementation) internal {\n\t\trequire(_implementation != address(0), \"Proxy::setImplementation: invalid address\");\n\t\temit ImplementationChanged(getImplementation(), _implementation);\n\n\t\tbytes32 key = KEY_IMPLEMENTATION;\n\t\tassembly {\n\t\t\tsstore(key, _implementation)\n\t\t}\n\t}\n\n\t/**\n\t * @notice Return address of the implementation.\n\t * @return Address of the implementation.\n\t * */\n\tfunction getImplementation() public view returns (address _implementation) {\n\t\tbytes32 key = KEY_IMPLEMENTATION;\n\t\tassembly {\n\t\t\t_implementation := sload(key)\n\t\t}\n\t}\n\n\t/**\n\t * @notice Set address of the owner.\n\t * @param _owner Address of the owner.\n\t * */\n\tfunction _setProxyOwner(address _owner) internal {\n\t\trequire(_owner != address(0), \"Proxy::setProxyOwner: invalid address\");\n\t\temit OwnershipTransferred(getProxyOwner(), _owner);\n\n\t\tbytes32 key = KEY_OWNER;\n\t\tassembly {\n\t\t\tsstore(key, _owner)\n\t\t}\n\t}\n\n\t/**\n\t * @notice Return address of the owner.\n\t * @return Address of the owner.\n\t * */\n\tfunction getProxyOwner() public view returns (address _owner) {\n\t\tbytes32 key = KEY_OWNER;\n\t\tassembly {\n\t\t\t_owner := sload(key)\n\t\t}\n\t}\n\n\t/**\n\t * @notice Fallback function performs a delegate call\n\t * to the actual implementation address is pointing this proxy.\n\t * Returns whatever the implementation call returns.\n\t * */\n\tfunction() external payable {\n\t\taddress implementation = getImplementation();\n\t\trequire(implementation != address(0), \"Proxy::(): implementation not found\");\n\n\t\tassembly {\n\t\t\tlet pointer := mload(0x40)\n\t\t\tcalldatacopy(pointer, 0, calldatasize)\n\t\t\tlet result := delegatecall(gas, implementation, pointer, calldatasize, 0, 0)\n\t\t\tlet size := returndatasize\n\t\t\treturndatacopy(pointer, 0, size)\n\n\t\t\tswitch result\n\t\t\t\tcase 0 {\n\t\t\t\t\trevert(pointer, size)\n\t\t\t\t}\n\t\t\t\tdefault {\n\t\t\t\t\treturn(pointer, size)\n\t\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "contracts/fish/governance/Vesting/VestingFactory.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"./Vesting.sol\";\nimport \"./TeamVesting.sol\";\nimport \"./IVestingFactory.sol\";\n\n/**\n * @title Vesting Factory: Contract to deploy vesting contracts\n * of two types: vesting (TokenHolder) and team vesting (Multisig).\n * @notice Factory pattern allows to create multiple instances\n * of the same contract and keep track of them easier.\n * */\ncontract VestingFactory is IVestingFactory, Ownable {\n\taddress public vestingLogic;\n\n\tconstructor(address _vestingLogic) public {\n\t\trequire(_vestingLogic != address(0), \"invalid vesting logic address\");\n\t\tvestingLogic = _vestingLogic;\n\t}\n\n\t/**\n\t * @notice Deploys Vesting contract.\n\t * @param _SOV the address of SOV token.\n\t * @param _staking The address of staking contract.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @param _cliff The time interval to the first withdraw in seconds.\n\t * @param _duration The total duration in seconds.\n\t * @param _feeSharing The address of fee sharing contract.\n\t * @param _vestingOwner The address of an owner of vesting contract.\n\t * @return The vesting contract address.\n\t * */\n\tfunction deployVesting(\n\t\taddress _SOV,\n\t\taddress _staking,\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration,\n\t\taddress _feeSharing,\n\t\taddress _vestingOwner\n\t)\n\t\texternal\n\t\tonlyOwner /// @dev owner - VestingRegistry\n\t\treturns (address)\n\t{\n\t\taddress vesting = address(new Vesting(vestingLogic, _SOV, _staking, _tokenOwner, _cliff, _duration, _feeSharing));\n\t\tOwnable(vesting).transferOwnership(_vestingOwner);\n\t\treturn vesting;\n\t}\n\n\t/**\n\t * @notice Deploys Team Vesting contract.\n\t * @param _SOV The address of SOV token.\n\t * @param _staking The address of staking contract.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @param _cliff The time interval to the first withdraw in seconds.\n\t * @param _duration The total duration in seconds.\n\t * @param _feeSharing The address of fee sharing contract.\n\t * @param _vestingOwner The address of an owner of vesting contract.\n\t * @return The vesting contract address.\n\t * */\n\tfunction deployTeamVesting(\n\t\taddress _SOV,\n\t\taddress _staking,\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration,\n\t\taddress _feeSharing,\n\t\taddress _vestingOwner\n\t)\n\t\texternal\n\t\tonlyOwner //owner - VestingRegistry\n\t\treturns (address)\n\t{\n\t\taddress vesting = address(new TeamVesting(vestingLogic, _SOV, _staking, _tokenOwner, _cliff, _duration, _feeSharing));\n\t\tOwnable(vesting).transferOwnership(_vestingOwner);\n\t\treturn vesting;\n\t}\n}\n"
    },
    "contracts/fish/governance/Vesting/Vesting.sol": {
      "content": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"./TeamVesting.sol\";\n\n/**\n * @title Vesting Contract.\n * @notice Team tokens and investor tokens are vested. Therefore, a smart\n * contract needs to be developed to enforce the vesting schedule.\n *\n * @dev TODO add tests for governanceWithdrawTokens.\n * */\ncontract Vesting is TeamVesting {\n\t/**\n\t * @notice Setup the vesting schedule.\n\t * @param _logic The address of logic contract.\n\t * @param _SOV The SOV token address.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @param _cliff The time interval to the first withdraw in seconds.\n\t * @param _duration The total duration in seconds.\n\t * */\n\tconstructor(\n\t\taddress _logic,\n\t\taddress _SOV,\n\t\taddress _stakingAddress,\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration,\n\t\taddress _feeSharingProxy\n\t) public TeamVesting(_logic, _SOV, _stakingAddress, _tokenOwner, _cliff, _duration, _feeSharingProxy) {}\n\n\t/**\n\t * @dev We need to add this implementation to prevent proxy call VestingLogic.governanceWithdrawTokens\n\t * @param receiver The receiver of the token withdrawal.\n\t * */\n\tfunction governanceWithdrawTokens(address receiver) public {\n\t\trevert(\"operation not supported\");\n\t}\n}\n"
    },
    "contracts/fish/governance/Vesting/VestingRegistry.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"../../interfaces/IERC20.sol\";\nimport \"../Staking/IStaking.sol\";\nimport \"../IFeeSharingProxy.sol\";\nimport \"./IVestingFactory.sol\";\nimport \"./IVesting.sol\";\nimport \"./ITeamVesting.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @title Vesting Registry contract.\n *\n * @notice On January 25, 2020, Sovryn launched the Genesis Reservation system.\n * Sovryn community members who controlled a special NFT were granted access to\n * stake BTC or rBTC for cSOV tokens at a rate of 2500 satoshis per cSOV. Per\n * SIP-0003, up to 2,000,000 cSOV were made available in the Genesis event,\n * which will be redeemable on a 1:1 basis for cSOV, subject to approval by\n * existing SOV holders.\n *\n * On 15 Feb 2021 Sovryn is taking another step in its journey to decentralized\n * financial sovereignty with the vote on SIP 0005. This proposal will enable\n * participants of the Genesis Reservation system to redeem their reserved cSOV\n * tokens for SOV. They will also have the choice to redeem cSOV for rBTC if\n * they decide to exit the system.\n *\n * This contract deals with the vesting and redemption of cSOV tokens.\n * */\ncontract VestingRegistry is Ownable {\n\tusing SafeMath for uint256;\n\n\t/* Storage */\n\n\t/// @notice Constant used for computing the vesting dates.\n\tuint256 public constant FOUR_WEEKS = 4 weeks;\n\n\tuint256 public constant CSOV_VESTING_CLIFF = FOUR_WEEKS;\n\tuint256 public constant CSOV_VESTING_DURATION = 10 * FOUR_WEEKS;\n\n\tIVestingFactory public vestingFactory;\n\n\t/// @notice The SOV token contract.\n\taddress public SOV;\n\n\t/// @notice The cSOV token contracts.\n\taddress[] public CSOVtokens;\n\n\tuint256 public priceSats;\n\n\t/// @notice The staking contract address.\n\taddress public staking;\n\n\t/// @notice Fee sharing proxy.\n\taddress public feeSharingProxy;\n\n\t/// @notice The vesting owner (e.g. governance timelock address).\n\taddress public vestingOwner;\n\n\t/// @dev TODO: Add to the documentation: address can have only one vesting of each type.\n\t/// @dev user => vesting type => vesting contract.\n\tmapping(address => mapping(uint256 => address)) public vestingContracts;\n\n\t/**\n\t * @dev Struct can be created to save storage slots, but it doesn't make\n\t * sense. We don't have a lot of blacklisted accounts or account with\n\t * locked amount.\n\t * */\n\n\t/// @dev user => flag whether user has already exchange cSOV or got a reimbursement.\n\tmapping(address => bool) public processedList;\n\n\t/// @dev user => flag whether user shouldn't be able to exchange or reimburse.\n\tmapping(address => bool) public blacklist;\n\n\t/// @dev user => amount of tokens should not be processed.\n\tmapping(address => uint256) public lockedAmount;\n\n\t/// @dev user => flag whether user has admin role.\n\tmapping(address => bool) public admins;\n\n\tenum VestingType {\n\t\tTeamVesting, // MultisigVesting\n\t\tVesting // TokenHolderVesting\n\t}\n\n\t/* Events */\n\n\tevent CSOVReImburse(address from, uint256 CSOVamount, uint256 reImburseAmount);\n\tevent CSOVTokensExchanged(address indexed caller, uint256 amount);\n\tevent SOVTransferred(address indexed receiver, uint256 amount);\n\tevent VestingCreated(address indexed tokenOwner, address vesting, uint256 cliff, uint256 duration, uint256 amount);\n\tevent TeamVestingCreated(address indexed tokenOwner, address vesting, uint256 cliff, uint256 duration, uint256 amount);\n\tevent TokensStaked(address indexed vesting, uint256 amount);\n\tevent AdminAdded(address admin);\n\tevent AdminRemoved(address admin);\n\n\t/* Functions */\n\n\t/**\n\t * @notice Contract deployment settings.\n\t * @param _vestingFactory The address of vesting factory contract.\n\t * @param _SOV The SOV token address.\n\t * @param _CSOVtokens The array of cSOV tokens.\n\t * @param _priceSats The price of cSOV tokens in satoshis.\n\t * @param _staking The address of staking contract.\n\t * @param _feeSharingProxy The address of fee sharing proxy contract.\n\t * @param _vestingOwner The address of an owner of vesting contract.\n\t * @dev On Sovryn the vesting owner is Exchequer Multisig.\n\t * According to SIP-0007 The Exchequer Multisig is designated to hold\n\t * certain funds in the form of rBTC and SOV, in order to allow for\n\t * flexible deployment of such funds on:\n\t *  + facilitating rBTC redemptions for Genesis pre-sale participants.\n\t *  + deploying of SOV for the purposes of exchange listings, market\n\t *    making, and partnerships with third parties.\n\t * */\n\tconstructor(\n\t\taddress _vestingFactory,\n\t\taddress _SOV,\n\t\taddress[] memory _CSOVtokens,\n\t\tuint256 _priceSats,\n\t\taddress _staking,\n\t\taddress _feeSharingProxy,\n\t\taddress _vestingOwner\n\t) public {\n\t\trequire(_SOV != address(0), \"SOV address invalid\");\n\t\trequire(_staking != address(0), \"staking address invalid\");\n\t\trequire(_feeSharingProxy != address(0), \"feeSharingProxy address invalid\");\n\t\trequire(_vestingOwner != address(0), \"vestingOwner address invalid\");\n\n\t\t_setVestingFactory(_vestingFactory);\n\t\t_setCSOVtokens(_CSOVtokens);\n\n\t\tSOV = _SOV;\n\t\tpriceSats = _priceSats;\n\t\tstaking = _staking;\n\t\tfeeSharingProxy = _feeSharingProxy;\n\t\tvestingOwner = _vestingOwner;\n\t}\n\n\t//---ACL------------------------------------------------------------------\n\n\t/**\n\t * @dev Throws if called by any account other than the owner or admin.\n\t * TODO: This ACL logic should be available on OpenZeppeling Ownable.sol\n\t * or on our own overriding sovrynOwnable. This same logic is repeated\n\t * on OriginInvestorsClaim.sol, TokenSender.sol and VestingRegistry2.sol\n\t */\n\tmodifier onlyAuthorized() {\n\t\trequire(isOwner() || admins[msg.sender], \"unauthorized\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Add account to ACL.\n\t * @param _admin The addresses of the account to grant permissions.\n\t * */\n\tfunction addAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = true;\n\t\temit AdminAdded(_admin);\n\t}\n\n\t/**\n\t * @notice Remove account from ACL.\n\t * @param _admin The addresses of the account to revoke permissions.\n\t * */\n\tfunction removeAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = false;\n\t\temit AdminRemoved(_admin);\n\t}\n\n\t//---PostCSOV--------------------------------------------------------------\n\n\tmodifier isNotProcessed() {\n\t\trequire(!processedList[msg.sender], \"Address cannot be processed twice\");\n\t\t_;\n\t}\n\n\tmodifier isNotBlacklisted() {\n\t\trequire(!blacklist[msg.sender], \"Address blacklisted\");\n\t\t_;\n\t}\n\n\t/**\n\t * @notice cSOV payout to sender with rBTC currency.\n\t * 1.- Check holder cSOV balance by adding up every cSOV token balance.\n\t * 2.- ReImburse rBTC if funds available.\n\t * 3.- And store holder address in processedList.\n\t */\n\tfunction reImburse() public isNotProcessed isNotBlacklisted {\n\t\tuint256 CSOVAmountWei = 0;\n\t\tfor (uint256 i = 0; i < CSOVtokens.length; i++) {\n\t\t\taddress CSOV = CSOVtokens[i];\n\t\t\tuint256 balance = IERC20(CSOV).balanceOf(msg.sender);\n\t\t\tCSOVAmountWei = CSOVAmountWei.add(balance);\n\t\t}\n\n\t\trequire(CSOVAmountWei > lockedAmount[msg.sender], \"holder has no CSOV\");\n\t\tCSOVAmountWei -= lockedAmount[msg.sender];\n\t\tprocessedList[msg.sender] = true;\n\n\t\t/**\n\t\t * @dev Found and fixed the SIP-0007 bug on VestingRegistry::reImburse formula.\n\t\t * More details at Documenting Code issues at point 11 in\n\t\t * https://docs.google.com/document/d/10idTD1K6JvoBmtPKGuJ2Ub_mMh6qTLLlTP693GQKMyU/\n\t\t * Previous buggy code: uint256 reImburseAmount = (CSOVAmountWei.mul(priceSats)).div(10**10);\n\t\t * */\n\t\tuint256 reImburseAmount = (CSOVAmountWei.mul(priceSats)).div(10**8);\n\t\trequire(address(this).balance >= reImburseAmount, \"Not enough funds to reimburse\");\n\t\tmsg.sender.transfer(reImburseAmount);\n\n\t\temit CSOVReImburse(msg.sender, CSOVAmountWei, reImburseAmount);\n\t}\n\n\t/**\n\t * @notice Get contract balance.\n\t * @return The token balance of the contract.\n\t * */\n\tfunction budget() external view returns (uint256) {\n\t\tuint256 SCBudget = address(this).balance;\n\t\treturn SCBudget;\n\t}\n\n\t/**\n\t * @notice Deposit function to receiving value (rBTC).\n\t * */\n\tfunction deposit() public payable {}\n\n\t/**\n\t * @notice Send all contract balance to an account.\n\t * @param to The account address to send the balance to.\n\t * */\n\tfunction withdrawAll(address payable to) public onlyOwner {\n\t\tto.transfer(address(this).balance);\n\t}\n\n\t//--------------------------------------------------------------------------------------------------------------------------------------\n\n\t/**\n\t * @notice Sets vesting factory address. High level endpoint.\n\t * @param _vestingFactory The address of vesting factory contract.\n\t *\n\t * @dev Splitting code on two functions: high level and low level\n\t * is a pattern that makes easy to extend functionality in a readable way,\n\t * without accidentally breaking the actual action being performed.\n\t * For example, checks should be done on high level endpoint, while core\n\t * functionality should be coded on the low level function.\n\t * */\n\tfunction setVestingFactory(address _vestingFactory) public onlyOwner {\n\t\t_setVestingFactory(_vestingFactory);\n\t}\n\n\t/**\n\t * @notice Sets vesting factory address. Low level core function.\n\t * @param _vestingFactory The address of vesting factory contract.\n\t * */\n\tfunction _setVestingFactory(address _vestingFactory) internal {\n\t\trequire(_vestingFactory != address(0), \"vestingFactory address invalid\");\n\t\tvestingFactory = IVestingFactory(_vestingFactory);\n\t}\n\n\t/**\n\t * @notice Sets cSOV tokens array. High level endpoint.\n\t * @param _CSOVtokens The array of cSOV tokens.\n\t * */\n\tfunction setCSOVtokens(address[] memory _CSOVtokens) public onlyOwner {\n\t\t_setCSOVtokens(_CSOVtokens);\n\t}\n\n\t/**\n\t * @notice Sets cSOV tokens array by looping through input. Low level function.\n\t * @param _CSOVtokens The array of cSOV tokens.\n\t * */\n\tfunction _setCSOVtokens(address[] memory _CSOVtokens) internal {\n\t\tfor (uint256 i = 0; i < _CSOVtokens.length; i++) {\n\t\t\trequire(_CSOVtokens[i] != address(0), \"CSOV address invalid\");\n\t\t}\n\t\tCSOVtokens = _CSOVtokens;\n\t}\n\n\t/**\n\t * @notice Set blacklist flag (true/false).\n\t * @param _account The address to be blacklisted.\n\t * @param _blacklisted The flag to add/remove to/from a blacklist.\n\t * */\n\tfunction setBlacklistFlag(address _account, bool _blacklisted) public onlyOwner {\n\t\trequire(_account != address(0), \"account address invalid\");\n\n\t\tblacklist[_account] = _blacklisted;\n\t}\n\n\t/**\n\t * @notice Set amount to be subtracted from user token balance.\n\t * @param _account The address with locked amount.\n\t * @param _amount The amount to be locked.\n\t * */\n\tfunction setLockedAmount(address _account, uint256 _amount) public onlyOwner {\n\t\trequire(_account != address(0), \"account address invalid\");\n\t\trequire(_amount != 0, \"amount invalid\");\n\n\t\tlockedAmount[_account] = _amount;\n\t}\n\n\t/**\n\t * @notice Transfer SOV tokens to given address.\n\t *\n\t * @dev This is a wrapper for ERC-20 transfer function w/\n\t * additional checks and triggering an event.\n\t *\n\t * @param _receiver The address of the SOV receiver.\n\t * @param _amount The amount to be transferred.\n\t * */\n\tfunction transferSOV(address _receiver, uint256 _amount) public onlyOwner {\n\t\trequire(_receiver != address(0), \"receiver address invalid\");\n\t\trequire(_amount != 0, \"amount invalid\");\n\n\t\tIERC20(SOV).transfer(_receiver, _amount);\n\t\temit SOVTransferred(_receiver, _amount);\n\t}\n\n\t/**\n\t * @notice Exchange cSOV to SOV with 1:1 rate\n\t */\n\tfunction exchangeAllCSOV() public isNotProcessed isNotBlacklisted {\n\t\tprocessedList[msg.sender] = true;\n\n\t\tuint256 amount = 0;\n\t\tfor (uint256 i = 0; i < CSOVtokens.length; i++) {\n\t\t\taddress CSOV = CSOVtokens[i];\n\t\t\tuint256 balance = IERC20(CSOV).balanceOf(msg.sender);\n\t\t\tamount += balance;\n\t\t}\n\n\t\trequire(amount > lockedAmount[msg.sender], \"amount invalid\");\n\t\tamount -= lockedAmount[msg.sender];\n\n\t\t_createVestingForCSOV(amount);\n\t}\n\n\t/**\n\t * @notice cSOV tokens are moved and staked on Vesting contract.\n\t * @param _amount The amount of tokens to be vested.\n\t * */\n\tfunction _createVestingForCSOV(uint256 _amount) internal {\n\t\taddress vesting = _getOrCreateVesting(msg.sender, CSOV_VESTING_CLIFF, CSOV_VESTING_DURATION);\n\n\t\tIERC20(SOV).approve(vesting, _amount);\n\t\tIVesting(vesting).stakeTokens(_amount);\n\n\t\temit CSOVTokensExchanged(msg.sender, _amount);\n\t}\n\n\t/**\n\t * @notice Check a token address is among the cSOV token addresses.\n\t * @param _CSOV The cSOV token address.\n\t * */\n\tfunction _validateCSOV(address _CSOV) internal view {\n\t\tbool isValid = false;\n\t\tfor (uint256 i = 0; i < CSOVtokens.length; i++) {\n\t\t\tif (_CSOV == CSOVtokens[i]) {\n\t\t\t\tisValid = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequire(isValid, \"wrong CSOV address\");\n\t}\n\n\t/**\n\t * @notice Create Vesting contract.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @param _amount The amount to be staked.\n\t * @param _cliff The time interval to the first withdraw in seconds.\n\t * @param _duration The total duration in seconds.\n\t * */\n\tfunction createVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _amount,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) public onlyAuthorized {\n\t\taddress vesting = _getOrCreateVesting(_tokenOwner, _cliff, _duration);\n\t\temit VestingCreated(_tokenOwner, vesting, _cliff, _duration, _amount);\n\t}\n\n\t/**\n\t * @notice Create Team Vesting contract.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @param _amount The amount to be staked.\n\t * @param _cliff The time interval to the first withdraw in seconds.\n\t * @param _duration The total duration in seconds.\n\t * */\n\tfunction createTeamVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _amount,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) public onlyAuthorized {\n\t\taddress vesting = _getOrCreateTeamVesting(_tokenOwner, _cliff, _duration);\n\t\temit TeamVestingCreated(_tokenOwner, vesting, _cliff, _duration, _amount);\n\t}\n\n\t/**\n\t * @notice Stake tokens according to the vesting schedule.\n\t * @param _vesting The address of Vesting contract.\n\t * @param _amount The amount of tokens to stake.\n\t * */\n\tfunction stakeTokens(address _vesting, uint256 _amount) public onlyAuthorized {\n\t\trequire(_vesting != address(0), \"vesting address invalid\");\n\t\trequire(_amount > 0, \"amount invalid\");\n\n\t\tIERC20(SOV).approve(_vesting, _amount);\n\t\tIVesting(_vesting).stakeTokens(_amount);\n\t\temit TokensStaked(_vesting, _amount);\n\t}\n\n\t/**\n\t * @notice Query the vesting contract for an account.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @return The vesting contract address for the given token owner.\n\t * */\n\tfunction getVesting(address _tokenOwner) public view returns (address) {\n\t\treturn vestingContracts[_tokenOwner][uint256(VestingType.Vesting)];\n\t}\n\n\t/**\n\t * @notice Query the team vesting contract for an account.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @return The team vesting contract address for the given token owner.\n\t * */\n\tfunction getTeamVesting(address _tokenOwner) public view returns (address) {\n\t\treturn vestingContracts[_tokenOwner][uint256(VestingType.TeamVesting)];\n\t}\n\n\t/**\n\t * @notice If not exists, deploy a vesting contract through factory.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @param _cliff The time interval to the first withdraw in seconds.\n\t * @param _duration The total duration in seconds.\n\t * @return The vesting contract address for the given token owner\n\t * whether it existed previously or not.\n\t * */\n\tfunction _getOrCreateVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) internal returns (address) {\n\t\tuint256 type_ = uint256(VestingType.Vesting);\n\t\tif (vestingContracts[_tokenOwner][type_] == address(0)) {\n\t\t\t/// @dev TODO: Owner of OwnerVesting contracts - the same address as tokenOwner.\n\t\t\taddress vesting = vestingFactory.deployVesting(SOV, staking, _tokenOwner, _cliff, _duration, feeSharingProxy, _tokenOwner);\n\t\t\tvestingContracts[_tokenOwner][type_] = vesting;\n\t\t}\n\t\treturn vestingContracts[_tokenOwner][type_];\n\t}\n\n\t/**\n\t * @notice If not exists, deploy a team vesting contract through factory.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @param _cliff The time interval to the first withdraw in seconds.\n\t * @param _duration The total duration in seconds.\n\t * @return The team vesting contract address for the given token owner\n\t * whether it existed previously or not.\n\t * */\n\tfunction _getOrCreateTeamVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) internal returns (address) {\n\t\tuint256 type_ = uint256(VestingType.TeamVesting);\n\t\tif (vestingContracts[_tokenOwner][type_] == address(0)) {\n\t\t\taddress vesting = vestingFactory.deployTeamVesting(SOV, staking, _tokenOwner, _cliff, _duration, feeSharingProxy, vestingOwner);\n\t\t\tvestingContracts[_tokenOwner][type_] = vesting;\n\t\t}\n\t\treturn vestingContracts[_tokenOwner][type_];\n\t}\n}\n"
    },
    "contracts/fish/governance/Vesting/OriginInvestorsClaim.sol": {
      "content": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"./VestingRegistry.sol\";\nimport \"../Staking/Staking.sol\";\n\n/**\n * @title Origin investors claim vested cSOV tokens.\n * @notice // TODO: fund this contract with a total amount of SOV needed to distribute.\n * */\ncontract OriginInvestorsClaim is Ownable {\n\tusing SafeMath for uint256;\n\n\t/* Storage */\n\n\t/// VestingRegistry public constant vestingRegistry = VestingRegistry(0x80B036ae59B3e38B573837c01BB1DB95515b7E6B);\n\n\tuint256 public totalAmount;\n\n\t/// @notice Constant used for computing the vesting dates.\n\tuint256 public constant SOV_VESTING_CLIFF = 6 weeks;\n\n\tuint256 public kickoffTS;\n\tuint256 public vestingTerm;\n\tuint256 public investorsQty;\n\tbool public investorsListInitialized;\n\tVestingRegistry public vestingRegistry;\n\tStaking public staking;\n\tIERC20 public SOVToken;\n\n\t/// @dev user => flag : Whether user has admin role.\n\tmapping(address => bool) public admins;\n\n\t/// @dev investor => Amount : Origin investors entitled to claim SOV.\n\tmapping(address => uint256) public investorsAmountsList;\n\n\t/* Events */\n\n\tevent AdminAdded(address admin);\n\tevent AdminRemoved(address admin);\n\tevent InvestorsAmountsListAppended(uint256 qty, uint256 amount);\n\tevent ClaimVested(address indexed investor, uint256 amount);\n\tevent ClaimTransferred(address indexed investor, uint256 amount);\n\tevent InvestorsAmountsListInitialized(uint256 qty, uint256 totalAmount);\n\n\t/* Modifiers */\n\n\t/// @dev Throws if called by any account other than the owner or admin.\n\tmodifier onlyAuthorized() {\n\t\trequire(isOwner() || admins[msg.sender], \"OriginInvestorsClaim::onlyAuthorized: should be authorized\");\n\t\t_;\n\t}\n\n\t/// @dev Throws if called by any account not whitelisted.\n\tmodifier onlyWhitelisted() {\n\t\trequire(investorsAmountsList[msg.sender] != 0, \"OriginInvestorsClaim::onlyWhitelisted: not whitelisted or already claimed\");\n\t\t_;\n\t}\n\n\t/// @dev Throws if called w/ an initialized investors list.\n\tmodifier notInitialized() {\n\t\trequire(!investorsListInitialized, \"OriginInvestorsClaim::notInitialized: the investors list should not be set as initialized\");\n\t\t_;\n\t}\n\n\t/// @dev Throws if called w/ an uninitialized investors list.\n\tmodifier initialized() {\n\t\trequire(investorsListInitialized, \"OriginInvestorsClaim::initialized: the investors list has not been set yet\");\n\t\t_;\n\t}\n\n\t/* Functions */\n\n\t/**\n\t * @notice Contract deployment requires one parameter:\n\t * @param vestingRegistryAddress The vestingRegistry contract instance address.\n\t * */\n\tconstructor(address vestingRegistryAddress) public {\n\t\tvestingRegistry = VestingRegistry(vestingRegistryAddress);\n\t\tstaking = Staking(vestingRegistry.staking());\n\t\tkickoffTS = staking.kickoffTS();\n\t\tSOVToken = staking.SOVToken();\n\t\tvestingTerm = kickoffTS + SOV_VESTING_CLIFF;\n\t}\n\n\t/**\n\t * @notice Add account to ACL.\n\t * @param _admin The addresses of the account to grant permissions.\n\t * */\n\tfunction addAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = true;\n\t\temit AdminAdded(_admin);\n\t}\n\n\t/**\n\t * @notice Remove account from ACL.\n\t * @param _admin The addresses of the account to revoke permissions.\n\t * */\n\tfunction removeAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = false;\n\t\temit AdminRemoved(_admin);\n\t}\n\n\t/**\n\t * @notice In case we have unclaimed tokens or in emergency case\n\t * this function transfers all SOV tokens to a given address.\n\t * @param toAddress The recipient address of all this contract tokens.\n\t * */\n\tfunction authorizedBalanceWithdraw(address toAddress) public onlyAuthorized {\n\t\trequire(\n\t\t\tSOVToken.transfer(toAddress, SOVToken.balanceOf(address(this))),\n\t\t\t\"OriginInvestorsClaim::authorizedTransferBalance: transfer failed\"\n\t\t);\n\t}\n\n\t/**\n\t * @notice Should be called after the investors list setup completed.\n\t * This function checks whether the SOV token balance of the contract is\n\t * enough and sets status list to initialized.\n\t * */\n\tfunction setInvestorsAmountsListInitialized() public onlyAuthorized notInitialized {\n\t\trequire(\n\t\t\tSOVToken.balanceOf(address(this)) >= totalAmount,\n\t\t\t\"OriginInvestorsClaim::setInvestorsAmountsList: the contract is not enough financed\"\n\t\t);\n\n\t\tinvestorsListInitialized = true;\n\n\t\temit InvestorsAmountsListInitialized(investorsQty, totalAmount);\n\t}\n\n\t/**\n\t * @notice The contract should be approved or transferred necessary\n\t * amount of SOV prior to calling the function.\n\t * @param investors The list of investors addresses to add to the list.\n\t * Duplicates will be skipped.\n\t * @param claimAmounts The list of amounts for investors investors[i]\n\t * will receive claimAmounts[i] of SOV.\n\t * */\n\tfunction appendInvestorsAmountsList(address[] calldata investors, uint256[] calldata claimAmounts)\n\t\texternal\n\t\tonlyAuthorized\n\t\tnotInitialized\n\t{\n\t\tuint256 subQty;\n\t\tuint256 sumAmount;\n\t\trequire(\n\t\t\tinvestors.length == claimAmounts.length,\n\t\t\t\"OriginInvestorsClaim::appendInvestorsAmountsList: investors.length != claimAmounts.length\"\n\t\t);\n\n\t\tfor (uint256 i = 0; i < investors.length; i++) {\n\t\t\tif (investorsAmountsList[investors[i]] == 0) {\n\t\t\t\tinvestorsAmountsList[investors[i]] = claimAmounts[i];\n\t\t\t\tsumAmount = sumAmount.add(claimAmounts[i]);\n\t\t\t} else {\n\t\t\t\tsubQty = subQty.add(1);\n\t\t\t}\n\t\t}\n\n\t\tinvestorsQty = investorsQty.add(investors.length.sub(subQty));\n\t\ttotalAmount = totalAmount.add(sumAmount);\n\t\temit InvestorsAmountsListAppended(investors.length.sub(subQty), sumAmount);\n\t}\n\n\t/**\n\t * @notice Claim tokens from this contract.\n\t * If vestingTerm is not yet achieved a vesting is created.\n\t * Otherwise tokens are tranferred.\n\t * */\n\tfunction claim() external onlyWhitelisted initialized {\n\t\tif (now < vestingTerm) {\n\t\t\tcreateVesting();\n\t\t} else {\n\t\t\ttransfer();\n\t\t}\n\t}\n\n\t/**\n\t * @notice Transfer tokens from this contract to a vestingRegistry contract.\n\t * Sender is removed from investor list and all its unvested tokens\n\t * are sent to vesting contract.\n\t * */\n\tfunction createVesting() internal {\n\t\tuint256 cliff = vestingTerm.sub(now);\n\t\tuint256 duration = cliff;\n\t\tuint256 amount = investorsAmountsList[msg.sender];\n\t\taddress vestingContractAddress;\n\n\t\tvestingContractAddress = vestingRegistry.getVesting(msg.sender);\n\t\trequire(vestingContractAddress == address(0), \"OriginInvestorsClaim::withdraw: the claimer has an active vesting contract\");\n\n\t\tdelete investorsAmountsList[msg.sender];\n\n\t\tvestingRegistry.createVesting(msg.sender, amount, cliff, duration);\n\t\tvestingContractAddress = vestingRegistry.getVesting(msg.sender);\n\t\trequire(SOVToken.transfer(address(vestingRegistry), amount), \"OriginInvestorsClaim::withdraw: SOV transfer failed\");\n\t\tvestingRegistry.stakeTokens(vestingContractAddress, amount);\n\n\t\temit ClaimVested(msg.sender, amount);\n\t}\n\n\t/**\n\t * @notice Transfer tokens from this contract to the sender.\n\t * Sender is removed from investor list and all its unvested tokens\n\t * are sent to its account.\n\t * */\n\tfunction transfer() internal {\n\t\tuint256 amount = investorsAmountsList[msg.sender];\n\n\t\tdelete investorsAmountsList[msg.sender];\n\n\t\t/**\n\t\t * @dev Withdraw only for those claiming after the cliff, i.e. without vesting contracts.\n\t\t * Those with vestingContracts should withdraw using Vesting.withdrawTokens\n\t\t * from Vesting (VestingLogic) contract.\n\t\t * */\n\t\trequire(SOVToken.transfer(msg.sender, amount), \"OriginInvestorsClaim::withdraw: SOV transfer failed\");\n\n\t\temit ClaimTransferred(msg.sender, amount);\n\t}\n}\n"
    },
    "contracts/fish/interfaces/IWrbtcERC20.sol": {
      "content": "/**\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\npragma solidity ^0.5.17;\n\nimport \"./IWrbtc.sol\";\nimport \"./IERC20.sol\";\n\ncontract IWrbtcERC20 is IWrbtc, IERC20 {}\n"
    },
    "contracts/fish/interfaces/IWrbtc.sol": {
      "content": "/**\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\npragma solidity ^0.5.17;\n\ninterface IWrbtc {\n\tfunction deposit() external payable;\n\n\tfunction withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/fish/interfaces/IChai.sol": {
      "content": "/**\n * Copyright 2017-2021, bZeroX, LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0.\n */\n\npragma solidity ^0.5.17;\n\nimport \"./IERC20.sol\";\n\ninterface IPot {\n\tfunction dsr() external view returns (uint256);\n\n\tfunction chi() external view returns (uint256);\n\n\tfunction rho() external view returns (uint256);\n}\n\ncontract IChai is IERC20 {\n\tfunction move(\n\t\taddress src,\n\t\taddress dst,\n\t\tuint256 wad\n\t) external returns (bool);\n\n\tfunction join(address dst, uint256 wad) external;\n\n\tfunction draw(address src, uint256 wad) external;\n\n\tfunction exit(address src, uint256 wad) external;\n}\n"
    },
    "contracts/fish/governance/Vesting/TokenSender.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"../../interfaces/IERC20.sol\";\n\n/**\n * @title SOV Token sender contract.\n *\n * @notice This contract includes functions to transfer SOV tokens\n * to a recipient or to several recipients in a list. There is\n * an ACL control check by modifier.\n *\n * @dev TODO: Maybe this token transfer functionality should be included\n * in the SOV token contract, because other contracts are requiring it too:\n * VestingRegistry.sol and VestingRegistry2.sol\n * */\ncontract TokenSender is Ownable {\n\t/* Storage */\n\n\t/// @notice The SOV token contract.\n\taddress public SOV;\n\n\t/// @dev user => flag whether user has admin role\n\tmapping(address => bool) public admins;\n\n\t/* Events */\n\n\tevent SOVTransferred(address indexed receiver, uint256 amount);\n\tevent AdminAdded(address admin);\n\tevent AdminRemoved(address admin);\n\n\t/* Functions */\n\n\tconstructor(address _SOV) public {\n\t\trequire(_SOV != address(0), \"SOV address invalid\");\n\n\t\tSOV = _SOV;\n\t}\n\n\t/* Modifiers */\n\n\t/**\n\t * @dev Throws if called by any account other than the owner or admin.\n\t * */\n\tmodifier onlyAuthorized() {\n\t\trequire(isOwner() || admins[msg.sender], \"unauthorized\");\n\t\t_;\n\t}\n\n\t/* Functions */\n\n\t/**\n\t * @notice Add account to ACL.\n\t * @param _admin The addresses of the account to grant permissions.\n\t * */\n\tfunction addAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = true;\n\t\temit AdminAdded(_admin);\n\t}\n\n\t/**\n\t * @notice Remove account from ACL.\n\t * @param _admin The addresses of the account to revoke permissions.\n\t * */\n\tfunction removeAdmin(address _admin) public onlyOwner {\n\t\tadmins[_admin] = false;\n\t\temit AdminRemoved(_admin);\n\t}\n\n\t/**\n\t * @notice Transfer given amounts of SOV to the given addresses.\n\t * @param _receivers The addresses of the SOV receivers.\n\t * @param _amounts The amounts to be transferred.\n\t * */\n\tfunction transferSOVusingList(address[] memory _receivers, uint256[] memory _amounts) public onlyAuthorized {\n\t\trequire(_receivers.length == _amounts.length, \"arrays mismatch\");\n\n\t\tfor (uint256 i = 0; i < _receivers.length; i++) {\n\t\t\t_transferSOV(_receivers[i], _amounts[i]);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Transfer SOV tokens to given address.\n\t * @param _receiver The address of the SOV receiver.\n\t * @param _amount The amount to be transferred.\n\t * */\n\tfunction transferSOV(address _receiver, uint256 _amount) public onlyAuthorized {\n\t\t_transferSOV(_receiver, _amount);\n\t}\n\n\tfunction _transferSOV(address _receiver, uint256 _amount) internal {\n\t\trequire(_receiver != address(0), \"receiver address invalid\");\n\t\trequire(_amount != 0, \"amount invalid\");\n\n\t\trequire(IERC20(SOV).transfer(_receiver, _amount), \"transfer failed\");\n\t\temit SOVTransferred(_receiver, _amount);\n\t}\n}\n"
    },
    "contracts/fish/governance/Vesting/DevelopmentFund.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../interfaces/IERC20.sol\";\n\n/**\n *  @title A holding contract for Sovryn Development Fund.\n *  @author Franklin Richards\n *  @notice You can use this contract for timed token release from Dev Fund.\n */\ncontract DevelopmentFund {\n\tusing SafeMath for uint256;\n\n\t/* Storage */\n\n\t/// @notice The SOV token contract.\n\tIERC20 public SOV;\n\n\t/// @notice The current contract status.\n\tenum Status { Deployed, Active, Expired }\n\tStatus public status;\n\n\t/// @notice The owner of the locked tokens (usually Governance).\n\taddress public lockedTokenOwner;\n\t/// @notice The owner of the unlocked tokens (usually MultiSig).\n\taddress public unlockedTokenOwner;\n\t/// @notice The emergency transfer wallet/contract.\n\taddress public safeVault;\n\t/// @notice The new locked token owner waiting to be approved.\n\taddress public newLockedTokenOwner;\n\n\t/// @notice The last token release timestamp or the time of contract creation.\n\tuint256 public lastReleaseTime;\n\n\t/// @notice The release duration array in seconds.\n\tuint256[] public releaseDuration;\n\t/// @notice The release token amount.\n\tuint256[] public releaseTokenAmount;\n\n\t/* Events */\n\n\t/// @notice Emitted when the contract is activated.\n\tevent DevelopmentFundActivated();\n\n\t/// @notice Emitted when the contract is expired due to total token transfer.\n\tevent DevelopmentFundExpired();\n\n\t/// @notice Emitted when a new locked owner is added to the contract.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _newLockedOwner The address which is added as the new locked owner.\n\t/// @dev Can only be initiated by the current locked owner.\n\tevent NewLockedOwnerAdded(address indexed _initiator, address indexed _newLockedOwner);\n\n\t/// @notice Emitted when a new locked owner is approved to the contract.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _oldLockedOwner The address of the previous locked owner.\n\t/// @param _newLockedOwner The address which is added as the new locked owner.\n\t/// @dev Can only be initiated by the current unlocked owner.\n\tevent NewLockedOwnerApproved(address indexed _initiator, address indexed _oldLockedOwner, address indexed _newLockedOwner);\n\n\t/// @notice Emitted when a new unlocked owner is updated in the contract.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _newUnlockedOwner The address which is updated as the new unlocked owner.\n\t/// @dev Can only be initiated by the current locked owner.\n\tevent UnlockedOwnerUpdated(address indexed _initiator, address indexed _newUnlockedOwner);\n\n\t/// @notice Emitted when a new token deposit is done.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _amount The total amount of token deposited.\n\tevent TokenDeposit(address indexed _initiator, uint256 _amount);\n\n\t/// @notice Emitted when a new release schedule is created.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _releaseCount The number of releases planned in the schedule.\n\tevent TokenReleaseChanged(address indexed _initiator, uint256 _releaseCount);\n\n\t/// @notice Emitted when a unlocked owner transfers all the tokens to a safe vault.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _receiver The address which receives this token withdrawn.\n\t/// @param _amount The total amount of token transferred.\n\t/// @dev This is done in an emergency situation only to a predetermined wallet by locked token owner.\n\tevent LockedTokenTransferByUnlockedOwner(address indexed _initiator, address indexed _receiver, uint256 _amount);\n\n\t/// @notice Emitted when a unlocked owner withdraws the released tokens.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _amount The total amount of token withdrawn.\n\t/// @param _releaseCount The total number of releases done based on duration.\n\tevent UnlockedTokenWithdrawalByUnlockedOwner(address indexed _initiator, uint256 _amount, uint256 _releaseCount);\n\n\t/// @notice Emitted when a locked owner transfers all the tokens to a receiver.\n\t/// @param _initiator The address which initiated this event to be emitted.\n\t/// @param _receiver The address which receives this token transfer.\n\t/// @param _amount The total amount of token transferred.\n\t/// @dev This is done only by locked token owner.\n\tevent LockedTokenTransferByLockedOwner(address indexed _initiator, address indexed _receiver, uint256 _amount);\n\n\t/* Modifiers */\n\n\tmodifier onlyLockedTokenOwner() {\n\t\trequire(msg.sender == lockedTokenOwner, \"Only Locked Token Owner can call this.\");\n\t\t_;\n\t}\n\n\tmodifier onlyUnlockedTokenOwner() {\n\t\trequire(msg.sender == unlockedTokenOwner, \"Only Unlocked Token Owner can call this.\");\n\t\t_;\n\t}\n\n\tmodifier checkStatus(Status s) {\n\t\trequire(status == s, \"The contract is not in the right state.\");\n\t\t_;\n\t}\n\n\t/* Functions */\n\n\t/**\n\t * @notice Setup the required parameters.\n\t * @param _SOV The SOV token address.\n\t * @param _lockedTokenOwner The owner of the locked tokens & contract.\n\t * @param _safeVault The emergency wallet/contract to transfer token.\n\t * @param _unlockedTokenOwner The owner of the unlocked tokens.\n\t * @param _lastReleaseTime If the last release time is to be changed, zero if no change required.\n\t * @param _releaseDuration The time duration between each release calculated from `lastReleaseTime` in seconds.\n\t * @param _releaseTokenAmount The amount of token to be released in each duration/interval.\n\t * @dev Initial release schedule should be verified, error will result in either redeployment or calling changeTokenReleaseSchedule() after init() along with token transfer.\n\t */\n\tconstructor(\n\t\taddress _SOV,\n\t\taddress _lockedTokenOwner,\n\t\taddress _safeVault,\n\t\taddress _unlockedTokenOwner,\n\t\tuint256 _lastReleaseTime,\n\t\tuint256[] memory _releaseDuration,\n\t\tuint256[] memory _releaseTokenAmount\n\t) public {\n\t\trequire(_SOV != address(0), \"Invalid SOV Address.\");\n\t\trequire(_lockedTokenOwner != address(0), \"Locked token & contract owner address invalid.\");\n\t\trequire(_safeVault != address(0), \"Safe Vault address invalid.\");\n\t\trequire(_unlockedTokenOwner != address(0), \"Unlocked token address invalid.\");\n\n\t\tSOV = IERC20(_SOV);\n\t\tlockedTokenOwner = _lockedTokenOwner;\n\t\tsafeVault = _safeVault;\n\t\tunlockedTokenOwner = _unlockedTokenOwner;\n\n\t\tlastReleaseTime = _lastReleaseTime;\n\t\t/// If last release time passed is zero, then current time stamp will be used as the last release time.\n\t\tif (_lastReleaseTime == 0) {\n\t\t\tlastReleaseTime = block.timestamp;\n\t\t}\n\n\t\t/// Checking if the schedule duration and token allocation length matches.\n\t\trequire(_releaseDuration.length == _releaseTokenAmount.length, \"Release Schedule does not match.\");\n\n\t\t/// Finally we update the token release schedule.\n\t\treleaseDuration = _releaseDuration;\n\t\treleaseTokenAmount = _releaseTokenAmount;\n\t}\n\n\t/**\n\t * @notice This function is called once after deployment for token transfer based on schedule.\n\t * @dev Without calling this function, the contract will not work.\n\t */\n\tfunction init() public checkStatus(Status.Deployed) {\n\t\tuint256[] memory _releaseTokenAmount = releaseTokenAmount;\n\t\trequire(_releaseTokenAmount.length != 0, \"Release Schedule not set.\");\n\n\t\t/// Getting the current release schedule total token amount.\n\t\tuint256 _releaseTotalTokenAmount;\n\t\tfor (uint256 amountIndex = 0; amountIndex < _releaseTokenAmount.length; amountIndex++) {\n\t\t\t_releaseTotalTokenAmount = _releaseTotalTokenAmount.add(_releaseTokenAmount[amountIndex]);\n\t\t}\n\n\t\tbool txStatus = SOV.transferFrom(msg.sender, address(this), _releaseTotalTokenAmount);\n\t\trequire(txStatus, \"Not enough token sent to change release schedule.\");\n\n\t\tstatus = Status.Active;\n\n\t\temit DevelopmentFundActivated();\n\t}\n\n\t/**\n\t * @notice Update Locked Token Owner.\n\t * @param _newLockedTokenOwner The owner of the locked tokens & contract.\n\t */\n\tfunction updateLockedTokenOwner(address _newLockedTokenOwner) public onlyLockedTokenOwner checkStatus(Status.Active) {\n\t\trequire(_newLockedTokenOwner != address(0), \"New locked token owner address invalid.\");\n\n\t\tnewLockedTokenOwner = _newLockedTokenOwner;\n\n\t\temit NewLockedOwnerAdded(msg.sender, _newLockedTokenOwner);\n\t}\n\n\t/**\n\t * @notice Approve Locked Token Owner.\n\t * @dev This approval is an added security to avoid development fund takeover by a compromised locked token owner.\n\t */\n\tfunction approveLockedTokenOwner() public onlyUnlockedTokenOwner checkStatus(Status.Active) {\n\t\trequire(newLockedTokenOwner != address(0), \"No new locked owner added.\");\n\n\t\temit NewLockedOwnerApproved(msg.sender, lockedTokenOwner, newLockedTokenOwner);\n\n\t\tlockedTokenOwner = newLockedTokenOwner;\n\n\t\tnewLockedTokenOwner = address(0);\n\t}\n\n\t/**\n\t * @notice Update Unlocked Token Owner.\n\t * @param _newUnlockedTokenOwner The new unlocked token owner.\n\t */\n\tfunction updateUnlockedTokenOwner(address _newUnlockedTokenOwner) public onlyLockedTokenOwner checkStatus(Status.Active) {\n\t\trequire(_newUnlockedTokenOwner != address(0), \"New unlocked token owner address invalid.\");\n\n\t\tunlockedTokenOwner = _newUnlockedTokenOwner;\n\n\t\temit UnlockedOwnerUpdated(msg.sender, _newUnlockedTokenOwner);\n\t}\n\n\t/**\n\t * @notice Deposit tokens to this contract.\n\t * @param _amount the amount of tokens deposited.\n\t * @dev These tokens can be withdrawn/transferred any time by the lockedTokenOwner.\n\t */\n\tfunction depositTokens(uint256 _amount) public checkStatus(Status.Active) {\n\t\trequire(_amount > 0, \"Amount needs to be bigger than zero.\");\n\n\t\tbool txStatus = SOV.transferFrom(msg.sender, address(this), _amount);\n\t\trequire(txStatus, \"Token transfer was not successful.\");\n\n\t\temit TokenDeposit(msg.sender, _amount);\n\t}\n\n\t/**\n\t * @notice Change the Token release schedule. It creates a completely new schedule, and does not append on the previous one.\n\t * @param _newLastReleaseTime If the last release time is to be changed, zero if no change required.\n\t * @param _releaseDuration The time duration between each release calculated from `lastReleaseTime` in seconds.\n\t * @param _releaseTokenAmount The amount of token to be released in each duration/interval.\n\t * @dev _releaseDuration and _releaseTokenAmount should be specified in reverse order of release.\n\t */\n\tfunction changeTokenReleaseSchedule(\n\t\tuint256 _newLastReleaseTime,\n\t\tuint256[] memory _releaseDuration,\n\t\tuint256[] memory _releaseTokenAmount\n\t) public onlyLockedTokenOwner checkStatus(Status.Active) {\n\t\t/// Checking if the schedule duration and token allocation length matches.\n\t\trequire(_releaseDuration.length == _releaseTokenAmount.length, \"Release Schedule does not match.\");\n\n\t\t/// If the last release time has to be changed, then you can pass a new one here.\n\t\t/// Or else, the duration of release will be calculated based on this timestamp.\n\t\t/// Even a future timestamp can be mentioned here.\n\t\tif (_newLastReleaseTime != 0) {\n\t\t\tlastReleaseTime = _newLastReleaseTime;\n\t\t}\n\n\t\t/// Checking if the contract have enough token balance for the release.\n\t\tuint256 _releaseTotalTokenAmount;\n\t\tfor (uint256 amountIndex = 0; amountIndex < _releaseTokenAmount.length; amountIndex++) {\n\t\t\t_releaseTotalTokenAmount = _releaseTotalTokenAmount.add(_releaseTokenAmount[amountIndex]);\n\t\t}\n\n\t\t/// Getting the current token balance of the contract.\n\t\tuint256 remainingTokens = SOV.balanceOf(address(this));\n\n\t\t/// If the token balance is not sufficient, then we transfer the change to contract.\n\t\tif (remainingTokens < _releaseTotalTokenAmount) {\n\t\t\tbool txStatus = SOV.transferFrom(msg.sender, address(this), _releaseTotalTokenAmount.sub(remainingTokens));\n\t\t\trequire(txStatus, \"Not enough token sent to change release schedule.\");\n\t\t} else if (remainingTokens > _releaseTotalTokenAmount) {\n\t\t\t/// If there are more tokens than required, send the extra tokens back.\n\t\t\tbool txStatus = SOV.transfer(msg.sender, remainingTokens.sub(_releaseTotalTokenAmount));\n\t\t\trequire(txStatus, \"Token not received by the Locked Owner.\");\n\t\t}\n\n\t\t/// Finally we update the token release schedule.\n\t\treleaseDuration = _releaseDuration;\n\t\treleaseTokenAmount = _releaseTokenAmount;\n\n\t\temit TokenReleaseChanged(msg.sender, _releaseDuration.length);\n\t}\n\n\t/**\n\t * @notice Transfers all of the remaining tokens in an emergency situation.\n\t * @dev This could be called when governance or development fund might be compromised.\n\t */\n\tfunction transferTokensByUnlockedTokenOwner() public onlyUnlockedTokenOwner checkStatus(Status.Active) {\n\t\tuint256 remainingTokens = SOV.balanceOf(address(this));\n\t\tbool txStatus = SOV.transfer(safeVault, remainingTokens);\n\t\trequire(txStatus, \"Token transfer was not successful. Check receiver address.\");\n\t\tstatus = Status.Expired;\n\n\t\temit LockedTokenTransferByUnlockedOwner(msg.sender, safeVault, remainingTokens);\n\t\temit DevelopmentFundExpired();\n\t}\n\n\t/**\n\t * @notice Withdraws all unlocked/released token.\n\t * @param _amount The amount to be withdrawn.\n\t */\n\tfunction withdrawTokensByUnlockedTokenOwner(uint256 _amount) public onlyUnlockedTokenOwner checkStatus(Status.Active) {\n\t\trequire(_amount > 0, \"Zero can't be withdrawn.\");\n\n\t\tuint256 count; /// To know how many elements to be removed from the release schedule.\n\t\tuint256 amount = _amount; /// To know the total amount to be transferred.\n\t\tuint256 newLastReleaseTimeMemory = lastReleaseTime; /// Better to use memory than storage.\n\t\tuint256 releaseLength = releaseDuration.length.sub(1); /// Also checks if there are any elements in the release schedule.\n\n\t\t/// Getting the amount of tokens, the number of releases and calculating the total duration.\n\t\twhile (amount > 0 && newLastReleaseTimeMemory.add(releaseDuration[releaseLength]) < block.timestamp) {\n\t\t\tif (amount >= releaseTokenAmount[releaseLength]) {\n\t\t\t\tamount = amount.sub(releaseTokenAmount[releaseLength]);\n\t\t\t\tnewLastReleaseTimeMemory = newLastReleaseTimeMemory.add(releaseDuration[releaseLength]);\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\t/// This will be the last case, if correct amount is passed.\n\t\t\t\treleaseTokenAmount[releaseLength] = releaseTokenAmount[releaseLength].sub(amount);\n\t\t\t\tamount = 0;\n\t\t\t}\n\t\t\treleaseLength--;\n\t\t}\n\n\t\t/// Checking to see if atleast a single schedule was reached or not.\n\t\trequire(count > 0 || amount == 0, \"No release schedule reached.\");\n\n\t\t/// If locked token owner tries to send a higher amount that schedule\n\t\tuint256 value = _amount.sub(amount);\n\n\t\t/// Now clearing up the release schedule.\n\t\treleaseDuration.length -= count;\n\t\treleaseTokenAmount.length -= count;\n\n\t\t/// Updating the last release time.\n\t\tlastReleaseTime = newLastReleaseTimeMemory;\n\n\t\t/// Sending the amount to unlocked token owner.\n\t\tbool txStatus = SOV.transfer(msg.sender, value);\n\t\trequire(txStatus, \"Token transfer was not successful. Check receiver address.\");\n\n\t\temit UnlockedTokenWithdrawalByUnlockedOwner(msg.sender, value, count);\n\t}\n\n\t/**\n\t * @notice Transfers all of the remaining tokens by the owner maybe for an upgrade.\n\t * @dev This could be called when the current development fund has to be upgraded.\n\t * @param _receiver The address which receives this token transfer.\n\t */\n\tfunction transferTokensByLockedTokenOwner(address _receiver) public onlyLockedTokenOwner checkStatus(Status.Active) {\n\t\tuint256 remainingTokens = SOV.balanceOf(address(this));\n\t\tbool txStatus = SOV.transfer(_receiver, remainingTokens);\n\t\trequire(txStatus, \"Token transfer was not successful. Check receiver address.\");\n\t\tstatus = Status.Expired;\n\n\t\temit LockedTokenTransferByLockedOwner(msg.sender, _receiver, remainingTokens);\n\t\temit DevelopmentFundExpired();\n\t}\n\n\t/* Getter Functions */\n\n\t/**\n\t * @notice Function to read the current token release duration.\n\t * @return _currentReleaseDuration The current release duration.\n\t */\n\tfunction getReleaseDuration() public view returns (uint256[] memory _releaseTokenDuration) {\n\t\treturn releaseDuration;\n\t}\n\n\t/**\n\t * @notice Function to read the current token release amount.\n\t * @return _currentReleaseTokenAmount The current release token amount.\n\t */\n\tfunction getReleaseTokenAmount() public view returns (uint256[] memory _currentReleaseTokenAmount) {\n\t\treturn releaseTokenAmount;\n\t}\n}\n"
    },
    "contracts/fish/governance/GovernorVault.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"../interfaces/IERC20.sol\";\n\n/**\n * @title Governance Vault.\n * @notice This contract stores tokens and rBTC only transfereble by owner,\n * i.e. Sovryn governance.\n * */\ncontract GovernorVault is Ownable {\n\t/* Events */\n\n\tevent Deposited(address indexed sender, uint256 amount);\n\tevent TokensTransferred(address indexed receiver, address indexed token, uint256 amount);\n\tevent RbtcTransferred(address indexed receiver, uint256 amount);\n\n\t/* Functions */\n\n\t/**\n\t * @notice Transfer tokens.\n\t * @param _receiver The receiver of tokens.\n\t * @param _token The address of token contract.\n\t * @param _amount The amount to be transferred.\n\t * */\n\tfunction transferTokens(\n\t\taddress _receiver,\n\t\taddress _token,\n\t\tuint256 _amount\n\t) public onlyOwner {\n\t\trequire(_receiver != address(0), \"Invalid receiver address\");\n\t\trequire(_token != address(0), \"Invalid token address\");\n\n\t\trequire(IERC20(_token).transfer(_receiver, _amount), \"Transfer failed\");\n\t\temit TokensTransferred(_receiver, _token, _amount);\n\t}\n\n\t/**\n\t * @notice Transfer RBTC.\n\t * @param _receiver The receiver of RBTC.\n\t * @param _amount The amount to be transferred.\n\t * */\n\tfunction transferRbtc(address payable _receiver, uint256 _amount) public onlyOwner {\n\t\trequire(_receiver != address(0), \"Invalid receiver address\");\n\n\t\taddress(_receiver).transfer(_amount);\n\t\temit RbtcTransferred(_receiver, _amount);\n\t}\n\n\t/**\n\t * @notice Fallback function is to react to receiving value (rBTC).\n\t * */\n\tfunction() external payable {\n\t\tif (msg.value > 0) {\n\t\t\temit Deposited(msg.sender, msg.value);\n\t\t}\n\t}\n}\n"
    },
    "contracts/fish/governance/Staking/StakingProxy.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"./StakingStorage.sol\";\nimport \"../proxy/UpgradableProxy.sol\";\n\n/**\n * @title Staking Proxy contract.\n * @dev Staking contract should be upgradable, use UpgradableProxy.\n * StakingStorage is deployed with the upgradable functionality\n * by using this contract instead, that inherits from UpgradableProxy\n * the possibility of being enhanced and re-deployed.\n * */\ncontract StakingProxy is StakingStorage, UpgradableProxy {\n\t/**\n\t * @notice Construct a new staking contract.\n\t * @param SOV The address of the SOV token address.\n\t */\n\tconstructor(address SOV) public {\n\t\tSOVToken = IERC20(SOV);\n\t\tkickoffTS = block.timestamp;\n\t}\n}\n"
    },
    "contracts/fish/governance/proxy/UpgradableProxy.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"./Proxy.sol\";\n\n/**\n * @title Upgradable Proxy contract.\n * @notice A disadvantage of the immutable ledger is that nobody can change the\n * source code of a smart contract after itâ€™s been deployed. In order to fix\n * bugs or introduce new features, smart contracts need to be upgradable somehow.\n *\n * Although it is not possible to upgrade the code of an already deployed smart\n * contract, it is possible to set-up a proxy contract architecture that will\n * allow to use new deployed contracts as if the main logic had been upgraded.\n *\n * A proxy architecture pattern is such that all message calls go through a\n * Proxy contract that will redirect them to the latest deployed contract logic.\n * To upgrade, a new version of the contract is deployed, and the Proxy is\n * updated to reference the new contract address.\n * */\ncontract UpgradableProxy is Proxy {\n\t/**\n\t * @notice Set address of the implementation.\n\t * @dev Wrapper for _setImplementation that exposes the function\n\t * as public for owner to be able to set a new version of the\n\t * contract as current pointing implementation.\n\t * @param _implementation Address of the implementation.\n\t * */\n\tfunction setImplementation(address _implementation) public onlyProxyOwner {\n\t\t_setImplementation(_implementation);\n\t}\n\n\t/**\n\t * @notice Set address of the owner.\n\t * @param _owner Address of the owner.\n\t * */\n\tfunction setProxyOwner(address _owner) public onlyProxyOwner {\n\t\t_setProxyOwner(_owner);\n\t}\n}\n"
    },
    "contracts/fish/governance/Vesting/OrigingVestingCreator.sol": {
      "content": "pragma solidity ^0.5.17;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"./VestingRegistry.sol\";\n\n/**\n * @title Temp contract for checking address, creating and staking tokens.\n * @notice It casts an instance of vestingRegistry and by using createVesting\n * function it creates a vesting, gets it and stakes some tokens w/ this vesting.\n * */\ncontract OrigingVestingCreator is Ownable {\n\tVestingRegistry public vestingRegistry;\n\n\tmapping(address => bool) processedList;\n\n\tconstructor(address _vestingRegistry) public {\n\t\tvestingRegistry = VestingRegistry(_vestingRegistry);\n\t}\n\n\t/**\n\t * @notice Create a vesting, get it and stake some tokens w/ this vesting.\n\t * @param _tokenOwner The owner of the tokens.\n\t * @param _amount The amount of tokens to be vested.\n\t * @param _cliff The time interval to the first withdraw in seconds.\n\t * @param _duration The total duration in seconds.\n\t * */\n\tfunction createVesting(\n\t\taddress _tokenOwner,\n\t\tuint256 _amount,\n\t\tuint256 _cliff,\n\t\tuint256 _duration\n\t) public onlyOwner {\n\t\trequire(_tokenOwner != address(0), \"Invalid address\");\n\t\trequire(!processedList[_tokenOwner], \"Already processed\");\n\n\t\tprocessedList[_tokenOwner] = true;\n\n\t\tvestingRegistry.createVesting(_tokenOwner, _amount, _cliff, _duration);\n\t\taddress vesting = vestingRegistry.getVesting(_tokenOwner);\n\t\tvestingRegistry.stakeTokens(vesting, _amount);\n\t}\n}\n"
    },
    "contracts/fish/governance/mocks/TimelockMock.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../ErrorDecoder.sol\";\nimport { ITimelock } from \"../Timelock.sol\";\n\n/**\n * @dev This contract is a copy of `Timelock.sol` with changed value of MINIMUM_DELAY for tests purposes\n * */\ncontract TimelockMock is ErrorDecoder, ITimelock {\n\tusing SafeMath for uint256;\n\n\tuint256 public constant GRACE_PERIOD = 14 days;\n\tuint256 public constant MINIMUM_DELAY = 0;\n\tuint256 public constant MAXIMUM_DELAY = 30 days;\n\n\taddress public admin;\n\taddress public pendingAdmin;\n\tuint256 public delay;\n\n\tmapping(bytes32 => bool) public queuedTransactions;\n\n\tevent NewAdmin(address indexed newAdmin);\n\tevent NewPendingAdmin(address indexed newPendingAdmin);\n\tevent NewDelay(uint256 indexed newDelay);\n\tevent CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n\tevent ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n\tevent QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n\n\t/**\n\t * @notice Function called on instance deployment of the contract.\n\t * @param admin_ Governance contract address.\n\t * @param delay_ Time to wait for queued transactions to be executed.\n\t * */\n\tconstructor(address admin_, uint256 delay_) public {\n\t\trequire(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n\t\trequire(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n\t\tadmin = admin_;\n\t\tdelay = delay_;\n\t}\n\n\t/**\n\t * @notice Fallback function is to react to receiving value (rBTC).\n\t * */\n\tfunction() external payable {}\n\n\t/**\n\t * @notice Set a new delay when executing the contract calls.\n\t * @param delay_ The amount of time to wait until execution.\n\t * */\n\tfunction setDelay(uint256 delay_) public {\n\t\trequire(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n\t\trequire(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n\t\trequire(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\t\tdelay = delay_;\n\n\t\temit NewDelay(delay);\n\t}\n\n\t/**\n\t * @notice Accept a new admin for the timelock.\n\t * */\n\tfunction acceptAdmin() public {\n\t\trequire(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n\t\tadmin = msg.sender;\n\t\tpendingAdmin = address(0);\n\n\t\temit NewAdmin(admin);\n\t}\n\n\t/**\n\t * @notice Set a new pending admin for the timelock.\n\t * @param pendingAdmin_ The new pending admin address.\n\t * */\n\tfunction setPendingAdmin(address pendingAdmin_) public {\n\t\trequire(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n\t\tpendingAdmin = pendingAdmin_;\n\n\t\temit NewPendingAdmin(pendingAdmin);\n\t}\n\n\t/**\n\t * @notice Queue a new transaction from the governance contract.\n\t * @param target The contract to call.\n\t * @param value The amount to send in the transaction.\n\t * @param signature The stanndard representation of the function called.\n\t * @param data The ethereum transaction input data payload.\n\t * @param eta Estimated Time of Accomplishment. The timestamp that the\n\t * proposal will be available for execution, set once the vote succeeds.\n\t * */\n\tfunction queueTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring memory signature,\n\t\tbytes memory data,\n\t\tuint256 eta\n\t) public returns (bytes32) {\n\t\trequire(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n\t\trequire(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n\t\tbytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\t\tqueuedTransactions[txHash] = true;\n\n\t\temit QueueTransaction(txHash, target, value, signature, data, eta);\n\t\treturn txHash;\n\t}\n\n\t/**\n\t * @notice Cancel a transaction.\n\t * @param target The contract to call.\n\t * @param value The amount to send in the transaction.\n\t * @param signature The stanndard representation of the function called.\n\t * @param data The ethereum transaction input data payload.\n\t * @param eta Estimated Time of Accomplishment. The timestamp that the\n\t * proposal will be available for execution, set once the vote succeeds.\n\t * */\n\tfunction cancelTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring memory signature,\n\t\tbytes memory data,\n\t\tuint256 eta\n\t) public {\n\t\trequire(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n\t\tbytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\t\tqueuedTransactions[txHash] = false;\n\n\t\temit CancelTransaction(txHash, target, value, signature, data, eta);\n\t}\n\n\t/**\n\t * @notice Executes a previously queued transaction from the governance.\n\t * @param target The contract to call.\n\t * @param value The amount to send in the transaction.\n\t * @param signature The stanndard representation of the function called.\n\t * @param data The ethereum transaction input data payload.\n\t * @param eta Estimated Time of Accomplishment. The timestamp that the\n\t * proposal will be available for execution, set once the vote succeeds.\n\t * */\n\tfunction executeTransaction(\n\t\taddress target,\n\t\tuint256 value,\n\t\tstring memory signature,\n\t\tbytes memory data,\n\t\tuint256 eta\n\t) public payable returns (bytes memory) {\n\t\trequire(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n\t\tbytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\t\trequire(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n\t\trequire(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n\t\trequire(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n\t\tqueuedTransactions[txHash] = false;\n\n\t\tbytes memory callData;\n\n\t\tif (bytes(signature).length == 0) {\n\t\t\tcallData = data;\n\t\t} else {\n\t\t\tcallData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n\t\t}\n\n\t\t// solium-disable-next-line security/no-call-value\n\t\t(bool success, bytes memory returnData) = target.call.value(value)(callData);\n\t\tif (!success) {\n\t\t\tif (returnData.length <= ERROR_MESSAGE_SHIFT) {\n\t\t\t\trevert(\"Timelock::executeTransaction: Transaction execution reverted.\");\n\t\t\t} else {\n\t\t\t\trevert(_addErrorMessage(\"Timelock::executeTransaction: \", string(returnData)));\n\t\t\t}\n\t\t}\n\n\t\temit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n\t\treturn returnData;\n\t}\n\n\t/**\n\t * @notice A function used to get the current Block Timestamp.\n\t * @dev Timestamp of the current block in seconds since the epoch.\n\t * It is a Unix time stamp. So, it has the complete information about\n\t * the date, hours, minutes, and seconds (in UTC) when the block was\n\t * created.\n\t * */\n\tfunction getBlockTimestamp() internal view returns (uint256) {\n\t\t// solium-disable-next-line security/no-block-members\n\t\treturn block.timestamp;\n\t}\n}\n"
    },
    "contracts/mocks/helpers/InitializableReentrancyGuardMock.sol": {
      "content": "pragma solidity ^0.5.17;\n\nimport { InitializableReentrancyGuard } from \"../../helpers/InitializableReentrancyGuard.sol\";\n\ninterface IReentrantMock {\n    function clientMethod () external returns(bool);\n}\n\ncontract ReentrantMock is IReentrantMock {\n    address contractAddress;\n\n    constructor (address _contractAddress) public {\n        contractAddress = _contractAddress;\n    }\n\n    function clientMethod() public returns(bool) {\n        InitializableReentrancyMock reentrancyMock = InitializableReentrancyMock(contractAddress);\n        reentrancyMock.runClientMethod(address(this));\n        return true;\n    }\n}\n\ncontract NonReentrantMock is IReentrantMock {\n    function clientMethod() public returns(bool) {\n        return true;\n    }\n}\n\ncontract InitializableReentrancyMock is InitializableReentrancyGuard {\n    function initialize () public {\n        _initialize();\n\n    }\n\n    function runClientMethod (address reentrantMockAddress) public nonReentrant {\n        IReentrantMock reentrantMock = IReentrantMock(reentrantMockAddress);\n        require(reentrantMock.clientMethod(), \"\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}